// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package interfaces

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// Attributes:
//  - Exc
type TransactionException struct {
  Exc string `thrift:"exc,1" db:"exc" json:"exc"`
}

func NewTransactionException() *TransactionException {
  return &TransactionException{}
}


func (p *TransactionException) GetExc() string {
  return p.Exc
}
func (p *TransactionException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TransactionException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Exc = v
}
  return nil
}

func (p *TransactionException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TransactionException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TransactionException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "exc", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:exc: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Exc)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.exc (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:exc: ", p), err) }
  return err
}

func (p *TransactionException) Equals(other *TransactionException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Exc != other.Exc { return false }
  return true
}

func (p *TransactionException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TransactionException(%+v)", *p)
}

func (p *TransactionException) Error() string {
  return p.String()
}

func (TransactionException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TransactionException)(nil)

// Attributes:
//  - ErrorMessage
type AssertException struct {
  ErrorMessage string `thrift:"error_message,1" db:"error_message" json:"error_message"`
}

func NewAssertException() *AssertException {
  return &AssertException{}
}


func (p *AssertException) GetErrorMessage() string {
  return p.ErrorMessage
}
func (p *AssertException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AssertException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ErrorMessage = v
}
  return nil
}

func (p *AssertException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AssertException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AssertException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "error_message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:error_message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ErrorMessage)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.error_message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:error_message: ", p), err) }
  return err
}

func (p *AssertException) Equals(other *AssertException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ErrorMessage != other.ErrorMessage { return false }
  return true
}

func (p *AssertException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AssertException(%+v)", *p)
}

func (p *AssertException) Error() string {
  return p.String()
}

func (AssertException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*AssertException)(nil)

// Attributes:
//  - Account
//  - Action
//  - Permissions
//  - Arguments
type Action struct {
  Account string `thrift:"account,1" db:"account" json:"account"`
  Action string `thrift:"action,2" db:"action" json:"action"`
  Permissions string `thrift:"permissions,3" db:"permissions" json:"permissions"`
  Arguments string `thrift:"arguments,4" db:"arguments" json:"arguments"`
}

func NewAction() *Action {
  return &Action{}
}


func (p *Action) GetAccount() string {
  return p.Account
}

func (p *Action) GetAction() string {
  return p.Action
}

func (p *Action) GetPermissions() string {
  return p.Permissions
}

func (p *Action) GetArguments() string {
  return p.Arguments
}
func (p *Action) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Action)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *Action)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *Action)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *Action)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Arguments = v
}
  return nil
}

func (p *Action) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Action"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Action) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *Action) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:action: ", p), err) }
  return err
}

func (p *Action) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:permissions: ", p), err) }
  return err
}

func (p *Action) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Arguments)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.arguments (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *Action) Equals(other *Action) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Account != other.Account { return false }
  if p.Action != other.Action { return false }
  if p.Permissions != other.Permissions { return false }
  if p.Arguments != other.Arguments { return false }
  return true
}

func (p *Action) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Action(%+v)", *p)
}

// Attributes:
//  - RawValue
type Uint64 struct {
  RawValue []byte `thrift:"rawValue,1" db:"rawValue" json:"rawValue"`
}

func NewUint64() *Uint64 {
  return &Uint64{}
}


func (p *Uint64) GetRawValue() []byte {
  return p.RawValue
}
func (p *Uint64) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Uint64)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RawValue = v
}
  return nil
}

func (p *Uint64) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Uint64"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Uint64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rawValue", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rawValue: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawValue); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rawValue (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rawValue: ", p), err) }
  return err
}

func (p *Uint64) Equals(other *Uint64) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.RawValue, other.RawValue) != 0 { return false }
  return true
}

func (p *Uint64) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Uint64(%+v)", *p)
}

// Attributes:
//  - Size
//  - Buffer
type DataBuffer struct {
  Size int32 `thrift:"size,1" db:"size" json:"size"`
  Buffer []byte `thrift:"buffer,2" db:"buffer" json:"buffer"`
}

func NewDataBuffer() *DataBuffer {
  return &DataBuffer{}
}


func (p *DataBuffer) GetSize() int32 {
  return p.Size
}

func (p *DataBuffer) GetBuffer() []byte {
  return p.Buffer
}
func (p *DataBuffer) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DataBuffer)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Size = v
}
  return nil
}

func (p *DataBuffer)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Buffer = v
}
  return nil
}

func (p *DataBuffer) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DataBuffer"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DataBuffer) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "size", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:size: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Size)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.size (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:size: ", p), err) }
  return err
}

func (p *DataBuffer) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "buffer", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:buffer: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Buffer); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.buffer (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:buffer: ", p), err) }
  return err
}

func (p *DataBuffer) Equals(other *DataBuffer) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Size != other.Size { return false }
  if bytes.Compare(p.Buffer, other.Buffer) != 0 { return false }
  return true
}

func (p *DataBuffer) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DataBuffer(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type NextPreviousReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewNextPreviousReturn() *NextPreviousReturn {
  return &NextPreviousReturn{}
}


func (p *NextPreviousReturn) GetIterator() int32 {
  return p.Iterator
}
var NextPreviousReturn_Primary_DEFAULT *Uint64
func (p *NextPreviousReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return NextPreviousReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *NextPreviousReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *NextPreviousReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NextPreviousReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *NextPreviousReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *NextPreviousReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NextPreviousReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NextPreviousReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *NextPreviousReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *NextPreviousReturn) Equals(other *NextPreviousReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *NextPreviousReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NextPreviousReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type IteratorPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewIteratorPrimaryReturn() *IteratorPrimaryReturn {
  return &IteratorPrimaryReturn{}
}


func (p *IteratorPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}
var IteratorPrimaryReturn_Primary_DEFAULT *Uint64
func (p *IteratorPrimaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return IteratorPrimaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *IteratorPrimaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *IteratorPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "IteratorPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IteratorPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) Equals(other *IteratorPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *IteratorPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IteratorPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
type FindPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
}

func NewFindPrimaryReturn() *FindPrimaryReturn {
  return &FindPrimaryReturn{}
}


func (p *FindPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *FindPrimaryReturn) GetSecondary() []byte {
  return p.Secondary
}
func (p *FindPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *FindPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) Equals(other *FindPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  return true
}

func (p *FindPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type FindSecondaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewFindSecondaryReturn() *FindSecondaryReturn {
  return &FindSecondaryReturn{}
}


func (p *FindSecondaryReturn) GetIterator() int32 {
  return p.Iterator
}
var FindSecondaryReturn_Primary_DEFAULT *Uint64
func (p *FindSecondaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return FindSecondaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *FindSecondaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *FindSecondaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindSecondaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindSecondaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *FindSecondaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindSecondaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindSecondaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) Equals(other *FindSecondaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *FindSecondaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindSecondaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
//  - Primary
type LowerBoundUpperBoundReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,3" db:"primary" json:"primary"`
}

func NewLowerBoundUpperBoundReturn() *LowerBoundUpperBoundReturn {
  return &LowerBoundUpperBoundReturn{}
}


func (p *LowerBoundUpperBoundReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *LowerBoundUpperBoundReturn) GetSecondary() []byte {
  return p.Secondary
}
var LowerBoundUpperBoundReturn_Primary_DEFAULT *Uint64
func (p *LowerBoundUpperBoundReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return LowerBoundUpperBoundReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *LowerBoundUpperBoundReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *LowerBoundUpperBoundReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LowerBoundUpperBoundReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LowerBoundUpperBoundReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:primary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) Equals(other *LowerBoundUpperBoundReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *LowerBoundUpperBoundReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LowerBoundUpperBoundReturn(%+v)", *p)
}

// Attributes:
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
type GetResourceLimitsReturn struct {
  RAMBytes int64 `thrift:"ram_bytes,1" db:"ram_bytes" json:"ram_bytes"`
  NetWeight int64 `thrift:"net_weight,2" db:"net_weight" json:"net_weight"`
  CPUWeight int64 `thrift:"cpu_weight,3" db:"cpu_weight" json:"cpu_weight"`
}

func NewGetResourceLimitsReturn() *GetResourceLimitsReturn {
  return &GetResourceLimitsReturn{}
}


func (p *GetResourceLimitsReturn) GetRAMBytes() int64 {
  return p.RAMBytes
}

func (p *GetResourceLimitsReturn) GetNetWeight() int64 {
  return p.NetWeight
}

func (p *GetResourceLimitsReturn) GetCPUWeight() int64 {
  return p.CPUWeight
}
func (p *GetResourceLimitsReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RAMBytes = v
}
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NetWeight = v
}
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.CPUWeight = v
}
  return nil
}

func (p *GetResourceLimitsReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetResourceLimitsReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetResourceLimitsReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ram_bytes", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ram_bytes: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RAMBytes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ram_bytes (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ram_bytes: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "net_weight", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:net_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NetWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.net_weight (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:net_weight: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cpu_weight", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:cpu_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CPUWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cpu_weight (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:cpu_weight: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) Equals(other *GetResourceLimitsReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.RAMBytes != other.RAMBytes { return false }
  if p.NetWeight != other.NetWeight { return false }
  if p.CPUWeight != other.CPUWeight { return false }
  return true
}

func (p *GetResourceLimitsReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetResourceLimitsReturn(%+v)", *p)
}

type IPCChainTester interface {
  InitVMAPI(ctx context.Context) (_err error)
  InitApplyRequest(ctx context.Context) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Enable
  EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error)
  // Parameters:
  //  - Abi
  PackAbi(ctx context.Context, abi string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - ActionArgs_
  PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - RawArgs_
  UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error)
  NewChain_(ctx context.Context) (_r int32, _err error)
  // Parameters:
  //  - ID
  FreeChain(ctx context.Context, id int32) (_r int32, _err error)
  // Parameters:
  //  - ID
  ProduceBlock(ctx context.Context, id int32) (_err error)
  // Parameters:
  //  - ID
  //  - Account
  //  - Action
  //  - Arguments
  //  - Permissions
  PushAction(ctx context.Context, id int32, account string, action string, arguments string, permissions string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Actions
  PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - JSON
  //  - Code
  //  - Scope
  //  - Table
  //  - LowerBound
  //  - UpperBound
  //  - Limit
  //  - KeyType
  //  - IndexPosition
  //  - Reverse
  //  - ShowPayer
  GetTableRows(ctx context.Context, id int32, json bool, code string, scope string, table string, lower_bound string, upper_bound string, limit int64, key_type string, index_position string, reverse bool, show_payer bool) (_r string, _err error)
}

type IPCChainTesterClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewIPCChainTesterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewIPCChainTesterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewIPCChainTesterClient(c thrift.TClient) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: c,
  }
}

func (p *IPCChainTesterClient) Client_() thrift.TClient {
  return p.c
}

func (p *IPCChainTesterClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *IPCChainTesterClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *IPCChainTesterClient) InitVMAPI(ctx context.Context) (_err error) {
  var _args0 IPCChainTesterInitVMAPIArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_vm_api", &_args0, nil); err != nil {
    return err
  }
  return nil
}

func (p *IPCChainTesterClient) InitApplyRequest(ctx context.Context) (_err error) {
  var _args1 IPCChainTesterInitApplyRequestArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_apply_request", &_args1, nil); err != nil {
    return err
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
//  - Enable
func (p *IPCChainTesterClient) EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error) {
  var _args2 IPCChainTesterEnableDebugContractArgs
  _args2.ID = id
  _args2.Contract = contract
  _args2.Enable = enable
  var _result4 IPCChainTesterEnableDebugContractResult
  var _meta3 thrift.ResponseMeta
  _meta3, _err = p.Client_().Call(ctx, "enable_debug_contract", &_args2, &_result4)
  p.SetLastResponseMeta_(_meta3)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
func (p *IPCChainTesterClient) IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error) {
  var _args5 IPCChainTesterIsDebugContractEnabledArgs
  _args5.ID = id
  _args5.Contract = contract
  var _result7 IPCChainTesterIsDebugContractEnabledResult
  var _meta6 thrift.ResponseMeta
  _meta6, _err = p.Client_().Call(ctx, "is_debug_contract_enabled", &_args5, &_result7)
  p.SetLastResponseMeta_(_meta6)
  if _err != nil {
    return
  }
  return _result7.GetSuccess(), nil
}

// Parameters:
//  - Abi
func (p *IPCChainTesterClient) PackAbi(ctx context.Context, abi string) (_r []byte, _err error) {
  var _args8 IPCChainTesterPackAbiArgs
  _args8.Abi = abi
  var _result10 IPCChainTesterPackAbiResult
  var _meta9 thrift.ResponseMeta
  _meta9, _err = p.Client_().Call(ctx, "pack_abi", &_args8, &_result10)
  p.SetLastResponseMeta_(_meta9)
  if _err != nil {
    return
  }
  return _result10.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
func (p *IPCChainTesterClient) PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error) {
  var _args11 IPCChainTesterPackActionArgsArgs
  _args11.ID = id
  _args11.Contract = contract
  _args11.Action = action
  _args11.ActionArgs_ = action_args
  var _result13 IPCChainTesterPackActionArgsResult
  var _meta12 thrift.ResponseMeta
  _meta12, _err = p.Client_().Call(ctx, "pack_action_args", &_args11, &_result13)
  p.SetLastResponseMeta_(_meta12)
  if _err != nil {
    return
  }
  return _result13.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
func (p *IPCChainTesterClient) UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error) {
  var _args14 IPCChainTesterUnpackActionArgsArgs
  _args14.ID = id
  _args14.Contract = contract
  _args14.Action = action
  _args14.RawArgs_ = raw_args
  var _result16 IPCChainTesterUnpackActionArgsResult
  var _meta15 thrift.ResponseMeta
  _meta15, _err = p.Client_().Call(ctx, "unpack_action_args", &_args14, &_result16)
  p.SetLastResponseMeta_(_meta15)
  if _err != nil {
    return
  }
  return _result16.GetSuccess(), nil
}

func (p *IPCChainTesterClient) NewChain_(ctx context.Context) (_r int32, _err error) {
  var _args17 IPCChainTesterNewChainArgs_
  var _result19 IPCChainTesterNewChainResult_
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "new_chain", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  return _result19.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) FreeChain(ctx context.Context, id int32) (_r int32, _err error) {
  var _args20 IPCChainTesterFreeChainArgs
  _args20.ID = id
  var _result22 IPCChainTesterFreeChainResult
  var _meta21 thrift.ResponseMeta
  _meta21, _err = p.Client_().Call(ctx, "free_chain", &_args20, &_result22)
  p.SetLastResponseMeta_(_meta21)
  if _err != nil {
    return
  }
  return _result22.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) ProduceBlock(ctx context.Context, id int32) (_err error) {
  var _args23 IPCChainTesterProduceBlockArgs
  _args23.ID = id
  var _result25 IPCChainTesterProduceBlockResult
  var _meta24 thrift.ResponseMeta
  _meta24, _err = p.Client_().Call(ctx, "produce_block", &_args23, &_result25)
  p.SetLastResponseMeta_(_meta24)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
func (p *IPCChainTesterClient) PushAction(ctx context.Context, id int32, account string, action string, arguments string, permissions string) (_r []byte, _err error) {
  var _args26 IPCChainTesterPushActionArgs
  _args26.ID = id
  _args26.Account = account
  _args26.Action = action
  _args26.Arguments = arguments
  _args26.Permissions = permissions
  var _result28 IPCChainTesterPushActionResult
  var _meta27 thrift.ResponseMeta
  _meta27, _err = p.Client_().Call(ctx, "push_action", &_args26, &_result28)
  p.SetLastResponseMeta_(_meta27)
  if _err != nil {
    return
  }
  return _result28.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Actions
func (p *IPCChainTesterClient) PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error) {
  var _args29 IPCChainTesterPushActionsArgs
  _args29.ID = id
  _args29.Actions = actions
  var _result31 IPCChainTesterPushActionsResult
  var _meta30 thrift.ResponseMeta
  _meta30, _err = p.Client_().Call(ctx, "push_actions", &_args29, &_result31)
  p.SetLastResponseMeta_(_meta30)
  if _err != nil {
    return
  }
  return _result31.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - JSON
//  - Code
//  - Scope
//  - Table
//  - LowerBound
//  - UpperBound
//  - Limit
//  - KeyType
//  - IndexPosition
//  - Reverse
//  - ShowPayer
func (p *IPCChainTesterClient) GetTableRows(ctx context.Context, id int32, json bool, code string, scope string, table string, lower_bound string, upper_bound string, limit int64, key_type string, index_position string, reverse bool, show_payer bool) (_r string, _err error) {
  var _args32 IPCChainTesterGetTableRowsArgs
  _args32.ID = id
  _args32.JSON = json
  _args32.Code = code
  _args32.Scope = scope
  _args32.Table = table
  _args32.LowerBound = lower_bound
  _args32.UpperBound = upper_bound
  _args32.Limit = limit
  _args32.KeyType = key_type
  _args32.IndexPosition = index_position
  _args32.Reverse = reverse
  _args32.ShowPayer = show_payer
  var _result34 IPCChainTesterGetTableRowsResult
  var _meta33 thrift.ResponseMeta
  _meta33, _err = p.Client_().Call(ctx, "get_table_rows", &_args32, &_result34)
  p.SetLastResponseMeta_(_meta33)
  if _err != nil {
    return
  }
  return _result34.GetSuccess(), nil
}

type IPCChainTesterProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler IPCChainTester
}

func (p *IPCChainTesterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *IPCChainTesterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *IPCChainTesterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewIPCChainTesterProcessor(handler IPCChainTester) *IPCChainTesterProcessor {

  self35 := &IPCChainTesterProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self35.processorMap["init_vm_api"] = &iPCChainTesterProcessorInitVMAPI{handler:handler}
  self35.processorMap["init_apply_request"] = &iPCChainTesterProcessorInitApplyRequest{handler:handler}
  self35.processorMap["enable_debug_contract"] = &iPCChainTesterProcessorEnableDebugContract{handler:handler}
  self35.processorMap["is_debug_contract_enabled"] = &iPCChainTesterProcessorIsDebugContractEnabled{handler:handler}
  self35.processorMap["pack_abi"] = &iPCChainTesterProcessorPackAbi{handler:handler}
  self35.processorMap["pack_action_args"] = &iPCChainTesterProcessorPackActionArgs_{handler:handler}
  self35.processorMap["unpack_action_args"] = &iPCChainTesterProcessorUnpackActionArgs_{handler:handler}
  self35.processorMap["new_chain"] = &iPCChainTesterProcessorNewChain_{handler:handler}
  self35.processorMap["free_chain"] = &iPCChainTesterProcessorFreeChain{handler:handler}
  self35.processorMap["produce_block"] = &iPCChainTesterProcessorProduceBlock{handler:handler}
  self35.processorMap["push_action"] = &iPCChainTesterProcessorPushAction{handler:handler}
  self35.processorMap["push_actions"] = &iPCChainTesterProcessorPushActions{handler:handler}
  self35.processorMap["get_table_rows"] = &iPCChainTesterProcessorGetTableRows{handler:handler}
return self35
}

func (p *IPCChainTesterProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x36 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x36.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x36

}

type iPCChainTesterProcessorInitVMAPI struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitVMAPI) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitVMAPIArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitVMAPI(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorInitApplyRequest struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitApplyRequest(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorEnableDebugContract struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorEnableDebugContract) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterEnableDebugContractArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterEnableDebugContractResult{}
  if err2 = p.handler.EnableDebugContract(ctx, args.ID, args.Contract, args.Enable); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enable_debug_contract: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorIsDebugContractEnabled struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorIsDebugContractEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterIsDebugContractEnabledArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterIsDebugContractEnabledResult{}
  var retval bool
  if retval, err2 = p.handler.IsDebugContractEnabled(ctx, args.ID, args.Contract); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_debug_contract_enabled: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackAbi struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackAbi) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackAbiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackAbiResult{}
  var retval []byte
  if retval, err2 = p.handler.PackAbi(ctx, args.Abi); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_abi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_abi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.PackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.ActionArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorUnpackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorUnpackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterUnpackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterUnpackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.UnpackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.RawArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unpack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorNewChain_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorNewChain_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterNewChainArgs_{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterNewChainResult_{}
  var retval int32
  if retval, err2 = p.handler.NewChain_(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing new_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "new_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorFreeChain struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorFreeChain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterFreeChainArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterFreeChainResult{}
  var retval int32
  if retval, err2 = p.handler.FreeChain(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing free_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "free_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorProduceBlock struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorProduceBlock) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterProduceBlockArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterProduceBlockResult{}
  if err2 = p.handler.ProduceBlock(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing produce_block: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "produce_block", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushAction struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionResult{}
  var retval []byte
  if retval, err2 = p.handler.PushAction(ctx, args.ID, args.Account, args.Action, args.Arguments, args.Permissions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushActions struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionsResult{}
  var retval []byte
  if retval, err2 = p.handler.PushActions(ctx, args.ID, args.Actions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorGetTableRows struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorGetTableRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterGetTableRowsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterGetTableRowsResult{}
  var retval string
  if retval, err2 = p.handler.GetTableRows(ctx, args.ID, args.JSON, args.Code, args.Scope, args.Table, args.LowerBound, args.UpperBound, args.Limit, args.KeyType, args.IndexPosition, args.Reverse, args.ShowPayer); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_table_rows: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type IPCChainTesterInitVMAPIArgs struct {
}

func NewIPCChainTesterInitVMAPIArgs() *IPCChainTesterInitVMAPIArgs {
  return &IPCChainTesterInitVMAPIArgs{}
}

func (p *IPCChainTesterInitVMAPIArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_vm_api_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitVMAPIArgs(%+v)", *p)
}

type IPCChainTesterInitApplyRequestArgs struct {
}

func NewIPCChainTesterInitApplyRequestArgs() *IPCChainTesterInitApplyRequestArgs {
  return &IPCChainTesterInitApplyRequestArgs{}
}

func (p *IPCChainTesterInitApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Enable
type IPCChainTesterEnableDebugContractArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Enable bool `thrift:"enable,3" db:"enable" json:"enable"`
}

func NewIPCChainTesterEnableDebugContractArgs() *IPCChainTesterEnableDebugContractArgs {
  return &IPCChainTesterEnableDebugContractArgs{}
}


func (p *IPCChainTesterEnableDebugContractArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterEnableDebugContractArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterEnableDebugContractArgs) GetEnable() bool {
  return p.Enable
}
func (p *IPCChainTesterEnableDebugContractArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Enable = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "enable", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:enable: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Enable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.enable (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:enable: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractArgs(%+v)", *p)
}

type IPCChainTesterEnableDebugContractResult struct {
}

func NewIPCChainTesterEnableDebugContractResult() *IPCChainTesterEnableDebugContractResult {
  return &IPCChainTesterEnableDebugContractResult{}
}

func (p *IPCChainTesterEnableDebugContractResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
type IPCChainTesterIsDebugContractEnabledArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
}

func NewIPCChainTesterIsDebugContractEnabledArgs() *IPCChainTesterIsDebugContractEnabledArgs {
  return &IPCChainTesterIsDebugContractEnabledArgs{}
}


func (p *IPCChainTesterIsDebugContractEnabledArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) GetContract() string {
  return p.Contract
}
func (p *IPCChainTesterIsDebugContractEnabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterIsDebugContractEnabledResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterIsDebugContractEnabledResult() *IPCChainTesterIsDebugContractEnabledResult {
  return &IPCChainTesterIsDebugContractEnabledResult{}
}

var IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT bool
func (p *IPCChainTesterIsDebugContractEnabledResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterIsDebugContractEnabledResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledResult(%+v)", *p)
}

// Attributes:
//  - Abi
type IPCChainTesterPackAbiArgs struct {
  Abi string `thrift:"abi,1" db:"abi" json:"abi"`
}

func NewIPCChainTesterPackAbiArgs() *IPCChainTesterPackAbiArgs {
  return &IPCChainTesterPackAbiArgs{}
}


func (p *IPCChainTesterPackAbiArgs) GetAbi() string {
  return p.Abi
}
func (p *IPCChainTesterPackAbiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Abi = v
}
  return nil
}

func (p *IPCChainTesterPackAbiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "abi", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:abi: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Abi)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.abi (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:abi: ", p), err) }
  return err
}

func (p *IPCChainTesterPackAbiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackAbiResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackAbiResult() *IPCChainTesterPackAbiResult {
  return &IPCChainTesterPackAbiResult{}
}

var IPCChainTesterPackAbiResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackAbiResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackAbiResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackAbiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackAbiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackAbiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
type IPCChainTesterPackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  ActionArgs_ string `thrift:"action_args,4" db:"action_args" json:"action_args"`
}

func NewIPCChainTesterPackActionArgsArgs() *IPCChainTesterPackActionArgsArgs {
  return &IPCChainTesterPackActionArgsArgs{}
}


func (p *IPCChainTesterPackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterPackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterPackActionArgsArgs) GetActionArgs_() string {
  return p.ActionArgs_
}
func (p *IPCChainTesterPackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ActionArgs_ = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:action_args: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ActionArgs_)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:action_args: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackActionArgsResult() *IPCChainTesterPackActionArgsResult {
  return &IPCChainTesterPackActionArgsResult{}
}

var IPCChainTesterPackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
type IPCChainTesterUnpackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  RawArgs_ []byte `thrift:"raw_args,4" db:"raw_args" json:"raw_args"`
}

func NewIPCChainTesterUnpackActionArgsArgs() *IPCChainTesterUnpackActionArgsArgs {
  return &IPCChainTesterUnpackActionArgsArgs{}
}


func (p *IPCChainTesterUnpackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetRawArgs_() []byte {
  return p.RawArgs_
}
func (p *IPCChainTesterUnpackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.RawArgs_ = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "raw_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:raw_args: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawArgs_); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.raw_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:raw_args: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterUnpackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterUnpackActionArgsResult() *IPCChainTesterUnpackActionArgsResult {
  return &IPCChainTesterUnpackActionArgsResult{}
}

var IPCChainTesterUnpackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterUnpackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterUnpackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterUnpackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsResult(%+v)", *p)
}

type IPCChainTesterNewChainArgs_ struct {
}

func NewIPCChainTesterNewChainArgs_() *IPCChainTesterNewChainArgs_ {
  return &IPCChainTesterNewChainArgs_{}
}

func (p *IPCChainTesterNewChainArgs_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainArgs_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainArgs_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainArgs_(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterNewChainResult_ struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterNewChainResult_() *IPCChainTesterNewChainResult_ {
  return &IPCChainTesterNewChainResult_{}
}

var IPCChainTesterNewChainResult__Success_DEFAULT int32
func (p *IPCChainTesterNewChainResult_) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterNewChainResult__Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterNewChainResult_) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterNewChainResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainResult_)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterNewChainResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainResult_) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterNewChainResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainResult_(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterFreeChainArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterFreeChainArgs() *IPCChainTesterFreeChainArgs {
  return &IPCChainTesterFreeChainArgs{}
}


func (p *IPCChainTesterFreeChainArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterFreeChainArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterFreeChainArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterFreeChainArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterFreeChainResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterFreeChainResult() *IPCChainTesterFreeChainResult {
  return &IPCChainTesterFreeChainResult{}
}

var IPCChainTesterFreeChainResult_Success_DEFAULT int32
func (p *IPCChainTesterFreeChainResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterFreeChainResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterFreeChainResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterFreeChainResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterFreeChainResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterFreeChainResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainResult(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterProduceBlockArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterProduceBlockArgs() *IPCChainTesterProduceBlockArgs {
  return &IPCChainTesterProduceBlockArgs{}
}


func (p *IPCChainTesterProduceBlockArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterProduceBlockArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterProduceBlockArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockArgs(%+v)", *p)
}

type IPCChainTesterProduceBlockResult struct {
}

func NewIPCChainTesterProduceBlockResult() *IPCChainTesterProduceBlockResult {
  return &IPCChainTesterProduceBlockResult{}
}

func (p *IPCChainTesterProduceBlockResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
type IPCChainTesterPushActionArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Account string `thrift:"account,2" db:"account" json:"account"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  Arguments string `thrift:"arguments,4" db:"arguments" json:"arguments"`
  Permissions string `thrift:"permissions,5" db:"permissions" json:"permissions"`
}

func NewIPCChainTesterPushActionArgs() *IPCChainTesterPushActionArgs {
  return &IPCChainTesterPushActionArgs{}
}


func (p *IPCChainTesterPushActionArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionArgs) GetAccount() string {
  return p.Account
}

func (p *IPCChainTesterPushActionArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterPushActionArgs) GetArguments() string {
  return p.Arguments
}

func (p *IPCChainTesterPushActionArgs) GetPermissions() string {
  return p.Permissions
}
func (p *IPCChainTesterPushActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Arguments = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:account: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Arguments)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.arguments (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:permissions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPushActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPushActionResult() *IPCChainTesterPushActionResult {
  return &IPCChainTesterPushActionResult{}
}

var IPCChainTesterPushActionResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPushActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Actions
type IPCChainTesterPushActionsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Actions []*Action `thrift:"actions,2" db:"actions" json:"actions"`
}

func NewIPCChainTesterPushActionsArgs() *IPCChainTesterPushActionsArgs {
  return &IPCChainTesterPushActionsArgs{}
}


func (p *IPCChainTesterPushActionsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *IPCChainTesterPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem37 := &Action{}
    if err := _elem37.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem37), err)
    }
    p.Actions = append(p.Actions, _elem37)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:actions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPushActionsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPushActionsResult() *IPCChainTesterPushActionsResult {
  return &IPCChainTesterPushActionsResult{}
}

var IPCChainTesterPushActionsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - JSON
//  - Code
//  - Scope
//  - Table
//  - LowerBound
//  - UpperBound
//  - Limit
//  - KeyType
//  - IndexPosition
//  - Reverse
//  - ShowPayer
type IPCChainTesterGetTableRowsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  JSON bool `thrift:"json,2" db:"json" json:"json"`
  Code string `thrift:"code,3" db:"code" json:"code"`
  Scope string `thrift:"scope,4" db:"scope" json:"scope"`
  Table string `thrift:"table,5" db:"table" json:"table"`
  LowerBound string `thrift:"lower_bound,6" db:"lower_bound" json:"lower_bound"`
  UpperBound string `thrift:"upper_bound,7" db:"upper_bound" json:"upper_bound"`
  Limit int64 `thrift:"limit,8" db:"limit" json:"limit"`
  KeyType string `thrift:"key_type,9" db:"key_type" json:"key_type"`
  IndexPosition string `thrift:"index_position,10" db:"index_position" json:"index_position"`
  Reverse bool `thrift:"reverse,11" db:"reverse" json:"reverse"`
  ShowPayer bool `thrift:"show_payer,12" db:"show_payer" json:"show_payer"`
}

func NewIPCChainTesterGetTableRowsArgs() *IPCChainTesterGetTableRowsArgs {
  return &IPCChainTesterGetTableRowsArgs{}
}


func (p *IPCChainTesterGetTableRowsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterGetTableRowsArgs) GetJSON() bool {
  return p.JSON
}

func (p *IPCChainTesterGetTableRowsArgs) GetCode() string {
  return p.Code
}

func (p *IPCChainTesterGetTableRowsArgs) GetScope() string {
  return p.Scope
}

func (p *IPCChainTesterGetTableRowsArgs) GetTable() string {
  return p.Table
}

func (p *IPCChainTesterGetTableRowsArgs) GetLowerBound() string {
  return p.LowerBound
}

func (p *IPCChainTesterGetTableRowsArgs) GetUpperBound() string {
  return p.UpperBound
}

func (p *IPCChainTesterGetTableRowsArgs) GetLimit() int64 {
  return p.Limit
}

func (p *IPCChainTesterGetTableRowsArgs) GetKeyType() string {
  return p.KeyType
}

func (p *IPCChainTesterGetTableRowsArgs) GetIndexPosition() string {
  return p.IndexPosition
}

func (p *IPCChainTesterGetTableRowsArgs) GetReverse() bool {
  return p.Reverse
}

func (p *IPCChainTesterGetTableRowsArgs) GetShowPayer() bool {
  return p.ShowPayer
}
func (p *IPCChainTesterGetTableRowsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.JSON = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Scope = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.LowerBound = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.UpperBound = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.Limit = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.KeyType = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.IndexPosition = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.Reverse = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.ShowPayer = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_table_rows_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "json", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:json: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.JSON)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.json (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:json: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:code: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:code: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:scope: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Scope)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.scope (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:scope: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:table: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Table)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:table: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lower_bound", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:lower_bound: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.LowerBound)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.lower_bound (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:lower_bound: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "upper_bound", thrift.STRING, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:upper_bound: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.UpperBound)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.upper_bound (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:upper_bound: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:limit: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Limit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.limit (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:limit: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_type", thrift.STRING, 9); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:key_type: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.KeyType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key_type (9) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 9:key_type: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index_position", thrift.STRING, 10); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:index_position: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.IndexPosition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index_position (10) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 10:index_position: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reverse", thrift.BOOL, 11); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:reverse: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Reverse)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reverse (11) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 11:reverse: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "show_payer", thrift.BOOL, 12); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:show_payer: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.ShowPayer)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.show_payer (12) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 12:show_payer: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetTableRowsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterGetTableRowsResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterGetTableRowsResult() *IPCChainTesterGetTableRowsResult {
  return &IPCChainTesterGetTableRowsResult{}
}

var IPCChainTesterGetTableRowsResult_Success_DEFAULT string
func (p *IPCChainTesterGetTableRowsResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterGetTableRowsResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterGetTableRowsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterGetTableRowsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetTableRowsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_table_rows_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetTableRowsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterGetTableRowsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetTableRowsResult(%+v)", *p)
}


type PushActions interface {
  // Parameters:
  //  - Actions
  PushActions(ctx context.Context, actions []*Action) (_r int32, _err error)
}

type PushActionsClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewPushActionsClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewPushActionsClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewPushActionsClient(c thrift.TClient) *PushActionsClient {
  return &PushActionsClient{
    c: c,
  }
}

func (p *PushActionsClient) Client_() thrift.TClient {
  return p.c
}

func (p *PushActionsClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *PushActionsClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Actions
func (p *PushActionsClient) PushActions(ctx context.Context, actions []*Action) (_r int32, _err error) {
  var _args78 PushActionsPushActionsArgs
  _args78.Actions = actions
  var _result80 PushActionsPushActionsResult
  var _meta79 thrift.ResponseMeta
  _meta79, _err = p.Client_().Call(ctx, "push_actions", &_args78, &_result80)
  p.SetLastResponseMeta_(_meta79)
  if _err != nil {
    return
  }
  return _result80.GetSuccess(), nil
}

type PushActionsProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler PushActions
}

func (p *PushActionsProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *PushActionsProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *PushActionsProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewPushActionsProcessor(handler PushActions) *PushActionsProcessor {

  self81 := &PushActionsProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self81.processorMap["push_actions"] = &pushActionsProcessorPushActions{handler:handler}
return self81
}

func (p *PushActionsProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x82 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x82.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x82

}

type pushActionsProcessorPushActions struct {
  handler PushActions
}

func (p *pushActionsProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PushActionsPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := PushActionsPushActionsResult{}
  var retval int32
  if retval, err2 = p.handler.PushActions(ctx, args.Actions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Actions
type PushActionsPushActionsArgs struct {
  Actions []*Action `thrift:"actions,1" db:"actions" json:"actions"`
}

func NewPushActionsPushActionsArgs() *PushActionsPushActionsArgs {
  return &PushActionsPushActionsArgs{}
}


func (p *PushActionsPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *PushActionsPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem83 := &Action{}
    if err := _elem83.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem83), err)
    }
    p.Actions = append(p.Actions, _elem83)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:actions: ", p), err) }
  return err
}

func (p *PushActionsPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type PushActionsPushActionsResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewPushActionsPushActionsResult() *PushActionsPushActionsResult {
  return &PushActionsPushActionsResult{}
}

var PushActionsPushActionsResult_Success_DEFAULT int32
func (p *PushActionsPushActionsResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return PushActionsPushActionsResult_Success_DEFAULT
  }
return *p.Success
}
func (p *PushActionsPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *PushActionsPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *PushActionsPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *PushActionsPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsResult(%+v)", *p)
}


type ApplyRequest interface {
  // Parameters:
  //  - Receiver
  //  - FirstReceiver
  //  - Action
  ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64) (_r int32, _err error)
  ApplyEnd(ctx context.Context) (_r int32, _err error)
}

type ApplyRequestClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyRequestClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyRequestClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyRequestClient(c thrift.TClient) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: c,
  }
}

func (p *ApplyRequestClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyRequestClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyRequestClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Receiver
//  - FirstReceiver
//  - Action
func (p *ApplyRequestClient) ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64) (_r int32, _err error) {
  var _args90 ApplyRequestApplyRequestArgs
  _args90.Receiver = receiver
  _args90.FirstReceiver = firstReceiver
  _args90.Action = action
  var _result92 ApplyRequestApplyRequestResult
  var _meta91 thrift.ResponseMeta
  _meta91, _err = p.Client_().Call(ctx, "apply_request", &_args90, &_result92)
  p.SetLastResponseMeta_(_meta91)
  if _err != nil {
    return
  }
  return _result92.GetSuccess(), nil
}

func (p *ApplyRequestClient) ApplyEnd(ctx context.Context) (_r int32, _err error) {
  var _args93 ApplyRequestApplyEndArgs
  var _result95 ApplyRequestApplyEndResult
  var _meta94 thrift.ResponseMeta
  _meta94, _err = p.Client_().Call(ctx, "apply_end", &_args93, &_result95)
  p.SetLastResponseMeta_(_meta94)
  if _err != nil {
    return
  }
  return _result95.GetSuccess(), nil
}

type ApplyRequestProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ApplyRequest
}

func (p *ApplyRequestProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyRequestProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyRequestProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyRequestProcessor(handler ApplyRequest) *ApplyRequestProcessor {

  self96 := &ApplyRequestProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self96.processorMap["apply_request"] = &applyRequestProcessorApplyRequest{handler:handler}
  self96.processorMap["apply_end"] = &applyRequestProcessorApplyEnd{handler:handler}
return self96
}

func (p *ApplyRequestProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x97 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x97.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x97

}

type applyRequestProcessorApplyRequest struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyRequestResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyRequest(ctx, args.Receiver, args.FirstReceiver, args.Action); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_request: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_request", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyRequestProcessorApplyEnd struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyEndResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyEnd(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Receiver
//  - FirstReceiver
//  - Action
type ApplyRequestApplyRequestArgs struct {
  Receiver *Uint64 `thrift:"receiver,1" db:"receiver" json:"receiver"`
  FirstReceiver *Uint64 `thrift:"firstReceiver,2" db:"firstReceiver" json:"firstReceiver"`
  Action *Uint64 `thrift:"action,3" db:"action" json:"action"`
}

func NewApplyRequestApplyRequestArgs() *ApplyRequestApplyRequestArgs {
  return &ApplyRequestApplyRequestArgs{}
}

var ApplyRequestApplyRequestArgs_Receiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetReceiver() *Uint64 {
  if !p.IsSetReceiver() {
    return ApplyRequestApplyRequestArgs_Receiver_DEFAULT
  }
return p.Receiver
}
var ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetFirstReceiver() *Uint64 {
  if !p.IsSetFirstReceiver() {
    return ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT
  }
return p.FirstReceiver
}
var ApplyRequestApplyRequestArgs_Action_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetAction() *Uint64 {
  if !p.IsSetAction() {
    return ApplyRequestApplyRequestArgs_Action_DEFAULT
  }
return p.Action
}
func (p *ApplyRequestApplyRequestArgs) IsSetReceiver() bool {
  return p.Receiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetFirstReceiver() bool {
  return p.FirstReceiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetAction() bool {
  return p.Action != nil
}

func (p *ApplyRequestApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Receiver = &Uint64{}
  if err := p.Receiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Receiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.FirstReceiver = &Uint64{}
  if err := p.FirstReceiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.FirstReceiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Action = &Uint64{}
  if err := p.Action.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Action), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "receiver", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:receiver: ", p), err) }
  if err := p.Receiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Receiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:receiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "firstReceiver", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:firstReceiver: ", p), err) }
  if err := p.FirstReceiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.FirstReceiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:firstReceiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := p.Action.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Action), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyRequestResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyRequestResult() *ApplyRequestApplyRequestResult {
  return &ApplyRequestApplyRequestResult{}
}

var ApplyRequestApplyRequestResult_Success_DEFAULT int32
func (p *ApplyRequestApplyRequestResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyRequestResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyRequestResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyRequestResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyRequestResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyRequestResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestResult(%+v)", *p)
}

type ApplyRequestApplyEndArgs struct {
}

func NewApplyRequestApplyEndArgs() *ApplyRequestApplyEndArgs {
  return &ApplyRequestApplyEndArgs{}
}

func (p *ApplyRequestApplyEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyEndResult() *ApplyRequestApplyEndResult {
  return &ApplyRequestApplyEndResult{}
}

var ApplyRequestApplyEndResult_Success_DEFAULT int32
func (p *ApplyRequestApplyEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndResult(%+v)", *p)
}


type Apply interface {
  EndApply(ctx context.Context) (_r int32, _err error)
  GetActiveProducers(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - Account
  GetResourceLimits(ctx context.Context, account *Uint64) (_r *GetResourceLimitsReturn, _err error)
  // Parameters:
  //  - Account
  //  - RAMBytes
  //  - NetWeight
  //  - CPUWeight
  SetResourceLimits(ctx context.Context, account *Uint64, ram_bytes int64, net_weight int64, cpu_weight int64) (_err error)
  // Parameters:
  //  - ProducerData
  SetProposedProducers(ctx context.Context, producer_data []byte) (_r int64, _err error)
  // Parameters:
  //  - ProducerDataFormat
  //  - ProducerData
  SetProposedProducersEx(ctx context.Context, producer_data_format *Uint64, producer_data *Uint64) (_r int64, _err error)
  // Parameters:
  //  - Account
  IsPrivileged(ctx context.Context, account *Uint64) (_r bool, _err error)
  // Parameters:
  //  - Account
  //  - IsPriv
  SetPrivileged(ctx context.Context, account *Uint64, is_priv bool) (_err error)
  // Parameters:
  //  - Data
  SetBlockchainParametersPacked(ctx context.Context, data []byte) (_err error)
  GetBlockchainParametersPacked(ctx context.Context) (_r int32, _err error)
  // Parameters:
  //  - FeatureDigest
  PreactivateFeature(ctx context.Context, feature_digest []byte) (_err error)
  // Parameters:
  //  - TrxData
  //  - PubkeysData
  //  - PermsData
  CheckTransactionAuthorization(ctx context.Context, trx_data []byte, pubkeys_data []byte, perms_data []byte) (_r int32, _err error)
  // Parameters:
  //  - Account
  //  - Permission
  //  - PubkeysData
  //  - PermsData
  //  - DelayUs
  CheckPermissionAuthorization(ctx context.Context, account *Uint64, permission *Uint64, pubkeys_data []byte, perms_data []byte, delay_us *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Account
  //  - Permission
  GetPermissionLastUsed(ctx context.Context, account *Uint64, permission *Uint64) (_r int64, _err error)
  // Parameters:
  //  - Account
  GetAccountCreationTime(ctx context.Context, account *Uint64) (_r int64, _err error)
  // Parameters:
  //  - Cstr
  Prints(ctx context.Context, cstr string) (_err error)
  // Parameters:
  //  - Cstr
  PrintsL(ctx context.Context, cstr []byte) (_err error)
  // Parameters:
  //  - N
  Printi(ctx context.Context, n int64) (_err error)
  // Parameters:
  //  - N
  Printui(ctx context.Context, n *Uint64) (_err error)
  // Parameters:
  //  - Value
  Printi128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printui128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printsf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printdf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printqf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Name
  Printn(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Data
  Printhex(ctx context.Context, data []byte) (_err error)
  ActionDataSize(ctx context.Context) (_r int32, _err error)
  ReadActionData(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - Name
  RequireRecipient(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  RequireAuth(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - Name
  //  - Permission
  RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error)
  // Parameters:
  //  - Name
  IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - SerializedAction
  SendInline(ctx context.Context, serialized_action []byte) (_err error)
  // Parameters:
  //  - SerializedData
  SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error)
  PublicationTime(ctx context.Context) (_r *Uint64, _err error)
  CurrentReceiver(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssert(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Code
  EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error)
  // Parameters:
  //  - Code
  EosioExit(ctx context.Context, code int32) (_err error)
  CurrentTime(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - FeatureDigest
  IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error)
  GetSender(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  Sha256(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha1(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha512(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  //  - Pub
  AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error)
  // Parameters:
  //  - SenderID
  //  - Payer
  //  - SerializedTransaction
  //  - ReplaceExisting
  SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error)
  // Parameters:
  //  - SenderID
  CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error)
  ReadTransaction(ctx context.Context) (_r []byte, _err error)
  TransactionSize(ctx context.Context) (_r int32, _err error)
  TaposBlockNum(ctx context.Context) (_r int32, _err error)
  TaposBlockPrefix(ctx context.Context) (_r int32, _err error)
  Expiration(ctx context.Context) (_r int64, _err error)
  // Parameters:
  //  - _type
  //  - Index
  GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Index
  GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbRemoveI64(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error)
  // Parameters:
  //  - Iterator
  DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iteratory
  DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
}

type ApplyClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyClient(c thrift.TClient) *ApplyClient {
  return &ApplyClient{
    c: c,
  }
}

func (p *ApplyClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *ApplyClient) EndApply(ctx context.Context) (_r int32, _err error) {
  var _args116 ApplyEndApplyArgs
  var _result118 ApplyEndApplyResult
  var _meta117 thrift.ResponseMeta
  _meta117, _err = p.Client_().Call(ctx, "end_apply", &_args116, &_result118)
  p.SetLastResponseMeta_(_meta117)
  if _err != nil {
    return
  }
  return _result118.GetSuccess(), nil
}

func (p *ApplyClient) GetActiveProducers(ctx context.Context) (_r []byte, _err error) {
  var _args119 ApplyGetActiveProducersArgs
  var _result121 ApplyGetActiveProducersResult
  var _meta120 thrift.ResponseMeta
  _meta120, _err = p.Client_().Call(ctx, "get_active_producers", &_args119, &_result121)
  p.SetLastResponseMeta_(_meta120)
  if _err != nil {
    return
  }
  return _result121.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) GetResourceLimits(ctx context.Context, account *Uint64) (_r *GetResourceLimitsReturn, _err error) {
  var _args122 ApplyGetResourceLimitsArgs
  _args122.Account = account
  var _result124 ApplyGetResourceLimitsResult
  var _meta123 thrift.ResponseMeta
  _meta123, _err = p.Client_().Call(ctx, "get_resource_limits", &_args122, &_result124)
  p.SetLastResponseMeta_(_meta123)
  if _err != nil {
    return
  }
  if _ret125 := _result124.GetSuccess(); _ret125 != nil {
    return _ret125, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get_resource_limits failed: unknown result")
}

// Parameters:
//  - Account
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
func (p *ApplyClient) SetResourceLimits(ctx context.Context, account *Uint64, ram_bytes int64, net_weight int64, cpu_weight int64) (_err error) {
  var _args126 ApplySetResourceLimitsArgs
  _args126.Account = account
  _args126.RAMBytes = ram_bytes
  _args126.NetWeight = net_weight
  _args126.CPUWeight = cpu_weight
  var _result128 ApplySetResourceLimitsResult
  var _meta127 thrift.ResponseMeta
  _meta127, _err = p.Client_().Call(ctx, "set_resource_limits", &_args126, &_result128)
  p.SetLastResponseMeta_(_meta127)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ProducerData
func (p *ApplyClient) SetProposedProducers(ctx context.Context, producer_data []byte) (_r int64, _err error) {
  var _args129 ApplySetProposedProducersArgs
  _args129.ProducerData = producer_data
  var _result131 ApplySetProposedProducersResult
  var _meta130 thrift.ResponseMeta
  _meta130, _err = p.Client_().Call(ctx, "set_proposed_producers", &_args129, &_result131)
  p.SetLastResponseMeta_(_meta130)
  if _err != nil {
    return
  }
  return _result131.GetSuccess(), nil
}

// Parameters:
//  - ProducerDataFormat
//  - ProducerData
func (p *ApplyClient) SetProposedProducersEx(ctx context.Context, producer_data_format *Uint64, producer_data *Uint64) (_r int64, _err error) {
  var _args132 ApplySetProposedProducersExArgs
  _args132.ProducerDataFormat = producer_data_format
  _args132.ProducerData = producer_data
  var _result134 ApplySetProposedProducersExResult
  var _meta133 thrift.ResponseMeta
  _meta133, _err = p.Client_().Call(ctx, "set_proposed_producers_ex", &_args132, &_result134)
  p.SetLastResponseMeta_(_meta133)
  if _err != nil {
    return
  }
  return _result134.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) IsPrivileged(ctx context.Context, account *Uint64) (_r bool, _err error) {
  var _args135 ApplyIsPrivilegedArgs
  _args135.Account = account
  var _result137 ApplyIsPrivilegedResult
  var _meta136 thrift.ResponseMeta
  _meta136, _err = p.Client_().Call(ctx, "is_privileged", &_args135, &_result137)
  p.SetLastResponseMeta_(_meta136)
  if _err != nil {
    return
  }
  return _result137.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - IsPriv
func (p *ApplyClient) SetPrivileged(ctx context.Context, account *Uint64, is_priv bool) (_err error) {
  var _args138 ApplySetPrivilegedArgs
  _args138.Account = account
  _args138.IsPriv = is_priv
  var _result140 ApplySetPrivilegedResult
  var _meta139 thrift.ResponseMeta
  _meta139, _err = p.Client_().Call(ctx, "set_privileged", &_args138, &_result140)
  p.SetLastResponseMeta_(_meta139)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) SetBlockchainParametersPacked(ctx context.Context, data []byte) (_err error) {
  var _args141 ApplySetBlockchainParametersPackedArgs
  _args141.Data = data
  var _result143 ApplySetBlockchainParametersPackedResult
  var _meta142 thrift.ResponseMeta
  _meta142, _err = p.Client_().Call(ctx, "set_blockchain_parameters_packed", &_args141, &_result143)
  p.SetLastResponseMeta_(_meta142)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) GetBlockchainParametersPacked(ctx context.Context) (_r int32, _err error) {
  var _args144 ApplyGetBlockchainParametersPackedArgs
  var _result146 ApplyGetBlockchainParametersPackedResult
  var _meta145 thrift.ResponseMeta
  _meta145, _err = p.Client_().Call(ctx, "get_blockchain_parameters_packed", &_args144, &_result146)
  p.SetLastResponseMeta_(_meta145)
  if _err != nil {
    return
  }
  return _result146.GetSuccess(), nil
}

// Parameters:
//  - FeatureDigest
func (p *ApplyClient) PreactivateFeature(ctx context.Context, feature_digest []byte) (_err error) {
  var _args147 ApplyPreactivateFeatureArgs
  _args147.FeatureDigest = feature_digest
  var _result149 ApplyPreactivateFeatureResult
  var _meta148 thrift.ResponseMeta
  _meta148, _err = p.Client_().Call(ctx, "preactivate_feature", &_args147, &_result149)
  p.SetLastResponseMeta_(_meta148)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - TrxData
//  - PubkeysData
//  - PermsData
func (p *ApplyClient) CheckTransactionAuthorization(ctx context.Context, trx_data []byte, pubkeys_data []byte, perms_data []byte) (_r int32, _err error) {
  var _args150 ApplyCheckTransactionAuthorizationArgs
  _args150.TrxData = trx_data
  _args150.PubkeysData = pubkeys_data
  _args150.PermsData = perms_data
  var _result152 ApplyCheckTransactionAuthorizationResult
  var _meta151 thrift.ResponseMeta
  _meta151, _err = p.Client_().Call(ctx, "check_transaction_authorization", &_args150, &_result152)
  p.SetLastResponseMeta_(_meta151)
  if _err != nil {
    return
  }
  return _result152.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - Permission
//  - PubkeysData
//  - PermsData
//  - DelayUs
func (p *ApplyClient) CheckPermissionAuthorization(ctx context.Context, account *Uint64, permission *Uint64, pubkeys_data []byte, perms_data []byte, delay_us *Uint64) (_r int32, _err error) {
  var _args153 ApplyCheckPermissionAuthorizationArgs
  _args153.Account = account
  _args153.Permission = permission
  _args153.PubkeysData = pubkeys_data
  _args153.PermsData = perms_data
  _args153.DelayUs = delay_us
  var _result155 ApplyCheckPermissionAuthorizationResult
  var _meta154 thrift.ResponseMeta
  _meta154, _err = p.Client_().Call(ctx, "check_permission_authorization", &_args153, &_result155)
  p.SetLastResponseMeta_(_meta154)
  if _err != nil {
    return
  }
  return _result155.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - Permission
func (p *ApplyClient) GetPermissionLastUsed(ctx context.Context, account *Uint64, permission *Uint64) (_r int64, _err error) {
  var _args156 ApplyGetPermissionLastUsedArgs
  _args156.Account = account
  _args156.Permission = permission
  var _result158 ApplyGetPermissionLastUsedResult
  var _meta157 thrift.ResponseMeta
  _meta157, _err = p.Client_().Call(ctx, "get_permission_last_used", &_args156, &_result158)
  p.SetLastResponseMeta_(_meta157)
  if _err != nil {
    return
  }
  return _result158.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) GetAccountCreationTime(ctx context.Context, account *Uint64) (_r int64, _err error) {
  var _args159 ApplyGetAccountCreationTimeArgs
  _args159.Account = account
  var _result161 ApplyGetAccountCreationTimeResult
  var _meta160 thrift.ResponseMeta
  _meta160, _err = p.Client_().Call(ctx, "get_account_creation_time", &_args159, &_result161)
  p.SetLastResponseMeta_(_meta160)
  if _err != nil {
    return
  }
  return _result161.GetSuccess(), nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) Prints(ctx context.Context, cstr string) (_err error) {
  var _args162 ApplyPrintsArgs
  _args162.Cstr = cstr
  var _result164 ApplyPrintsResult
  var _meta163 thrift.ResponseMeta
  _meta163, _err = p.Client_().Call(ctx, "prints", &_args162, &_result164)
  p.SetLastResponseMeta_(_meta163)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) PrintsL(ctx context.Context, cstr []byte) (_err error) {
  var _args165 ApplyPrintsLArgs
  _args165.Cstr = cstr
  var _result167 ApplyPrintsLResult
  var _meta166 thrift.ResponseMeta
  _meta166, _err = p.Client_().Call(ctx, "prints_l", &_args165, &_result167)
  p.SetLastResponseMeta_(_meta166)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printi(ctx context.Context, n int64) (_err error) {
  var _args168 ApplyPrintiArgs
  _args168.N = n
  var _result170 ApplyPrintiResult
  var _meta169 thrift.ResponseMeta
  _meta169, _err = p.Client_().Call(ctx, "printi", &_args168, &_result170)
  p.SetLastResponseMeta_(_meta169)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printui(ctx context.Context, n *Uint64) (_err error) {
  var _args171 ApplyPrintuiArgs
  _args171.N = n
  var _result173 ApplyPrintuiResult
  var _meta172 thrift.ResponseMeta
  _meta172, _err = p.Client_().Call(ctx, "printui", &_args171, &_result173)
  p.SetLastResponseMeta_(_meta172)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printi128(ctx context.Context, value []byte) (_err error) {
  var _args174 ApplyPrinti128Args
  _args174.Value = value
  var _result176 ApplyPrinti128Result
  var _meta175 thrift.ResponseMeta
  _meta175, _err = p.Client_().Call(ctx, "printi128", &_args174, &_result176)
  p.SetLastResponseMeta_(_meta175)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printui128(ctx context.Context, value []byte) (_err error) {
  var _args177 ApplyPrintui128Args
  _args177.Value = value
  var _result179 ApplyPrintui128Result
  var _meta178 thrift.ResponseMeta
  _meta178, _err = p.Client_().Call(ctx, "printui128", &_args177, &_result179)
  p.SetLastResponseMeta_(_meta178)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printsf(ctx context.Context, value []byte) (_err error) {
  var _args180 ApplyPrintsfArgs
  _args180.Value = value
  var _result182 ApplyPrintsfResult
  var _meta181 thrift.ResponseMeta
  _meta181, _err = p.Client_().Call(ctx, "printsf", &_args180, &_result182)
  p.SetLastResponseMeta_(_meta181)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printdf(ctx context.Context, value []byte) (_err error) {
  var _args183 ApplyPrintdfArgs
  _args183.Value = value
  var _result185 ApplyPrintdfResult
  var _meta184 thrift.ResponseMeta
  _meta184, _err = p.Client_().Call(ctx, "printdf", &_args183, &_result185)
  p.SetLastResponseMeta_(_meta184)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printqf(ctx context.Context, value []byte) (_err error) {
  var _args186 ApplyPrintqfArgs
  _args186.Value = value
  var _result188 ApplyPrintqfResult
  var _meta187 thrift.ResponseMeta
  _meta187, _err = p.Client_().Call(ctx, "printqf", &_args186, &_result188)
  p.SetLastResponseMeta_(_meta187)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) Printn(ctx context.Context, name *Uint64) (_err error) {
  var _args189 ApplyPrintnArgs
  _args189.Name = name
  var _result191 ApplyPrintnResult
  var _meta190 thrift.ResponseMeta
  _meta190, _err = p.Client_().Call(ctx, "printn", &_args189, &_result191)
  p.SetLastResponseMeta_(_meta190)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Printhex(ctx context.Context, data []byte) (_err error) {
  var _args192 ApplyPrinthexArgs
  _args192.Data = data
  var _result194 ApplyPrinthexResult
  var _meta193 thrift.ResponseMeta
  _meta193, _err = p.Client_().Call(ctx, "printhex", &_args192, &_result194)
  p.SetLastResponseMeta_(_meta193)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) ActionDataSize(ctx context.Context) (_r int32, _err error) {
  var _args195 ApplyActionDataSizeArgs
  var _result197 ApplyActionDataSizeResult
  var _meta196 thrift.ResponseMeta
  _meta196, _err = p.Client_().Call(ctx, "action_data_size", &_args195, &_result197)
  p.SetLastResponseMeta_(_meta196)
  if _err != nil {
    return
  }
  return _result197.GetSuccess(), nil
}

func (p *ApplyClient) ReadActionData(ctx context.Context) (_r []byte, _err error) {
  var _args198 ApplyReadActionDataArgs
  var _result200 ApplyReadActionDataResult
  var _meta199 thrift.ResponseMeta
  _meta199, _err = p.Client_().Call(ctx, "read_action_data", &_args198, &_result200)
  p.SetLastResponseMeta_(_meta199)
  if _err != nil {
    return
  }
  return _result200.GetSuccess(), nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireRecipient(ctx context.Context, name *Uint64) (_err error) {
  var _args201 ApplyRequireRecipientArgs
  _args201.Name = name
  var _result203 ApplyRequireRecipientResult
  var _meta202 thrift.ResponseMeta
  _meta202, _err = p.Client_().Call(ctx, "require_recipient", &_args201, &_result203)
  p.SetLastResponseMeta_(_meta202)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireAuth(ctx context.Context, name *Uint64) (_err error) {
  var _args204 ApplyRequireAuthArgs
  _args204.Name = name
  var _result206 ApplyRequireAuthResult
  var _meta205 thrift.ResponseMeta
  _meta205, _err = p.Client_().Call(ctx, "require_auth", &_args204, &_result206)
  p.SetLastResponseMeta_(_meta205)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args207 ApplyHasAuthArgs
  _args207.Name = name
  var _result209 ApplyHasAuthResult
  var _meta208 thrift.ResponseMeta
  _meta208, _err = p.Client_().Call(ctx, "has_auth", &_args207, &_result209)
  p.SetLastResponseMeta_(_meta208)
  if _err != nil {
    return
  }
  return _result209.GetSuccess(), nil
}

// Parameters:
//  - Name
//  - Permission
func (p *ApplyClient) RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error) {
  var _args210 ApplyRequireAuth2Args
  _args210.Name = name
  _args210.Permission = permission
  var _result212 ApplyRequireAuth2Result
  var _meta211 thrift.ResponseMeta
  _meta211, _err = p.Client_().Call(ctx, "require_auth2", &_args210, &_result212)
  p.SetLastResponseMeta_(_meta211)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args213 ApplyIsAccountArgs
  _args213.Name = name
  var _result215 ApplyIsAccountResult
  var _meta214 thrift.ResponseMeta
  _meta214, _err = p.Client_().Call(ctx, "is_account", &_args213, &_result215)
  p.SetLastResponseMeta_(_meta214)
  if _err != nil {
    return
  }
  return _result215.GetSuccess(), nil
}

// Parameters:
//  - SerializedAction
func (p *ApplyClient) SendInline(ctx context.Context, serialized_action []byte) (_err error) {
  var _args216 ApplySendInlineArgs
  _args216.SerializedAction = serialized_action
  var _result218 ApplySendInlineResult
  var _meta217 thrift.ResponseMeta
  _meta217, _err = p.Client_().Call(ctx, "send_inline", &_args216, &_result218)
  p.SetLastResponseMeta_(_meta217)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SerializedData
func (p *ApplyClient) SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error) {
  var _args219 ApplySendContextFreeInlineArgs
  _args219.SerializedData = serialized_data
  var _result221 ApplySendContextFreeInlineResult
  var _meta220 thrift.ResponseMeta
  _meta220, _err = p.Client_().Call(ctx, "send_context_free_inline", &_args219, &_result221)
  p.SetLastResponseMeta_(_meta220)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) PublicationTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args222 ApplyPublicationTimeArgs
  var _result224 ApplyPublicationTimeResult
  var _meta223 thrift.ResponseMeta
  _meta223, _err = p.Client_().Call(ctx, "publication_time", &_args222, &_result224)
  p.SetLastResponseMeta_(_meta223)
  if _err != nil {
    return
  }
  if _ret225 := _result224.GetSuccess(); _ret225 != nil {
    return _ret225, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "publication_time failed: unknown result")
}

func (p *ApplyClient) CurrentReceiver(ctx context.Context) (_r *Uint64, _err error) {
  var _args226 ApplyCurrentReceiverArgs
  var _result228 ApplyCurrentReceiverResult
  var _meta227 thrift.ResponseMeta
  _meta227, _err = p.Client_().Call(ctx, "current_receiver", &_args226, &_result228)
  p.SetLastResponseMeta_(_meta227)
  if _err != nil {
    return
  }
  if _ret229 := _result228.GetSuccess(); _ret229 != nil {
    return _ret229, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_receiver failed: unknown result")
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssert(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args230 ApplyEosioAssertArgs
  _args230.Test = test
  _args230.Msg = msg
  var _result232 ApplyEosioAssertResult
  var _meta231 thrift.ResponseMeta
  _meta231, _err = p.Client_().Call(ctx, "eosio_assert", &_args230, &_result232)
  p.SetLastResponseMeta_(_meta231)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args233 ApplyEosioAssertMessageArgs
  _args233.Test = test
  _args233.Msg = msg
  var _result235 ApplyEosioAssertMessageResult
  var _meta234 thrift.ResponseMeta
  _meta234, _err = p.Client_().Call(ctx, "eosio_assert_message", &_args233, &_result235)
  p.SetLastResponseMeta_(_meta234)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Code
func (p *ApplyClient) EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error) {
  var _args236 ApplyEosioAssertCodeArgs
  _args236.Test = test
  _args236.Code = code
  var _result238 ApplyEosioAssertCodeResult
  var _meta237 thrift.ResponseMeta
  _meta237, _err = p.Client_().Call(ctx, "eosio_assert_code", &_args236, &_result238)
  p.SetLastResponseMeta_(_meta237)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Code
func (p *ApplyClient) EosioExit(ctx context.Context, code int32) (_err error) {
  var _args239 ApplyEosioExitArgs
  _args239.Code = code
  var _result241 ApplyEosioExitResult
  var _meta240 thrift.ResponseMeta
  _meta240, _err = p.Client_().Call(ctx, "eosio_exit", &_args239, &_result241)
  p.SetLastResponseMeta_(_meta240)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) CurrentTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args242 ApplyCurrentTimeArgs
  var _result244 ApplyCurrentTimeResult
  var _meta243 thrift.ResponseMeta
  _meta243, _err = p.Client_().Call(ctx, "current_time", &_args242, &_result244)
  p.SetLastResponseMeta_(_meta243)
  if _err != nil {
    return
  }
  if _ret245 := _result244.GetSuccess(); _ret245 != nil {
    return _ret245, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_time failed: unknown result")
}

// Parameters:
//  - FeatureDigest
func (p *ApplyClient) IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error) {
  var _args246 ApplyIsFeatureActivatedArgs
  _args246.FeatureDigest = feature_digest
  var _result248 ApplyIsFeatureActivatedResult
  var _meta247 thrift.ResponseMeta
  _meta247, _err = p.Client_().Call(ctx, "is_feature_activated", &_args246, &_result248)
  p.SetLastResponseMeta_(_meta247)
  if _err != nil {
    return
  }
  return _result248.GetSuccess(), nil
}

func (p *ApplyClient) GetSender(ctx context.Context) (_r *Uint64, _err error) {
  var _args249 ApplyGetSenderArgs
  var _result251 ApplyGetSenderResult
  var _meta250 thrift.ResponseMeta
  _meta250, _err = p.Client_().Call(ctx, "get_sender", &_args249, &_result251)
  p.SetLastResponseMeta_(_meta250)
  if _err != nil {
    return
  }
  if _ret252 := _result251.GetSuccess(); _ret252 != nil {
    return _ret252, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get_sender failed: unknown result")
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args253 ApplyAssertSha256Args
  _args253.Data = data
  _args253.Hash = hash
  var _result255 ApplyAssertSha256Result
  var _meta254 thrift.ResponseMeta
  _meta254, _err = p.Client_().Call(ctx, "assert_sha256", &_args253, &_result255)
  p.SetLastResponseMeta_(_meta254)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args256 ApplyAssertSha1Args
  _args256.Data = data
  _args256.Hash = hash
  var _result258 ApplyAssertSha1Result
  var _meta257 thrift.ResponseMeta
  _meta257, _err = p.Client_().Call(ctx, "assert_sha1", &_args256, &_result258)
  p.SetLastResponseMeta_(_meta257)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args259 ApplyAssertSha512Args
  _args259.Data = data
  _args259.Hash = hash
  var _result261 ApplyAssertSha512Result
  var _meta260 thrift.ResponseMeta
  _meta260, _err = p.Client_().Call(ctx, "assert_sha512", &_args259, &_result261)
  p.SetLastResponseMeta_(_meta260)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args262 ApplyAssertRipemd160Args
  _args262.Data = data
  _args262.Hash = hash
  var _result264 ApplyAssertRipemd160Result
  var _meta263 thrift.ResponseMeta
  _meta263, _err = p.Client_().Call(ctx, "assert_ripemd160", &_args262, &_result264)
  p.SetLastResponseMeta_(_meta263)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha256(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args265 ApplySha256Args
  _args265.Data = data
  var _result267 ApplySha256Result
  var _meta266 thrift.ResponseMeta
  _meta266, _err = p.Client_().Call(ctx, "sha256", &_args265, &_result267)
  p.SetLastResponseMeta_(_meta266)
  if _err != nil {
    return
  }
  return _result267.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha1(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args268 ApplySha1Args
  _args268.Data = data
  var _result270 ApplySha1Result
  var _meta269 thrift.ResponseMeta
  _meta269, _err = p.Client_().Call(ctx, "sha1", &_args268, &_result270)
  p.SetLastResponseMeta_(_meta269)
  if _err != nil {
    return
  }
  return _result270.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha512(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args271 ApplySha512Args
  _args271.Data = data
  var _result273 ApplySha512Result
  var _meta272 thrift.ResponseMeta
  _meta272, _err = p.Client_().Call(ctx, "sha512", &_args271, &_result273)
  p.SetLastResponseMeta_(_meta272)
  if _err != nil {
    return
  }
  return _result273.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args274 ApplyRipemd160Args
  _args274.Data = data
  var _result276 ApplyRipemd160Result
  var _meta275 thrift.ResponseMeta
  _meta275, _err = p.Client_().Call(ctx, "ripemd160", &_args274, &_result276)
  p.SetLastResponseMeta_(_meta275)
  if _err != nil {
    return
  }
  return _result276.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
func (p *ApplyClient) RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error) {
  var _args277 ApplyRecoverKeyArgs
  _args277.Digest = digest
  _args277.Sig = sig
  var _result279 ApplyRecoverKeyResult
  var _meta278 thrift.ResponseMeta
  _meta278, _err = p.Client_().Call(ctx, "recover_key", &_args277, &_result279)
  p.SetLastResponseMeta_(_meta278)
  if _err != nil {
    return
  }
  return _result279.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
//  - Pub
func (p *ApplyClient) AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error) {
  var _args280 ApplyAssertRecoverKeyArgs
  _args280.Digest = digest
  _args280.Sig = sig
  _args280.Pub = pub
  var _result282 ApplyAssertRecoverKeyResult
  var _meta281 thrift.ResponseMeta
  _meta281, _err = p.Client_().Call(ctx, "assert_recover_key", &_args280, &_result282)
  p.SetLastResponseMeta_(_meta281)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
func (p *ApplyClient) SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error) {
  var _args283 ApplySendDeferredArgs
  _args283.SenderID = sender_id
  _args283.Payer = payer
  _args283.SerializedTransaction = serialized_transaction
  _args283.ReplaceExisting = replace_existing
  var _result285 ApplySendDeferredResult
  var _meta284 thrift.ResponseMeta
  _meta284, _err = p.Client_().Call(ctx, "send_deferred", &_args283, &_result285)
  p.SetLastResponseMeta_(_meta284)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
func (p *ApplyClient) CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error) {
  var _args286 ApplyCancelDeferredArgs
  _args286.SenderID = sender_id
  var _result288 ApplyCancelDeferredResult
  var _meta287 thrift.ResponseMeta
  _meta287, _err = p.Client_().Call(ctx, "cancel_deferred", &_args286, &_result288)
  p.SetLastResponseMeta_(_meta287)
  if _err != nil {
    return
  }
  return _result288.GetSuccess(), nil
}

func (p *ApplyClient) ReadTransaction(ctx context.Context) (_r []byte, _err error) {
  var _args289 ApplyReadTransactionArgs
  var _result291 ApplyReadTransactionResult
  var _meta290 thrift.ResponseMeta
  _meta290, _err = p.Client_().Call(ctx, "read_transaction", &_args289, &_result291)
  p.SetLastResponseMeta_(_meta290)
  if _err != nil {
    return
  }
  return _result291.GetSuccess(), nil
}

func (p *ApplyClient) TransactionSize(ctx context.Context) (_r int32, _err error) {
  var _args292 ApplyTransactionSizeArgs
  var _result294 ApplyTransactionSizeResult
  var _meta293 thrift.ResponseMeta
  _meta293, _err = p.Client_().Call(ctx, "transaction_size", &_args292, &_result294)
  p.SetLastResponseMeta_(_meta293)
  if _err != nil {
    return
  }
  return _result294.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockNum(ctx context.Context) (_r int32, _err error) {
  var _args295 ApplyTaposBlockNumArgs
  var _result297 ApplyTaposBlockNumResult
  var _meta296 thrift.ResponseMeta
  _meta296, _err = p.Client_().Call(ctx, "tapos_block_num", &_args295, &_result297)
  p.SetLastResponseMeta_(_meta296)
  if _err != nil {
    return
  }
  return _result297.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockPrefix(ctx context.Context) (_r int32, _err error) {
  var _args298 ApplyTaposBlockPrefixArgs
  var _result300 ApplyTaposBlockPrefixResult
  var _meta299 thrift.ResponseMeta
  _meta299, _err = p.Client_().Call(ctx, "tapos_block_prefix", &_args298, &_result300)
  p.SetLastResponseMeta_(_meta299)
  if _err != nil {
    return
  }
  return _result300.GetSuccess(), nil
}

func (p *ApplyClient) Expiration(ctx context.Context) (_r int64, _err error) {
  var _args301 ApplyExpirationArgs
  var _result303 ApplyExpirationResult
  var _meta302 thrift.ResponseMeta
  _meta302, _err = p.Client_().Call(ctx, "expiration", &_args301, &_result303)
  p.SetLastResponseMeta_(_meta302)
  if _err != nil {
    return
  }
  return _result303.GetSuccess(), nil
}

// Parameters:
//  - _type
//  - Index
func (p *ApplyClient) GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error) {
  var _args304 ApplyGetActionArgs
  _args304._type = _type
  _args304.Index = index
  var _result306 ApplyGetActionResult
  var _meta305 thrift.ResponseMeta
  _meta305, _err = p.Client_().Call(ctx, "get_action", &_args304, &_result306)
  p.SetLastResponseMeta_(_meta305)
  if _err != nil {
    return
  }
  return _result306.GetSuccess(), nil
}

// Parameters:
//  - Index
func (p *ApplyClient) GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error) {
  var _args307 ApplyGetContextFreeDataArgs
  _args307.Index = index
  var _result309 ApplyGetContextFreeDataResult
  var _meta308 thrift.ResponseMeta
  _meta308, _err = p.Client_().Call(ctx, "get_context_free_data", &_args307, &_result309)
  p.SetLastResponseMeta_(_meta308)
  if _err != nil {
    return
  }
  return _result309.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args310 ApplyDbStoreI64Args
  _args310.Scope = scope
  _args310.Table = table
  _args310.Payer = payer
  _args310.ID = id
  _args310.Data = data
  var _result312 ApplyDbStoreI64Result
  var _meta311 thrift.ResponseMeta
  _meta311, _err = p.Client_().Call(ctx, "db_store_i64", &_args310, &_result312)
  p.SetLastResponseMeta_(_meta311)
  if _err != nil {
    return
  }
  return _result312.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args313 ApplyDbUpdateI64Args
  _args313.Iterator = iterator
  _args313.Payer = payer
  _args313.Data = data
  var _result315 ApplyDbUpdateI64Result
  var _meta314 thrift.ResponseMeta
  _meta314, _err = p.Client_().Call(ctx, "db_update_i64", &_args313, &_result315)
  p.SetLastResponseMeta_(_meta314)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbRemoveI64(ctx context.Context, iterator int32) (_err error) {
  var _args316 ApplyDbRemoveI64Args
  _args316.Iterator = iterator
  var _result318 ApplyDbRemoveI64Result
  var _meta317 thrift.ResponseMeta
  _meta317, _err = p.Client_().Call(ctx, "db_remove_i64", &_args316, &_result318)
  p.SetLastResponseMeta_(_meta317)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error) {
  var _args319 ApplyDbGetI64Args
  _args319.Iterator = iterator
  var _result321 ApplyDbGetI64Result
  var _meta320 thrift.ResponseMeta
  _meta320, _err = p.Client_().Call(ctx, "db_get_i64", &_args319, &_result321)
  p.SetLastResponseMeta_(_meta320)
  if _err != nil {
    return
  }
  return _result321.GetSuccess(), nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args322 ApplyDbNextI64Args
  _args322.Iterator = iterator
  var _result324 ApplyDbNextI64Result
  var _meta323 thrift.ResponseMeta
  _meta323, _err = p.Client_().Call(ctx, "db_next_i64", &_args322, &_result324)
  p.SetLastResponseMeta_(_meta323)
  if _err != nil {
    return
  }
  if _ret325 := _result324.GetSuccess(); _ret325 != nil {
    return _ret325, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_next_i64 failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args326 ApplyDbPreviousI64Args
  _args326.Iterator = iterator
  var _result328 ApplyDbPreviousI64Result
  var _meta327 thrift.ResponseMeta
  _meta327, _err = p.Client_().Call(ctx, "db_previous_i64", &_args326, &_result328)
  p.SetLastResponseMeta_(_meta327)
  if _err != nil {
    return
  }
  if _ret329 := _result328.GetSuccess(); _ret329 != nil {
    return _ret329, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_previous_i64 failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args330 ApplyDbFindI64Args
  _args330.Code = code
  _args330.Scope = scope
  _args330.Table = table
  _args330.ID = id
  var _result332 ApplyDbFindI64Result
  var _meta331 thrift.ResponseMeta
  _meta331, _err = p.Client_().Call(ctx, "db_find_i64", &_args330, &_result332)
  p.SetLastResponseMeta_(_meta331)
  if _err != nil {
    return
  }
  return _result332.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args333 ApplyDbLowerboundI64Args
  _args333.Code = code
  _args333.Scope = scope
  _args333.Table = table
  _args333.ID = id
  var _result335 ApplyDbLowerboundI64Result
  var _meta334 thrift.ResponseMeta
  _meta334, _err = p.Client_().Call(ctx, "db_lowerbound_i64", &_args333, &_result335)
  p.SetLastResponseMeta_(_meta334)
  if _err != nil {
    return
  }
  return _result335.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args336 ApplyDbUpperboundI64Args
  _args336.Code = code
  _args336.Scope = scope
  _args336.Table = table
  _args336.ID = id
  var _result338 ApplyDbUpperboundI64Result
  var _meta337 thrift.ResponseMeta
  _meta337, _err = p.Client_().Call(ctx, "db_upperbound_i64", &_args336, &_result338)
  p.SetLastResponseMeta_(_meta337)
  if _err != nil {
    return
  }
  return _result338.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args339 ApplyDbEndI64Args
  _args339.Code = code
  _args339.Scope = scope
  _args339.Table = table
  var _result341 ApplyDbEndI64Result
  var _meta340 thrift.ResponseMeta
  _meta340, _err = p.Client_().Call(ctx, "db_end_i64", &_args339, &_result341)
  p.SetLastResponseMeta_(_meta340)
  if _err != nil {
    return
  }
  return _result341.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error) {
  var _args342 ApplyDbIdx64StoreArgs
  _args342.Scope = scope
  _args342.Table = table
  _args342.Payer = payer
  _args342.ID = id
  _args342.Secondary = secondary
  var _result344 ApplyDbIdx64StoreResult
  var _meta343 thrift.ResponseMeta
  _meta343, _err = p.Client_().Call(ctx, "db_idx64_store", &_args342, &_result344)
  p.SetLastResponseMeta_(_meta343)
  if _err != nil {
    return
  }
  return _result344.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error) {
  var _args345 ApplyDbIdx64UpdateArgs
  _args345.Iterator = iterator
  _args345.Payer = payer
  _args345.Secondary = secondary
  var _result347 ApplyDbIdx64UpdateResult
  var _meta346 thrift.ResponseMeta
  _meta346, _err = p.Client_().Call(ctx, "db_idx64_update", &_args345, &_result347)
  p.SetLastResponseMeta_(_meta346)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Remove(ctx context.Context, iterator int32) (_err error) {
  var _args348 ApplyDbIdx64RemoveArgs
  _args348.Iterator = iterator
  var _result350 ApplyDbIdx64RemoveResult
  var _meta349 thrift.ResponseMeta
  _meta349, _err = p.Client_().Call(ctx, "db_idx64_remove", &_args348, &_result350)
  p.SetLastResponseMeta_(_meta349)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args351 ApplyDbIdx64NextArgs
  _args351.Iterator = iterator
  var _result353 ApplyDbIdx64NextResult
  var _meta352 thrift.ResponseMeta
  _meta352, _err = p.Client_().Call(ctx, "db_idx64_next", &_args351, &_result353)
  p.SetLastResponseMeta_(_meta352)
  if _err != nil {
    return
  }
  if _ret354 := _result353.GetSuccess(); _ret354 != nil {
    return _ret354, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_next failed: unknown result")
}

// Parameters:
//  - Iteratory
func (p *ApplyClient) DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error) {
  var _args355 ApplyDbIdx64PreviousArgs
  _args355.Iteratory = iteratory
  var _result357 ApplyDbIdx64PreviousResult
  var _meta356 thrift.ResponseMeta
  _meta356, _err = p.Client_().Call(ctx, "db_idx64_previous", &_args355, &_result357)
  p.SetLastResponseMeta_(_meta356)
  if _err != nil {
    return
  }
  if _ret358 := _result357.GetSuccess(); _ret358 != nil {
    return _ret358, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args359 ApplyDbIdx64FindPrimaryArgs
  _args359.Code = code
  _args359.Scope = scope
  _args359.Table = table
  _args359.Primary = primary
  var _result361 ApplyDbIdx64FindPrimaryResult
  var _meta360 thrift.ResponseMeta
  _meta360, _err = p.Client_().Call(ctx, "db_idx64_find_primary", &_args359, &_result361)
  p.SetLastResponseMeta_(_meta360)
  if _err != nil {
    return
  }
  if _ret362 := _result361.GetSuccess(); _ret362 != nil {
    return _ret362, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error) {
  var _args363 ApplyDbIdx64FindSecondaryArgs
  _args363.Code = code
  _args363.Scope = scope
  _args363.Table = table
  _args363.Secondary = secondary
  var _result365 ApplyDbIdx64FindSecondaryResult
  var _meta364 thrift.ResponseMeta
  _meta364, _err = p.Client_().Call(ctx, "db_idx64_find_secondary", &_args363, &_result365)
  p.SetLastResponseMeta_(_meta364)
  if _err != nil {
    return
  }
  if _ret366 := _result365.GetSuccess(); _ret366 != nil {
    return _ret366, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args367 ApplyDbIdx64LowerboundArgs
  _args367.Code = code
  _args367.Scope = scope
  _args367.Table = table
  _args367.Secondary = secondary
  _args367.Primary = primary
  var _result369 ApplyDbIdx64LowerboundResult
  var _meta368 thrift.ResponseMeta
  _meta368, _err = p.Client_().Call(ctx, "db_idx64_lowerbound", &_args367, &_result369)
  p.SetLastResponseMeta_(_meta368)
  if _err != nil {
    return
  }
  if _ret370 := _result369.GetSuccess(); _ret370 != nil {
    return _ret370, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args371 ApplyDbIdx64UpperboundArgs
  _args371.Code = code
  _args371.Scope = scope
  _args371.Table = table
  _args371.Secondary = secondary
  _args371.Primary = primary
  var _result373 ApplyDbIdx64UpperboundResult
  var _meta372 thrift.ResponseMeta
  _meta372, _err = p.Client_().Call(ctx, "db_idx64_upperbound", &_args371, &_result373)
  p.SetLastResponseMeta_(_meta372)
  if _err != nil {
    return
  }
  if _ret374 := _result373.GetSuccess(); _ret374 != nil {
    return _ret374, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args375 ApplyDbIdx64EndArgs
  _args375.Code = code
  _args375.Scope = scope
  _args375.Table = table
  var _result377 ApplyDbIdx64EndResult
  var _meta376 thrift.ResponseMeta
  _meta376, _err = p.Client_().Call(ctx, "db_idx64_end", &_args375, &_result377)
  p.SetLastResponseMeta_(_meta376)
  if _err != nil {
    return
  }
  return _result377.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args378 ApplyDbIdx128StoreArgs
  _args378.Scope = scope
  _args378.Table = table
  _args378.Payer = payer
  _args378.ID = id
  _args378.Secondary = secondary
  var _result380 ApplyDbIdx128StoreResult
  var _meta379 thrift.ResponseMeta
  _meta379, _err = p.Client_().Call(ctx, "db_idx128_store", &_args378, &_result380)
  p.SetLastResponseMeta_(_meta379)
  if _err != nil {
    return
  }
  return _result380.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args381 ApplyDbIdx128UpdateArgs
  _args381.Iterator = iterator
  _args381.Payer = payer
  _args381.Secondary = secondary
  var _result383 ApplyDbIdx128UpdateResult
  var _meta382 thrift.ResponseMeta
  _meta382, _err = p.Client_().Call(ctx, "db_idx128_update", &_args381, &_result383)
  p.SetLastResponseMeta_(_meta382)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Remove(ctx context.Context, iterator int32) (_err error) {
  var _args384 ApplyDbIdx128RemoveArgs
  _args384.Iterator = iterator
  var _result386 ApplyDbIdx128RemoveResult
  var _meta385 thrift.ResponseMeta
  _meta385, _err = p.Client_().Call(ctx, "db_idx128_remove", &_args384, &_result386)
  p.SetLastResponseMeta_(_meta385)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args387 ApplyDbIdx128NextArgs
  _args387.Iterator = iterator
  var _result389 ApplyDbIdx128NextResult
  var _meta388 thrift.ResponseMeta
  _meta388, _err = p.Client_().Call(ctx, "db_idx128_next", &_args387, &_result389)
  p.SetLastResponseMeta_(_meta388)
  if _err != nil {
    return
  }
  if _ret390 := _result389.GetSuccess(); _ret390 != nil {
    return _ret390, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args391 ApplyDbIdx128PreviousArgs
  _args391.Iterator = iterator
  var _result393 ApplyDbIdx128PreviousResult
  var _meta392 thrift.ResponseMeta
  _meta392, _err = p.Client_().Call(ctx, "db_idx128_previous", &_args391, &_result393)
  p.SetLastResponseMeta_(_meta392)
  if _err != nil {
    return
  }
  if _ret394 := _result393.GetSuccess(); _ret394 != nil {
    return _ret394, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args395 ApplyDbIdx128FindPrimaryArgs
  _args395.Code = code
  _args395.Scope = scope
  _args395.Table = table
  _args395.Primary = primary
  var _result397 ApplyDbIdx128FindPrimaryResult
  var _meta396 thrift.ResponseMeta
  _meta396, _err = p.Client_().Call(ctx, "db_idx128_find_primary", &_args395, &_result397)
  p.SetLastResponseMeta_(_meta396)
  if _err != nil {
    return
  }
  if _ret398 := _result397.GetSuccess(); _ret398 != nil {
    return _ret398, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args399 ApplyDbIdx128FindSecondaryArgs
  _args399.Code = code
  _args399.Scope = scope
  _args399.Table = table
  _args399.Secondary = secondary
  var _result401 ApplyDbIdx128FindSecondaryResult
  var _meta400 thrift.ResponseMeta
  _meta400, _err = p.Client_().Call(ctx, "db_idx128_find_secondary", &_args399, &_result401)
  p.SetLastResponseMeta_(_meta400)
  if _err != nil {
    return
  }
  if _ret402 := _result401.GetSuccess(); _ret402 != nil {
    return _ret402, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args403 ApplyDbIdx128LowerboundArgs
  _args403.Code = code
  _args403.Scope = scope
  _args403.Table = table
  _args403.Secondary = secondary
  _args403.Primary = primary
  var _result405 ApplyDbIdx128LowerboundResult
  var _meta404 thrift.ResponseMeta
  _meta404, _err = p.Client_().Call(ctx, "db_idx128_lowerbound", &_args403, &_result405)
  p.SetLastResponseMeta_(_meta404)
  if _err != nil {
    return
  }
  if _ret406 := _result405.GetSuccess(); _ret406 != nil {
    return _ret406, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args407 ApplyDbIdx128UpperboundArgs
  _args407.Code = code
  _args407.Scope = scope
  _args407.Table = table
  _args407.Secondary = secondary
  _args407.Primary = primary
  var _result409 ApplyDbIdx128UpperboundResult
  var _meta408 thrift.ResponseMeta
  _meta408, _err = p.Client_().Call(ctx, "db_idx128_upperbound", &_args407, &_result409)
  p.SetLastResponseMeta_(_meta408)
  if _err != nil {
    return
  }
  if _ret410 := _result409.GetSuccess(); _ret410 != nil {
    return _ret410, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args411 ApplyDbIdx128EndArgs
  _args411.Code = code
  _args411.Scope = scope
  _args411.Table = table
  var _result413 ApplyDbIdx128EndResult
  var _meta412 thrift.ResponseMeta
  _meta412, _err = p.Client_().Call(ctx, "db_idx128_end", &_args411, &_result413)
  p.SetLastResponseMeta_(_meta412)
  if _err != nil {
    return
  }
  return _result413.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args414 ApplyDbIdx256StoreArgs
  _args414.Scope = scope
  _args414.Table = table
  _args414.Payer = payer
  _args414.ID = id
  _args414.Data = data
  var _result416 ApplyDbIdx256StoreResult
  var _meta415 thrift.ResponseMeta
  _meta415, _err = p.Client_().Call(ctx, "db_idx256_store", &_args414, &_result416)
  p.SetLastResponseMeta_(_meta415)
  if _err != nil {
    return
  }
  return _result416.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args417 ApplyDbIdx256UpdateArgs
  _args417.Iterator = iterator
  _args417.Payer = payer
  _args417.Data = data
  var _result419 ApplyDbIdx256UpdateResult
  var _meta418 thrift.ResponseMeta
  _meta418, _err = p.Client_().Call(ctx, "db_idx256_update", &_args417, &_result419)
  p.SetLastResponseMeta_(_meta418)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Remove(ctx context.Context, iterator int32) (_err error) {
  var _args420 ApplyDbIdx256RemoveArgs
  _args420.Iterator = iterator
  var _result422 ApplyDbIdx256RemoveResult
  var _meta421 thrift.ResponseMeta
  _meta421, _err = p.Client_().Call(ctx, "db_idx256_remove", &_args420, &_result422)
  p.SetLastResponseMeta_(_meta421)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args423 ApplyDbIdx256NextArgs
  _args423.Iterator = iterator
  var _result425 ApplyDbIdx256NextResult
  var _meta424 thrift.ResponseMeta
  _meta424, _err = p.Client_().Call(ctx, "db_idx256_next", &_args423, &_result425)
  p.SetLastResponseMeta_(_meta424)
  if _err != nil {
    return
  }
  if _ret426 := _result425.GetSuccess(); _ret426 != nil {
    return _ret426, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args427 ApplyDbIdx256PreviousArgs
  _args427.Iterator = iterator
  var _result429 ApplyDbIdx256PreviousResult
  var _meta428 thrift.ResponseMeta
  _meta428, _err = p.Client_().Call(ctx, "db_idx256_previous", &_args427, &_result429)
  p.SetLastResponseMeta_(_meta428)
  if _err != nil {
    return
  }
  if _ret430 := _result429.GetSuccess(); _ret430 != nil {
    return _ret430, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args431 ApplyDbIdx256FindPrimaryArgs
  _args431.Code = code
  _args431.Scope = scope
  _args431.Table = table
  _args431.Primary = primary
  var _result433 ApplyDbIdx256FindPrimaryResult
  var _meta432 thrift.ResponseMeta
  _meta432, _err = p.Client_().Call(ctx, "db_idx256_find_primary", &_args431, &_result433)
  p.SetLastResponseMeta_(_meta432)
  if _err != nil {
    return
  }
  if _ret434 := _result433.GetSuccess(); _ret434 != nil {
    return _ret434, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
func (p *ApplyClient) DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error) {
  var _args435 ApplyDbIdx256FindSecondaryArgs
  _args435.Code = code
  _args435.Scope = scope
  _args435.Table = table
  _args435.Data = data
  var _result437 ApplyDbIdx256FindSecondaryResult
  var _meta436 thrift.ResponseMeta
  _meta436, _err = p.Client_().Call(ctx, "db_idx256_find_secondary", &_args435, &_result437)
  p.SetLastResponseMeta_(_meta436)
  if _err != nil {
    return
  }
  if _ret438 := _result437.GetSuccess(); _ret438 != nil {
    return _ret438, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args439 ApplyDbIdx256LowerboundArgs
  _args439.Code = code
  _args439.Scope = scope
  _args439.Table = table
  _args439.Data = data
  _args439.Primary = primary
  var _result441 ApplyDbIdx256LowerboundResult
  var _meta440 thrift.ResponseMeta
  _meta440, _err = p.Client_().Call(ctx, "db_idx256_lowerbound", &_args439, &_result441)
  p.SetLastResponseMeta_(_meta440)
  if _err != nil {
    return
  }
  if _ret442 := _result441.GetSuccess(); _ret442 != nil {
    return _ret442, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args443 ApplyDbIdx256UpperboundArgs
  _args443.Code = code
  _args443.Scope = scope
  _args443.Table = table
  _args443.Data = data
  _args443.Primary = primary
  var _result445 ApplyDbIdx256UpperboundResult
  var _meta444 thrift.ResponseMeta
  _meta444, _err = p.Client_().Call(ctx, "db_idx256_upperbound", &_args443, &_result445)
  p.SetLastResponseMeta_(_meta444)
  if _err != nil {
    return
  }
  if _ret446 := _result445.GetSuccess(); _ret446 != nil {
    return _ret446, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args447 ApplyDbIdx256EndArgs
  _args447.Code = code
  _args447.Scope = scope
  _args447.Table = table
  var _result449 ApplyDbIdx256EndResult
  var _meta448 thrift.ResponseMeta
  _meta448, _err = p.Client_().Call(ctx, "db_idx256_end", &_args447, &_result449)
  p.SetLastResponseMeta_(_meta448)
  if _err != nil {
    return
  }
  return _result449.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args450 ApplyDbIdxDoubleStoreArgs
  _args450.Scope = scope
  _args450.Table = table
  _args450.Payer = payer
  _args450.ID = id
  _args450.Secondary = secondary
  var _result452 ApplyDbIdxDoubleStoreResult
  var _meta451 thrift.ResponseMeta
  _meta451, _err = p.Client_().Call(ctx, "db_idx_double_store", &_args450, &_result452)
  p.SetLastResponseMeta_(_meta451)
  if _err != nil {
    return
  }
  return _result452.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args453 ApplyDbIdxDoubleUpdateArgs
  _args453.Iterator = iterator
  _args453.Payer = payer
  _args453.Secondary = secondary
  var _result455 ApplyDbIdxDoubleUpdateResult
  var _meta454 thrift.ResponseMeta
  _meta454, _err = p.Client_().Call(ctx, "db_idx_double_update", &_args453, &_result455)
  p.SetLastResponseMeta_(_meta454)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args456 ApplyDbIdxDoubleRemoveArgs
  _args456.Iterator = iterator
  var _result458 ApplyDbIdxDoubleRemoveResult
  var _meta457 thrift.ResponseMeta
  _meta457, _err = p.Client_().Call(ctx, "db_idx_double_remove", &_args456, &_result458)
  p.SetLastResponseMeta_(_meta457)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args459 ApplyDbIdxDoubleNextArgs
  _args459.Iterator = iterator
  var _result461 ApplyDbIdxDoubleNextResult
  var _meta460 thrift.ResponseMeta
  _meta460, _err = p.Client_().Call(ctx, "db_idx_double_next", &_args459, &_result461)
  p.SetLastResponseMeta_(_meta460)
  if _err != nil {
    return
  }
  if _ret462 := _result461.GetSuccess(); _ret462 != nil {
    return _ret462, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args463 ApplyDbIdxDoublePreviousArgs
  _args463.Iterator = iterator
  var _result465 ApplyDbIdxDoublePreviousResult
  var _meta464 thrift.ResponseMeta
  _meta464, _err = p.Client_().Call(ctx, "db_idx_double_previous", &_args463, &_result465)
  p.SetLastResponseMeta_(_meta464)
  if _err != nil {
    return
  }
  if _ret466 := _result465.GetSuccess(); _ret466 != nil {
    return _ret466, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args467 ApplyDbIdxDoubleFindPrimaryArgs
  _args467.Code = code
  _args467.Scope = scope
  _args467.Table = table
  _args467.Primary = primary
  var _result469 ApplyDbIdxDoubleFindPrimaryResult
  var _meta468 thrift.ResponseMeta
  _meta468, _err = p.Client_().Call(ctx, "db_idx_double_find_primary", &_args467, &_result469)
  p.SetLastResponseMeta_(_meta468)
  if _err != nil {
    return
  }
  if _ret470 := _result469.GetSuccess(); _ret470 != nil {
    return _ret470, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args471 ApplyDbIdxDoubleFindSecondaryArgs
  _args471.Code = code
  _args471.Scope = scope
  _args471.Table = table
  _args471.Secondary = secondary
  var _result473 ApplyDbIdxDoubleFindSecondaryResult
  var _meta472 thrift.ResponseMeta
  _meta472, _err = p.Client_().Call(ctx, "db_idx_double_find_secondary", &_args471, &_result473)
  p.SetLastResponseMeta_(_meta472)
  if _err != nil {
    return
  }
  if _ret474 := _result473.GetSuccess(); _ret474 != nil {
    return _ret474, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args475 ApplyDbIdxDoubleLowerboundArgs
  _args475.Code = code
  _args475.Scope = scope
  _args475.Table = table
  _args475.Secondary = secondary
  _args475.Primary = primary
  var _result477 ApplyDbIdxDoubleLowerboundResult
  var _meta476 thrift.ResponseMeta
  _meta476, _err = p.Client_().Call(ctx, "db_idx_double_lowerbound", &_args475, &_result477)
  p.SetLastResponseMeta_(_meta476)
  if _err != nil {
    return
  }
  if _ret478 := _result477.GetSuccess(); _ret478 != nil {
    return _ret478, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args479 ApplyDbIdxDoubleUpperboundArgs
  _args479.Code = code
  _args479.Scope = scope
  _args479.Table = table
  _args479.Secondary = secondary
  _args479.Primary = primary
  var _result481 ApplyDbIdxDoubleUpperboundResult
  var _meta480 thrift.ResponseMeta
  _meta480, _err = p.Client_().Call(ctx, "db_idx_double_upperbound", &_args479, &_result481)
  p.SetLastResponseMeta_(_meta480)
  if _err != nil {
    return
  }
  if _ret482 := _result481.GetSuccess(); _ret482 != nil {
    return _ret482, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args483 ApplyDbIdxDoubleEndArgs
  _args483.Code = code
  _args483.Scope = scope
  _args483.Table = table
  var _result485 ApplyDbIdxDoubleEndResult
  var _meta484 thrift.ResponseMeta
  _meta484, _err = p.Client_().Call(ctx, "db_idx_double_end", &_args483, &_result485)
  p.SetLastResponseMeta_(_meta484)
  if _err != nil {
    return
  }
  return _result485.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args486 ApplyDbIdxLongDoubleStoreArgs
  _args486.Scope = scope
  _args486.Table = table
  _args486.Payer = payer
  _args486.ID = id
  _args486.Secondary = secondary
  var _result488 ApplyDbIdxLongDoubleStoreResult
  var _meta487 thrift.ResponseMeta
  _meta487, _err = p.Client_().Call(ctx, "db_idx_long_double_store", &_args486, &_result488)
  p.SetLastResponseMeta_(_meta487)
  if _err != nil {
    return
  }
  return _result488.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args489 ApplyDbIdxLongDoubleUpdateArgs
  _args489.Iterator = iterator
  _args489.Payer = payer
  _args489.Secondary = secondary
  var _result491 ApplyDbIdxLongDoubleUpdateResult
  var _meta490 thrift.ResponseMeta
  _meta490, _err = p.Client_().Call(ctx, "db_idx_long_double_update", &_args489, &_result491)
  p.SetLastResponseMeta_(_meta490)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args492 ApplyDbIdxLongDoubleRemoveArgs
  _args492.Iterator = iterator
  var _result494 ApplyDbIdxLongDoubleRemoveResult
  var _meta493 thrift.ResponseMeta
  _meta493, _err = p.Client_().Call(ctx, "db_idx_long_double_remove", &_args492, &_result494)
  p.SetLastResponseMeta_(_meta493)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args495 ApplyDbIdxLongDoubleNextArgs
  _args495.Iterator = iterator
  var _result497 ApplyDbIdxLongDoubleNextResult
  var _meta496 thrift.ResponseMeta
  _meta496, _err = p.Client_().Call(ctx, "db_idx_long_double_next", &_args495, &_result497)
  p.SetLastResponseMeta_(_meta496)
  if _err != nil {
    return
  }
  if _ret498 := _result497.GetSuccess(); _ret498 != nil {
    return _ret498, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args499 ApplyDbIdxLongDoublePreviousArgs
  _args499.Iterator = iterator
  var _result501 ApplyDbIdxLongDoublePreviousResult
  var _meta500 thrift.ResponseMeta
  _meta500, _err = p.Client_().Call(ctx, "db_idx_long_double_previous", &_args499, &_result501)
  p.SetLastResponseMeta_(_meta500)
  if _err != nil {
    return
  }
  if _ret502 := _result501.GetSuccess(); _ret502 != nil {
    return _ret502, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args503 ApplyDbIdxLongDoubleFindPrimaryArgs
  _args503.Code = code
  _args503.Scope = scope
  _args503.Table = table
  _args503.Primary = primary
  var _result505 ApplyDbIdxLongDoubleFindPrimaryResult
  var _meta504 thrift.ResponseMeta
  _meta504, _err = p.Client_().Call(ctx, "db_idx_long_double_find_primary", &_args503, &_result505)
  p.SetLastResponseMeta_(_meta504)
  if _err != nil {
    return
  }
  if _ret506 := _result505.GetSuccess(); _ret506 != nil {
    return _ret506, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args507 ApplyDbIdxLongDoubleFindSecondaryArgs
  _args507.Code = code
  _args507.Scope = scope
  _args507.Table = table
  _args507.Secondary = secondary
  var _result509 ApplyDbIdxLongDoubleFindSecondaryResult
  var _meta508 thrift.ResponseMeta
  _meta508, _err = p.Client_().Call(ctx, "db_idx_long_double_find_secondary", &_args507, &_result509)
  p.SetLastResponseMeta_(_meta508)
  if _err != nil {
    return
  }
  if _ret510 := _result509.GetSuccess(); _ret510 != nil {
    return _ret510, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args511 ApplyDbIdxLongDoubleLowerboundArgs
  _args511.Code = code
  _args511.Scope = scope
  _args511.Table = table
  _args511.Secondary = secondary
  _args511.Primary = primary
  var _result513 ApplyDbIdxLongDoubleLowerboundResult
  var _meta512 thrift.ResponseMeta
  _meta512, _err = p.Client_().Call(ctx, "db_idx_long_double_lowerbound", &_args511, &_result513)
  p.SetLastResponseMeta_(_meta512)
  if _err != nil {
    return
  }
  if _ret514 := _result513.GetSuccess(); _ret514 != nil {
    return _ret514, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args515 ApplyDbIdxLongDoubleUpperboundArgs
  _args515.Code = code
  _args515.Scope = scope
  _args515.Table = table
  _args515.Secondary = secondary
  _args515.Primary = primary
  var _result517 ApplyDbIdxLongDoubleUpperboundResult
  var _meta516 thrift.ResponseMeta
  _meta516, _err = p.Client_().Call(ctx, "db_idx_long_double_upperbound", &_args515, &_result517)
  p.SetLastResponseMeta_(_meta516)
  if _err != nil {
    return
  }
  if _ret518 := _result517.GetSuccess(); _ret518 != nil {
    return _ret518, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args519 ApplyDbIdxLongDoubleEndArgs
  _args519.Code = code
  _args519.Scope = scope
  _args519.Table = table
  var _result521 ApplyDbIdxLongDoubleEndResult
  var _meta520 thrift.ResponseMeta
  _meta520, _err = p.Client_().Call(ctx, "db_idx_long_double_end", &_args519, &_result521)
  p.SetLastResponseMeta_(_meta520)
  if _err != nil {
    return
  }
  return _result521.GetSuccess(), nil
}

type ApplyProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler Apply
}

func (p *ApplyProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyProcessor(handler Apply) *ApplyProcessor {

  self522 := &ApplyProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self522.processorMap["end_apply"] = &applyProcessorEndApply{handler:handler}
  self522.processorMap["get_active_producers"] = &applyProcessorGetActiveProducers{handler:handler}
  self522.processorMap["get_resource_limits"] = &applyProcessorGetResourceLimits{handler:handler}
  self522.processorMap["set_resource_limits"] = &applyProcessorSetResourceLimits{handler:handler}
  self522.processorMap["set_proposed_producers"] = &applyProcessorSetProposedProducers{handler:handler}
  self522.processorMap["set_proposed_producers_ex"] = &applyProcessorSetProposedProducersEx{handler:handler}
  self522.processorMap["is_privileged"] = &applyProcessorIsPrivileged{handler:handler}
  self522.processorMap["set_privileged"] = &applyProcessorSetPrivileged{handler:handler}
  self522.processorMap["set_blockchain_parameters_packed"] = &applyProcessorSetBlockchainParametersPacked{handler:handler}
  self522.processorMap["get_blockchain_parameters_packed"] = &applyProcessorGetBlockchainParametersPacked{handler:handler}
  self522.processorMap["preactivate_feature"] = &applyProcessorPreactivateFeature{handler:handler}
  self522.processorMap["check_transaction_authorization"] = &applyProcessorCheckTransactionAuthorization{handler:handler}
  self522.processorMap["check_permission_authorization"] = &applyProcessorCheckPermissionAuthorization{handler:handler}
  self522.processorMap["get_permission_last_used"] = &applyProcessorGetPermissionLastUsed{handler:handler}
  self522.processorMap["get_account_creation_time"] = &applyProcessorGetAccountCreationTime{handler:handler}
  self522.processorMap["prints"] = &applyProcessorPrints{handler:handler}
  self522.processorMap["prints_l"] = &applyProcessorPrintsL{handler:handler}
  self522.processorMap["printi"] = &applyProcessorPrinti{handler:handler}
  self522.processorMap["printui"] = &applyProcessorPrintui{handler:handler}
  self522.processorMap["printi128"] = &applyProcessorPrinti128{handler:handler}
  self522.processorMap["printui128"] = &applyProcessorPrintui128{handler:handler}
  self522.processorMap["printsf"] = &applyProcessorPrintsf{handler:handler}
  self522.processorMap["printdf"] = &applyProcessorPrintdf{handler:handler}
  self522.processorMap["printqf"] = &applyProcessorPrintqf{handler:handler}
  self522.processorMap["printn"] = &applyProcessorPrintn{handler:handler}
  self522.processorMap["printhex"] = &applyProcessorPrinthex{handler:handler}
  self522.processorMap["action_data_size"] = &applyProcessorActionDataSize{handler:handler}
  self522.processorMap["read_action_data"] = &applyProcessorReadActionData{handler:handler}
  self522.processorMap["require_recipient"] = &applyProcessorRequireRecipient{handler:handler}
  self522.processorMap["require_auth"] = &applyProcessorRequireAuth{handler:handler}
  self522.processorMap["has_auth"] = &applyProcessorHasAuth{handler:handler}
  self522.processorMap["require_auth2"] = &applyProcessorRequireAuth2{handler:handler}
  self522.processorMap["is_account"] = &applyProcessorIsAccount{handler:handler}
  self522.processorMap["send_inline"] = &applyProcessorSendInline{handler:handler}
  self522.processorMap["send_context_free_inline"] = &applyProcessorSendContextFreeInline{handler:handler}
  self522.processorMap["publication_time"] = &applyProcessorPublicationTime{handler:handler}
  self522.processorMap["current_receiver"] = &applyProcessorCurrentReceiver{handler:handler}
  self522.processorMap["eosio_assert"] = &applyProcessorEosioAssert{handler:handler}
  self522.processorMap["eosio_assert_message"] = &applyProcessorEosioAssertMessage{handler:handler}
  self522.processorMap["eosio_assert_code"] = &applyProcessorEosioAssertCode{handler:handler}
  self522.processorMap["eosio_exit"] = &applyProcessorEosioExit{handler:handler}
  self522.processorMap["current_time"] = &applyProcessorCurrentTime{handler:handler}
  self522.processorMap["is_feature_activated"] = &applyProcessorIsFeatureActivated{handler:handler}
  self522.processorMap["get_sender"] = &applyProcessorGetSender{handler:handler}
  self522.processorMap["assert_sha256"] = &applyProcessorAssertSha256{handler:handler}
  self522.processorMap["assert_sha1"] = &applyProcessorAssertSha1{handler:handler}
  self522.processorMap["assert_sha512"] = &applyProcessorAssertSha512{handler:handler}
  self522.processorMap["assert_ripemd160"] = &applyProcessorAssertRipemd160{handler:handler}
  self522.processorMap["sha256"] = &applyProcessorSha256{handler:handler}
  self522.processorMap["sha1"] = &applyProcessorSha1{handler:handler}
  self522.processorMap["sha512"] = &applyProcessorSha512{handler:handler}
  self522.processorMap["ripemd160"] = &applyProcessorRipemd160{handler:handler}
  self522.processorMap["recover_key"] = &applyProcessorRecoverKey{handler:handler}
  self522.processorMap["assert_recover_key"] = &applyProcessorAssertRecoverKey{handler:handler}
  self522.processorMap["send_deferred"] = &applyProcessorSendDeferred{handler:handler}
  self522.processorMap["cancel_deferred"] = &applyProcessorCancelDeferred{handler:handler}
  self522.processorMap["read_transaction"] = &applyProcessorReadTransaction{handler:handler}
  self522.processorMap["transaction_size"] = &applyProcessorTransactionSize{handler:handler}
  self522.processorMap["tapos_block_num"] = &applyProcessorTaposBlockNum{handler:handler}
  self522.processorMap["tapos_block_prefix"] = &applyProcessorTaposBlockPrefix{handler:handler}
  self522.processorMap["expiration"] = &applyProcessorExpiration{handler:handler}
  self522.processorMap["get_action"] = &applyProcessorGetAction{handler:handler}
  self522.processorMap["get_context_free_data"] = &applyProcessorGetContextFreeData{handler:handler}
  self522.processorMap["db_store_i64"] = &applyProcessorDbStoreI64{handler:handler}
  self522.processorMap["db_update_i64"] = &applyProcessorDbUpdateI64{handler:handler}
  self522.processorMap["db_remove_i64"] = &applyProcessorDbRemoveI64{handler:handler}
  self522.processorMap["db_get_i64"] = &applyProcessorDbGetI64{handler:handler}
  self522.processorMap["db_next_i64"] = &applyProcessorDbNextI64{handler:handler}
  self522.processorMap["db_previous_i64"] = &applyProcessorDbPreviousI64{handler:handler}
  self522.processorMap["db_find_i64"] = &applyProcessorDbFindI64{handler:handler}
  self522.processorMap["db_lowerbound_i64"] = &applyProcessorDbLowerboundI64{handler:handler}
  self522.processorMap["db_upperbound_i64"] = &applyProcessorDbUpperboundI64{handler:handler}
  self522.processorMap["db_end_i64"] = &applyProcessorDbEndI64{handler:handler}
  self522.processorMap["db_idx64_store"] = &applyProcessorDbIdx64Store{handler:handler}
  self522.processorMap["db_idx64_update"] = &applyProcessorDbIdx64Update{handler:handler}
  self522.processorMap["db_idx64_remove"] = &applyProcessorDbIdx64Remove{handler:handler}
  self522.processorMap["db_idx64_next"] = &applyProcessorDbIdx64Next{handler:handler}
  self522.processorMap["db_idx64_previous"] = &applyProcessorDbIdx64Previous{handler:handler}
  self522.processorMap["db_idx64_find_primary"] = &applyProcessorDbIdx64FindPrimary{handler:handler}
  self522.processorMap["db_idx64_find_secondary"] = &applyProcessorDbIdx64FindSecondary{handler:handler}
  self522.processorMap["db_idx64_lowerbound"] = &applyProcessorDbIdx64Lowerbound{handler:handler}
  self522.processorMap["db_idx64_upperbound"] = &applyProcessorDbIdx64Upperbound{handler:handler}
  self522.processorMap["db_idx64_end"] = &applyProcessorDbIdx64End{handler:handler}
  self522.processorMap["db_idx128_store"] = &applyProcessorDbIdx128Store{handler:handler}
  self522.processorMap["db_idx128_update"] = &applyProcessorDbIdx128Update{handler:handler}
  self522.processorMap["db_idx128_remove"] = &applyProcessorDbIdx128Remove{handler:handler}
  self522.processorMap["db_idx128_next"] = &applyProcessorDbIdx128Next{handler:handler}
  self522.processorMap["db_idx128_previous"] = &applyProcessorDbIdx128Previous{handler:handler}
  self522.processorMap["db_idx128_find_primary"] = &applyProcessorDbIdx128FindPrimary{handler:handler}
  self522.processorMap["db_idx128_find_secondary"] = &applyProcessorDbIdx128FindSecondary{handler:handler}
  self522.processorMap["db_idx128_lowerbound"] = &applyProcessorDbIdx128Lowerbound{handler:handler}
  self522.processorMap["db_idx128_upperbound"] = &applyProcessorDbIdx128Upperbound{handler:handler}
  self522.processorMap["db_idx128_end"] = &applyProcessorDbIdx128End{handler:handler}
  self522.processorMap["db_idx256_store"] = &applyProcessorDbIdx256Store{handler:handler}
  self522.processorMap["db_idx256_update"] = &applyProcessorDbIdx256Update{handler:handler}
  self522.processorMap["db_idx256_remove"] = &applyProcessorDbIdx256Remove{handler:handler}
  self522.processorMap["db_idx256_next"] = &applyProcessorDbIdx256Next{handler:handler}
  self522.processorMap["db_idx256_previous"] = &applyProcessorDbIdx256Previous{handler:handler}
  self522.processorMap["db_idx256_find_primary"] = &applyProcessorDbIdx256FindPrimary{handler:handler}
  self522.processorMap["db_idx256_find_secondary"] = &applyProcessorDbIdx256FindSecondary{handler:handler}
  self522.processorMap["db_idx256_lowerbound"] = &applyProcessorDbIdx256Lowerbound{handler:handler}
  self522.processorMap["db_idx256_upperbound"] = &applyProcessorDbIdx256Upperbound{handler:handler}
  self522.processorMap["db_idx256_end"] = &applyProcessorDbIdx256End{handler:handler}
  self522.processorMap["db_idx_double_store"] = &applyProcessorDbIdxDoubleStore{handler:handler}
  self522.processorMap["db_idx_double_update"] = &applyProcessorDbIdxDoubleUpdate{handler:handler}
  self522.processorMap["db_idx_double_remove"] = &applyProcessorDbIdxDoubleRemove{handler:handler}
  self522.processorMap["db_idx_double_next"] = &applyProcessorDbIdxDoubleNext{handler:handler}
  self522.processorMap["db_idx_double_previous"] = &applyProcessorDbIdxDoublePrevious{handler:handler}
  self522.processorMap["db_idx_double_find_primary"] = &applyProcessorDbIdxDoubleFindPrimary{handler:handler}
  self522.processorMap["db_idx_double_find_secondary"] = &applyProcessorDbIdxDoubleFindSecondary{handler:handler}
  self522.processorMap["db_idx_double_lowerbound"] = &applyProcessorDbIdxDoubleLowerbound{handler:handler}
  self522.processorMap["db_idx_double_upperbound"] = &applyProcessorDbIdxDoubleUpperbound{handler:handler}
  self522.processorMap["db_idx_double_end"] = &applyProcessorDbIdxDoubleEnd{handler:handler}
  self522.processorMap["db_idx_long_double_store"] = &applyProcessorDbIdxLongDoubleStore{handler:handler}
  self522.processorMap["db_idx_long_double_update"] = &applyProcessorDbIdxLongDoubleUpdate{handler:handler}
  self522.processorMap["db_idx_long_double_remove"] = &applyProcessorDbIdxLongDoubleRemove{handler:handler}
  self522.processorMap["db_idx_long_double_next"] = &applyProcessorDbIdxLongDoubleNext{handler:handler}
  self522.processorMap["db_idx_long_double_previous"] = &applyProcessorDbIdxLongDoublePrevious{handler:handler}
  self522.processorMap["db_idx_long_double_find_primary"] = &applyProcessorDbIdxLongDoubleFindPrimary{handler:handler}
  self522.processorMap["db_idx_long_double_find_secondary"] = &applyProcessorDbIdxLongDoubleFindSecondary{handler:handler}
  self522.processorMap["db_idx_long_double_lowerbound"] = &applyProcessorDbIdxLongDoubleLowerbound{handler:handler}
  self522.processorMap["db_idx_long_double_upperbound"] = &applyProcessorDbIdxLongDoubleUpperbound{handler:handler}
  self522.processorMap["db_idx_long_double_end"] = &applyProcessorDbIdxLongDoubleEnd{handler:handler}
return self522
}

func (p *ApplyProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x523 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x523.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x523

}

type applyProcessorEndApply struct {
  handler Apply
}

func (p *applyProcessorEndApply) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEndApplyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEndApplyResult{}
  var retval int32
  if retval, err2 = p.handler.EndApply(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing end_apply: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "end_apply", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetActiveProducers struct {
  handler Apply
}

func (p *applyProcessorGetActiveProducers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetActiveProducersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetActiveProducersResult{}
  var retval []byte
  if retval, err2 = p.handler.GetActiveProducers(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_active_producers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetResourceLimits struct {
  handler Apply
}

func (p *applyProcessorGetResourceLimits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetResourceLimitsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetResourceLimitsResult{}
  var retval *GetResourceLimitsReturn
  if retval, err2 = p.handler.GetResourceLimits(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_resource_limits: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetResourceLimits struct {
  handler Apply
}

func (p *applyProcessorSetResourceLimits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetResourceLimitsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetResourceLimitsResult{}
  if err2 = p.handler.SetResourceLimits(ctx, args.Account, args.RAMBytes, args.NetWeight, args.CPUWeight); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_resource_limits: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetProposedProducers struct {
  handler Apply
}

func (p *applyProcessorSetProposedProducers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetProposedProducersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetProposedProducersResult{}
  var retval int64
  if retval, err2 = p.handler.SetProposedProducers(ctx, args.ProducerData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_proposed_producers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetProposedProducersEx struct {
  handler Apply
}

func (p *applyProcessorSetProposedProducersEx) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetProposedProducersExArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetProposedProducersExResult{}
  var retval int64
  if retval, err2 = p.handler.SetProposedProducersEx(ctx, args.ProducerDataFormat, args.ProducerData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_proposed_producers_ex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsPrivileged struct {
  handler Apply
}

func (p *applyProcessorIsPrivileged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsPrivilegedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsPrivilegedResult{}
  var retval bool
  if retval, err2 = p.handler.IsPrivileged(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_privileged: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_privileged", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetPrivileged struct {
  handler Apply
}

func (p *applyProcessorSetPrivileged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetPrivilegedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetPrivilegedResult{}
  if err2 = p.handler.SetPrivileged(ctx, args.Account, args.IsPriv); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_privileged: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_privileged", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetBlockchainParametersPacked struct {
  handler Apply
}

func (p *applyProcessorSetBlockchainParametersPacked) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetBlockchainParametersPackedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetBlockchainParametersPackedResult{}
  if err2 = p.handler.SetBlockchainParametersPacked(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_blockchain_parameters_packed: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetBlockchainParametersPacked struct {
  handler Apply
}

func (p *applyProcessorGetBlockchainParametersPacked) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetBlockchainParametersPackedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetBlockchainParametersPackedResult{}
  var retval int32
  if retval, err2 = p.handler.GetBlockchainParametersPacked(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_blockchain_parameters_packed: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPreactivateFeature struct {
  handler Apply
}

func (p *applyProcessorPreactivateFeature) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPreactivateFeatureArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPreactivateFeatureResult{}
  if err2 = p.handler.PreactivateFeature(ctx, args.FeatureDigest); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing preactivate_feature: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCheckTransactionAuthorization struct {
  handler Apply
}

func (p *applyProcessorCheckTransactionAuthorization) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCheckTransactionAuthorizationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCheckTransactionAuthorizationResult{}
  var retval int32
  if retval, err2 = p.handler.CheckTransactionAuthorization(ctx, args.TrxData, args.PubkeysData, args.PermsData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing check_transaction_authorization: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCheckPermissionAuthorization struct {
  handler Apply
}

func (p *applyProcessorCheckPermissionAuthorization) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCheckPermissionAuthorizationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCheckPermissionAuthorizationResult{}
  var retval int32
  if retval, err2 = p.handler.CheckPermissionAuthorization(ctx, args.Account, args.Permission, args.PubkeysData, args.PermsData, args.DelayUs); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing check_permission_authorization: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetPermissionLastUsed struct {
  handler Apply
}

func (p *applyProcessorGetPermissionLastUsed) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetPermissionLastUsedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetPermissionLastUsedResult{}
  var retval int64
  if retval, err2 = p.handler.GetPermissionLastUsed(ctx, args.Account, args.Permission); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_permission_last_used: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetAccountCreationTime struct {
  handler Apply
}

func (p *applyProcessorGetAccountCreationTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetAccountCreationTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetAccountCreationTimeResult{}
  var retval int64
  if retval, err2 = p.handler.GetAccountCreationTime(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_account_creation_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrints struct {
  handler Apply
}

func (p *applyProcessorPrints) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsResult{}
  if err2 = p.handler.Prints(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsL struct {
  handler Apply
}

func (p *applyProcessorPrintsL) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsLArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsLResult{}
  if err2 = p.handler.PrintsL(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints_l: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints_l", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti struct {
  handler Apply
}

func (p *applyProcessorPrinti) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintiResult{}
  if err2 = p.handler.Printi(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui struct {
  handler Apply
}

func (p *applyProcessorPrintui) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintuiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintuiResult{}
  if err2 = p.handler.Printui(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti128 struct {
  handler Apply
}

func (p *applyProcessorPrinti128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinti128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinti128Result{}
  if err2 = p.handler.Printi128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui128 struct {
  handler Apply
}

func (p *applyProcessorPrintui128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintui128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintui128Result{}
  if err2 = p.handler.Printui128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsf struct {
  handler Apply
}

func (p *applyProcessorPrintsf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsfResult{}
  if err2 = p.handler.Printsf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printsf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printsf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintdf struct {
  handler Apply
}

func (p *applyProcessorPrintdf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintdfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintdfResult{}
  if err2 = p.handler.Printdf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printdf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printdf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintqf struct {
  handler Apply
}

func (p *applyProcessorPrintqf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintqfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintqfResult{}
  if err2 = p.handler.Printqf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printqf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printqf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintn struct {
  handler Apply
}

func (p *applyProcessorPrintn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintnArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintnResult{}
  if err2 = p.handler.Printn(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printn: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printn", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinthex struct {
  handler Apply
}

func (p *applyProcessorPrinthex) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinthexArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinthexResult{}
  if err2 = p.handler.Printhex(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printhex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printhex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorActionDataSize struct {
  handler Apply
}

func (p *applyProcessorActionDataSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyActionDataSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyActionDataSizeResult{}
  var retval int32
  if retval, err2 = p.handler.ActionDataSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing action_data_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "action_data_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadActionData struct {
  handler Apply
}

func (p *applyProcessorReadActionData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadActionDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadActionDataResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadActionData(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_action_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_action_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireRecipient struct {
  handler Apply
}

func (p *applyProcessorRequireRecipient) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireRecipientArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireRecipientResult{}
  if err2 = p.handler.RequireRecipient(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_recipient: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_recipient", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth struct {
  handler Apply
}

func (p *applyProcessorRequireAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuthResult{}
  if err2 = p.handler.RequireAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorHasAuth struct {
  handler Apply
}

func (p *applyProcessorHasAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyHasAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyHasAuthResult{}
  var retval bool
  if retval, err2 = p.handler.HasAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing has_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "has_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth2 struct {
  handler Apply
}

func (p *applyProcessorRequireAuth2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuth2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuth2Result{}
  if err2 = p.handler.RequireAuth2(ctx, args.Name, args.Permission); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsAccount struct {
  handler Apply
}

func (p *applyProcessorIsAccount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsAccountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsAccountResult{}
  var retval bool
  if retval, err2 = p.handler.IsAccount(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_account: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_account", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendInline struct {
  handler Apply
}

func (p *applyProcessorSendInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendInlineResult{}
  if err2 = p.handler.SendInline(ctx, args.SerializedAction); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendContextFreeInline struct {
  handler Apply
}

func (p *applyProcessorSendContextFreeInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendContextFreeInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendContextFreeInlineResult{}
  if err2 = p.handler.SendContextFreeInline(ctx, args.SerializedData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_context_free_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPublicationTime struct {
  handler Apply
}

func (p *applyProcessorPublicationTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPublicationTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPublicationTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.PublicationTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing publication_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "publication_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentReceiver struct {
  handler Apply
}

func (p *applyProcessorCurrentReceiver) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentReceiverArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentReceiverResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentReceiver(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_receiver: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_receiver", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssert struct {
  handler Apply
}

func (p *applyProcessorEosioAssert) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertResult{}
  if err2 = p.handler.EosioAssert(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertMessage struct {
  handler Apply
}

func (p *applyProcessorEosioAssertMessage) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertMessageArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertMessageResult{}
  if err2 = p.handler.EosioAssertMessage(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_message: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertCode struct {
  handler Apply
}

func (p *applyProcessorEosioAssertCode) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertCodeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertCodeResult{}
  if err2 = p.handler.EosioAssertCode(ctx, args.Test, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_code: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioExit struct {
  handler Apply
}

func (p *applyProcessorEosioExit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioExitArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioExitResult{}
  if err2 = p.handler.EosioExit(ctx, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_exit: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentTime struct {
  handler Apply
}

func (p *applyProcessorCurrentTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsFeatureActivated struct {
  handler Apply
}

func (p *applyProcessorIsFeatureActivated) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsFeatureActivatedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsFeatureActivatedResult{}
  var retval bool
  if retval, err2 = p.handler.IsFeatureActivated(ctx, args.FeatureDigest); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_feature_activated: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetSender struct {
  handler Apply
}

func (p *applyProcessorGetSender) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetSenderArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetSenderResult{}
  var retval *Uint64
  if retval, err2 = p.handler.GetSender(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_sender: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_sender", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha256 struct {
  handler Apply
}

func (p *applyProcessorAssertSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha256Result{}
  if err2 = p.handler.AssertSha256(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha1 struct {
  handler Apply
}

func (p *applyProcessorAssertSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha1Result{}
  if err2 = p.handler.AssertSha1(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha512 struct {
  handler Apply
}

func (p *applyProcessorAssertSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha512Result{}
  if err2 = p.handler.AssertSha512(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRipemd160 struct {
  handler Apply
}

func (p *applyProcessorAssertRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRipemd160Result{}
  if err2 = p.handler.AssertRipemd160(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha256 struct {
  handler Apply
}

func (p *applyProcessorSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha256Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha256(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha1 struct {
  handler Apply
}

func (p *applyProcessorSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha1Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha1(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha512 struct {
  handler Apply
}

func (p *applyProcessorSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha512Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha512(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRipemd160 struct {
  handler Apply
}

func (p *applyProcessorRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRipemd160Result{}
  var retval []byte
  if retval, err2 = p.handler.Ripemd160(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRecoverKey struct {
  handler Apply
}

func (p *applyProcessorRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRecoverKeyResult{}
  var retval []byte
  if retval, err2 = p.handler.RecoverKey(ctx, args.Digest, args.Sig); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRecoverKey struct {
  handler Apply
}

func (p *applyProcessorAssertRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRecoverKeyResult{}
  if err2 = p.handler.AssertRecoverKey(ctx, args.Digest, args.Sig, args.Pub); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendDeferred struct {
  handler Apply
}

func (p *applyProcessorSendDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendDeferredResult{}
  if err2 = p.handler.SendDeferred(ctx, args.SenderID, args.Payer, args.SerializedTransaction, args.ReplaceExisting); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCancelDeferred struct {
  handler Apply
}

func (p *applyProcessorCancelDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCancelDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCancelDeferredResult{}
  var retval int32
  if retval, err2 = p.handler.CancelDeferred(ctx, args.SenderID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadTransaction struct {
  handler Apply
}

func (p *applyProcessorReadTransaction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadTransactionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadTransactionResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadTransaction(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_transaction: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_transaction", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTransactionSize struct {
  handler Apply
}

func (p *applyProcessorTransactionSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTransactionSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTransactionSizeResult{}
  var retval int32
  if retval, err2 = p.handler.TransactionSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing transaction_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "transaction_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockNum struct {
  handler Apply
}

func (p *applyProcessorTaposBlockNum) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockNumArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockNumResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockNum(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_num: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockPrefix struct {
  handler Apply
}

func (p *applyProcessorTaposBlockPrefix) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockPrefixArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockPrefixResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockPrefix(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_prefix: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorExpiration struct {
  handler Apply
}

func (p *applyProcessorExpiration) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyExpirationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyExpirationResult{}
  var retval int64
  if retval, err2 = p.handler.Expiration(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expiration: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expiration", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetAction struct {
  handler Apply
}

func (p *applyProcessorGetAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetActionResult{}
  var retval []byte
  if retval, err2 = p.handler.GetAction(ctx, args._type, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetContextFreeData struct {
  handler Apply
}

func (p *applyProcessorGetContextFreeData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetContextFreeDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetContextFreeDataResult{}
  var retval []byte
  if retval, err2 = p.handler.GetContextFreeData(ctx, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_context_free_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbStoreI64 struct {
  handler Apply
}

func (p *applyProcessorDbStoreI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbStoreI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbStoreI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbStoreI64(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_store_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpdateI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpdateI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpdateI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpdateI64Result{}
  if err2 = p.handler.DbUpdateI64(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_update_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbRemoveI64 struct {
  handler Apply
}

func (p *applyProcessorDbRemoveI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbRemoveI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbRemoveI64Result{}
  if err2 = p.handler.DbRemoveI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_remove_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbGetI64 struct {
  handler Apply
}

func (p *applyProcessorDbGetI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbGetI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbGetI64Result{}
  var retval []byte
  if retval, err2 = p.handler.DbGetI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_get_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbNextI64 struct {
  handler Apply
}

func (p *applyProcessorDbNextI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbNextI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbNextI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbNextI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_next_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbPreviousI64 struct {
  handler Apply
}

func (p *applyProcessorDbPreviousI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbPreviousI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbPreviousI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbPreviousI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_previous_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbFindI64 struct {
  handler Apply
}

func (p *applyProcessorDbFindI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbFindI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbFindI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbFindI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_find_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbLowerboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbLowerboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbLowerboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbLowerboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbLowerboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_lowerbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpperboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpperboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpperboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpperboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbUpperboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_upperbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbEndI64 struct {
  handler Apply
}

func (p *applyProcessorDbEndI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbEndI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbEndI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbEndI64(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_end_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpdateResult{}
  if err2 = p.handler.DbIdx64Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64RemoveResult{}
  if err2 = p.handler.DbIdx64Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Previous(ctx, args.Iteratory); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx64FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx64FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64End struct {
  handler Apply
}

func (p *applyProcessorDbIdx64End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpdateResult{}
  if err2 = p.handler.DbIdx128Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128RemoveResult{}
  if err2 = p.handler.DbIdx128Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx128FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx128FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128End struct {
  handler Apply
}

func (p *applyProcessorDbIdx128End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpdateResult{}
  if err2 = p.handler.DbIdx256Update(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256RemoveResult{}
  if err2 = p.handler.DbIdx256Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx256FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx256FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Upperbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256End struct {
  handler Apply
}

func (p *applyProcessorDbIdx256End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpdateResult{}
  if err2 = p.handler.DbIdxDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleRemoveResult{}
  if err2 = p.handler.DbIdxDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpdateResult{}
  if err2 = p.handler.DbIdxLongDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleRemoveResult{}
  if err2 = p.handler.DbIdxLongDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ApplyEndApplyArgs struct {
}

func NewApplyEndApplyArgs() *ApplyEndApplyArgs {
  return &ApplyEndApplyArgs{}
}

func (p *ApplyEndApplyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyEndApplyResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyEndApplyResult() *ApplyEndApplyResult {
  return &ApplyEndApplyResult{}
}

var ApplyEndApplyResult_Success_DEFAULT int32
func (p *ApplyEndApplyResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyEndApplyResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyEndApplyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyEndApplyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyEndApplyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyEndApplyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyResult(%+v)", *p)
}

type ApplyGetActiveProducersArgs struct {
}

func NewApplyGetActiveProducersArgs() *ApplyGetActiveProducersArgs {
  return &ApplyGetActiveProducersArgs{}
}

func (p *ApplyGetActiveProducersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActiveProducersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_active_producers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActiveProducersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActiveProducersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetActiveProducersResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetActiveProducersResult() *ApplyGetActiveProducersResult {
  return &ApplyGetActiveProducersResult{}
}

var ApplyGetActiveProducersResult_Success_DEFAULT []byte

func (p *ApplyGetActiveProducersResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetActiveProducersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetActiveProducersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActiveProducersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetActiveProducersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_active_producers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActiveProducersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetActiveProducersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActiveProducersResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyGetResourceLimitsArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyGetResourceLimitsArgs() *ApplyGetResourceLimitsArgs {
  return &ApplyGetResourceLimitsArgs{}
}

var ApplyGetResourceLimitsArgs_Account_DEFAULT *Uint64
func (p *ApplyGetResourceLimitsArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetResourceLimitsArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyGetResourceLimitsArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetResourceLimitsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_resource_limits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetResourceLimitsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetResourceLimitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetResourceLimitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetResourceLimitsResult struct {
  Success *GetResourceLimitsReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetResourceLimitsResult() *ApplyGetResourceLimitsResult {
  return &ApplyGetResourceLimitsResult{}
}

var ApplyGetResourceLimitsResult_Success_DEFAULT *GetResourceLimitsReturn
func (p *ApplyGetResourceLimitsResult) GetSuccess() *GetResourceLimitsReturn {
  if !p.IsSetSuccess() {
    return ApplyGetResourceLimitsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyGetResourceLimitsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetResourceLimitsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &GetResourceLimitsReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_resource_limits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetResourceLimitsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetResourceLimitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetResourceLimitsResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
type ApplySetResourceLimitsArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  RAMBytes int64 `thrift:"ram_bytes,2" db:"ram_bytes" json:"ram_bytes"`
  NetWeight int64 `thrift:"net_weight,3" db:"net_weight" json:"net_weight"`
  CPUWeight int64 `thrift:"cpu_weight,4" db:"cpu_weight" json:"cpu_weight"`
}

func NewApplySetResourceLimitsArgs() *ApplySetResourceLimitsArgs {
  return &ApplySetResourceLimitsArgs{}
}

var ApplySetResourceLimitsArgs_Account_DEFAULT *Uint64
func (p *ApplySetResourceLimitsArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplySetResourceLimitsArgs_Account_DEFAULT
  }
return p.Account
}

func (p *ApplySetResourceLimitsArgs) GetRAMBytes() int64 {
  return p.RAMBytes
}

func (p *ApplySetResourceLimitsArgs) GetNetWeight() int64 {
  return p.NetWeight
}

func (p *ApplySetResourceLimitsArgs) GetCPUWeight() int64 {
  return p.CPUWeight
}
func (p *ApplySetResourceLimitsArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplySetResourceLimitsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.RAMBytes = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NetWeight = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.CPUWeight = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_resource_limits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetResourceLimitsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ram_bytes", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ram_bytes: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RAMBytes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ram_bytes (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ram_bytes: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "net_weight", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:net_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NetWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.net_weight (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:net_weight: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cpu_weight", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:cpu_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CPUWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cpu_weight (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:cpu_weight: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetResourceLimitsArgs(%+v)", *p)
}

type ApplySetResourceLimitsResult struct {
}

func NewApplySetResourceLimitsResult() *ApplySetResourceLimitsResult {
  return &ApplySetResourceLimitsResult{}
}

func (p *ApplySetResourceLimitsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_resource_limits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetResourceLimitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetResourceLimitsResult(%+v)", *p)
}

// Attributes:
//  - ProducerData
type ApplySetProposedProducersArgs struct {
  ProducerData []byte `thrift:"producer_data,1" db:"producer_data" json:"producer_data"`
}

func NewApplySetProposedProducersArgs() *ApplySetProposedProducersArgs {
  return &ApplySetProposedProducersArgs{}
}


func (p *ApplySetProposedProducersArgs) GetProducerData() []byte {
  return p.ProducerData
}
func (p *ApplySetProposedProducersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ProducerData = v
}
  return nil
}

func (p *ApplySetProposedProducersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:producer_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.ProducerData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.producer_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:producer_data: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySetProposedProducersResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySetProposedProducersResult() *ApplySetProposedProducersResult {
  return &ApplySetProposedProducersResult{}
}

var ApplySetProposedProducersResult_Success_DEFAULT int64
func (p *ApplySetProposedProducersResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplySetProposedProducersResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplySetProposedProducersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySetProposedProducersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplySetProposedProducersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySetProposedProducersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersResult(%+v)", *p)
}

// Attributes:
//  - ProducerDataFormat
//  - ProducerData
type ApplySetProposedProducersExArgs struct {
  ProducerDataFormat *Uint64 `thrift:"producer_data_format,1" db:"producer_data_format" json:"producer_data_format"`
  ProducerData *Uint64 `thrift:"producer_data,2" db:"producer_data" json:"producer_data"`
}

func NewApplySetProposedProducersExArgs() *ApplySetProposedProducersExArgs {
  return &ApplySetProposedProducersExArgs{}
}

var ApplySetProposedProducersExArgs_ProducerDataFormat_DEFAULT *Uint64
func (p *ApplySetProposedProducersExArgs) GetProducerDataFormat() *Uint64 {
  if !p.IsSetProducerDataFormat() {
    return ApplySetProposedProducersExArgs_ProducerDataFormat_DEFAULT
  }
return p.ProducerDataFormat
}
var ApplySetProposedProducersExArgs_ProducerData_DEFAULT *Uint64
func (p *ApplySetProposedProducersExArgs) GetProducerData() *Uint64 {
  if !p.IsSetProducerData() {
    return ApplySetProposedProducersExArgs_ProducerData_DEFAULT
  }
return p.ProducerData
}
func (p *ApplySetProposedProducersExArgs) IsSetProducerDataFormat() bool {
  return p.ProducerDataFormat != nil
}

func (p *ApplySetProposedProducersExArgs) IsSetProducerData() bool {
  return p.ProducerData != nil
}

func (p *ApplySetProposedProducersExArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ProducerDataFormat = &Uint64{}
  if err := p.ProducerDataFormat.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ProducerDataFormat), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.ProducerData = &Uint64{}
  if err := p.ProducerData.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ProducerData), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_ex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersExArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data_format", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:producer_data_format: ", p), err) }
  if err := p.ProducerDataFormat.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ProducerDataFormat), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:producer_data_format: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersExArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:producer_data: ", p), err) }
  if err := p.ProducerData.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ProducerData), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:producer_data: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersExArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersExArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySetProposedProducersExResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySetProposedProducersExResult() *ApplySetProposedProducersExResult {
  return &ApplySetProposedProducersExResult{}
}

var ApplySetProposedProducersExResult_Success_DEFAULT int64
func (p *ApplySetProposedProducersExResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplySetProposedProducersExResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplySetProposedProducersExResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySetProposedProducersExResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplySetProposedProducersExResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_ex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersExResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySetProposedProducersExResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersExResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyIsPrivilegedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyIsPrivilegedArgs() *ApplyIsPrivilegedArgs {
  return &ApplyIsPrivilegedArgs{}
}

var ApplyIsPrivilegedArgs_Account_DEFAULT *Uint64
func (p *ApplyIsPrivilegedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyIsPrivilegedArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyIsPrivilegedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyIsPrivilegedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_privileged_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsPrivilegedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyIsPrivilegedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsPrivilegedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsPrivilegedResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsPrivilegedResult() *ApplyIsPrivilegedResult {
  return &ApplyIsPrivilegedResult{}
}

var ApplyIsPrivilegedResult_Success_DEFAULT bool
func (p *ApplyIsPrivilegedResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsPrivilegedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsPrivilegedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsPrivilegedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsPrivilegedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_privileged_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsPrivilegedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsPrivilegedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsPrivilegedResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - IsPriv
type ApplySetPrivilegedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  IsPriv bool `thrift:"is_priv,2" db:"is_priv" json:"is_priv"`
}

func NewApplySetPrivilegedArgs() *ApplySetPrivilegedArgs {
  return &ApplySetPrivilegedArgs{}
}

var ApplySetPrivilegedArgs_Account_DEFAULT *Uint64
func (p *ApplySetPrivilegedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplySetPrivilegedArgs_Account_DEFAULT
  }
return p.Account
}

func (p *ApplySetPrivilegedArgs) GetIsPriv() bool {
  return p.IsPriv
}
func (p *ApplySetPrivilegedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplySetPrivilegedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetPrivilegedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplySetPrivilegedArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IsPriv = v
}
  return nil
}

func (p *ApplySetPrivilegedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_privileged_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetPrivilegedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplySetPrivilegedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "is_priv", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:is_priv: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IsPriv)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.is_priv (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:is_priv: ", p), err) }
  return err
}

func (p *ApplySetPrivilegedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetPrivilegedArgs(%+v)", *p)
}

type ApplySetPrivilegedResult struct {
}

func NewApplySetPrivilegedResult() *ApplySetPrivilegedResult {
  return &ApplySetPrivilegedResult{}
}

func (p *ApplySetPrivilegedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetPrivilegedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_privileged_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetPrivilegedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetPrivilegedResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySetBlockchainParametersPackedArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySetBlockchainParametersPackedArgs() *ApplySetBlockchainParametersPackedArgs {
  return &ApplySetBlockchainParametersPackedArgs{}
}


func (p *ApplySetBlockchainParametersPackedArgs) GetData() []byte {
  return p.Data
}
func (p *ApplySetBlockchainParametersPackedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_blockchain_parameters_packed_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySetBlockchainParametersPackedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetBlockchainParametersPackedArgs(%+v)", *p)
}

type ApplySetBlockchainParametersPackedResult struct {
}

func NewApplySetBlockchainParametersPackedResult() *ApplySetBlockchainParametersPackedResult {
  return &ApplySetBlockchainParametersPackedResult{}
}

func (p *ApplySetBlockchainParametersPackedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetBlockchainParametersPackedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_blockchain_parameters_packed_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetBlockchainParametersPackedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetBlockchainParametersPackedResult(%+v)", *p)
}

type ApplyGetBlockchainParametersPackedArgs struct {
}

func NewApplyGetBlockchainParametersPackedArgs() *ApplyGetBlockchainParametersPackedArgs {
  return &ApplyGetBlockchainParametersPackedArgs{}
}

func (p *ApplyGetBlockchainParametersPackedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_blockchain_parameters_packed_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockchainParametersPackedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetBlockchainParametersPackedResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetBlockchainParametersPackedResult() *ApplyGetBlockchainParametersPackedResult {
  return &ApplyGetBlockchainParametersPackedResult{}
}

var ApplyGetBlockchainParametersPackedResult_Success_DEFAULT int32
func (p *ApplyGetBlockchainParametersPackedResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyGetBlockchainParametersPackedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetBlockchainParametersPackedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetBlockchainParametersPackedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_blockchain_parameters_packed_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetBlockchainParametersPackedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockchainParametersPackedResult(%+v)", *p)
}

// Attributes:
//  - FeatureDigest
type ApplyPreactivateFeatureArgs struct {
  FeatureDigest []byte `thrift:"feature_digest,1" db:"feature_digest" json:"feature_digest"`
}

func NewApplyPreactivateFeatureArgs() *ApplyPreactivateFeatureArgs {
  return &ApplyPreactivateFeatureArgs{}
}


func (p *ApplyPreactivateFeatureArgs) GetFeatureDigest() []byte {
  return p.FeatureDigest
}
func (p *ApplyPreactivateFeatureArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPreactivateFeatureArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FeatureDigest = v
}
  return nil
}

func (p *ApplyPreactivateFeatureArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "preactivate_feature_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPreactivateFeatureArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "feature_digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature_digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.FeatureDigest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.feature_digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature_digest: ", p), err) }
  return err
}

func (p *ApplyPreactivateFeatureArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPreactivateFeatureArgs(%+v)", *p)
}

type ApplyPreactivateFeatureResult struct {
}

func NewApplyPreactivateFeatureResult() *ApplyPreactivateFeatureResult {
  return &ApplyPreactivateFeatureResult{}
}

func (p *ApplyPreactivateFeatureResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPreactivateFeatureResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "preactivate_feature_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPreactivateFeatureResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPreactivateFeatureResult(%+v)", *p)
}

// Attributes:
//  - TrxData
//  - PubkeysData
//  - PermsData
type ApplyCheckTransactionAuthorizationArgs struct {
  TrxData []byte `thrift:"trx_data,1" db:"trx_data" json:"trx_data"`
  PubkeysData []byte `thrift:"pubkeys_data,2" db:"pubkeys_data" json:"pubkeys_data"`
  PermsData []byte `thrift:"perms_data,3" db:"perms_data" json:"perms_data"`
}

func NewApplyCheckTransactionAuthorizationArgs() *ApplyCheckTransactionAuthorizationArgs {
  return &ApplyCheckTransactionAuthorizationArgs{}
}


func (p *ApplyCheckTransactionAuthorizationArgs) GetTrxData() []byte {
  return p.TrxData
}

func (p *ApplyCheckTransactionAuthorizationArgs) GetPubkeysData() []byte {
  return p.PubkeysData
}

func (p *ApplyCheckTransactionAuthorizationArgs) GetPermsData() []byte {
  return p.PermsData
}
func (p *ApplyCheckTransactionAuthorizationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TrxData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PubkeysData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PermsData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_transaction_authorization_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "trx_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:trx_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.TrxData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.trx_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:trx_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pubkeys_data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pubkeys_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PubkeysData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pubkeys_data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pubkeys_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "perms_data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:perms_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PermsData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.perms_data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:perms_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckTransactionAuthorizationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCheckTransactionAuthorizationResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCheckTransactionAuthorizationResult() *ApplyCheckTransactionAuthorizationResult {
  return &ApplyCheckTransactionAuthorizationResult{}
}

var ApplyCheckTransactionAuthorizationResult_Success_DEFAULT int32
func (p *ApplyCheckTransactionAuthorizationResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCheckTransactionAuthorizationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCheckTransactionAuthorizationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCheckTransactionAuthorizationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_transaction_authorization_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCheckTransactionAuthorizationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckTransactionAuthorizationResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - Permission
//  - PubkeysData
//  - PermsData
//  - DelayUs
type ApplyCheckPermissionAuthorizationArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
  PubkeysData []byte `thrift:"pubkeys_data,3" db:"pubkeys_data" json:"pubkeys_data"`
  PermsData []byte `thrift:"perms_data,4" db:"perms_data" json:"perms_data"`
  DelayUs *Uint64 `thrift:"delay_us,5" db:"delay_us" json:"delay_us"`
}

func NewApplyCheckPermissionAuthorizationArgs() *ApplyCheckPermissionAuthorizationArgs {
  return &ApplyCheckPermissionAuthorizationArgs{}
}

var ApplyCheckPermissionAuthorizationArgs_Account_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyCheckPermissionAuthorizationArgs_Account_DEFAULT
  }
return p.Account
}
var ApplyCheckPermissionAuthorizationArgs_Permission_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyCheckPermissionAuthorizationArgs_Permission_DEFAULT
  }
return p.Permission
}

func (p *ApplyCheckPermissionAuthorizationArgs) GetPubkeysData() []byte {
  return p.PubkeysData
}

func (p *ApplyCheckPermissionAuthorizationArgs) GetPermsData() []byte {
  return p.PermsData
}
var ApplyCheckPermissionAuthorizationArgs_DelayUs_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetDelayUs() *Uint64 {
  if !p.IsSetDelayUs() {
    return ApplyCheckPermissionAuthorizationArgs_DelayUs_DEFAULT
  }
return p.DelayUs
}
func (p *ApplyCheckPermissionAuthorizationArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) IsSetDelayUs() bool {
  return p.DelayUs != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PubkeysData = v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.PermsData = v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.DelayUs = &Uint64{}
  if err := p.DelayUs.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DelayUs), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_permission_authorization_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pubkeys_data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pubkeys_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PubkeysData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pubkeys_data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pubkeys_data: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "perms_data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:perms_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PermsData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.perms_data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:perms_data: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "delay_us", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:delay_us: ", p), err) }
  if err := p.DelayUs.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DelayUs), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:delay_us: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckPermissionAuthorizationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCheckPermissionAuthorizationResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCheckPermissionAuthorizationResult() *ApplyCheckPermissionAuthorizationResult {
  return &ApplyCheckPermissionAuthorizationResult{}
}

var ApplyCheckPermissionAuthorizationResult_Success_DEFAULT int32
func (p *ApplyCheckPermissionAuthorizationResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCheckPermissionAuthorizationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCheckPermissionAuthorizationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCheckPermissionAuthorizationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_permission_authorization_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCheckPermissionAuthorizationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckPermissionAuthorizationResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - Permission
type ApplyGetPermissionLastUsedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
}

func NewApplyGetPermissionLastUsedArgs() *ApplyGetPermissionLastUsedArgs {
  return &ApplyGetPermissionLastUsedArgs{}
}

var ApplyGetPermissionLastUsedArgs_Account_DEFAULT *Uint64
func (p *ApplyGetPermissionLastUsedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetPermissionLastUsedArgs_Account_DEFAULT
  }
return p.Account
}
var ApplyGetPermissionLastUsedArgs_Permission_DEFAULT *Uint64
func (p *ApplyGetPermissionLastUsedArgs) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyGetPermissionLastUsedArgs_Permission_DEFAULT
  }
return p.Permission
}
func (p *ApplyGetPermissionLastUsedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetPermissionLastUsedArgs) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyGetPermissionLastUsedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_permission_last_used_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetPermissionLastUsedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyGetPermissionLastUsedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetPermissionLastUsedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetPermissionLastUsedResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetPermissionLastUsedResult() *ApplyGetPermissionLastUsedResult {
  return &ApplyGetPermissionLastUsedResult{}
}

var ApplyGetPermissionLastUsedResult_Success_DEFAULT int64
func (p *ApplyGetPermissionLastUsedResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyGetPermissionLastUsedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetPermissionLastUsedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetPermissionLastUsedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetPermissionLastUsedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_permission_last_used_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetPermissionLastUsedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetPermissionLastUsedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetPermissionLastUsedResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyGetAccountCreationTimeArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyGetAccountCreationTimeArgs() *ApplyGetAccountCreationTimeArgs {
  return &ApplyGetAccountCreationTimeArgs{}
}

var ApplyGetAccountCreationTimeArgs_Account_DEFAULT *Uint64
func (p *ApplyGetAccountCreationTimeArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetAccountCreationTimeArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyGetAccountCreationTimeArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetAccountCreationTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_creation_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetAccountCreationTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetAccountCreationTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetAccountCreationTimeResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetAccountCreationTimeResult() *ApplyGetAccountCreationTimeResult {
  return &ApplyGetAccountCreationTimeResult{}
}

var ApplyGetAccountCreationTimeResult_Success_DEFAULT int64
func (p *ApplyGetAccountCreationTimeResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyGetAccountCreationTimeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetAccountCreationTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetAccountCreationTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetAccountCreationTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_creation_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetAccountCreationTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetAccountCreationTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetAccountCreationTimeResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsArgs struct {
  Cstr string `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsArgs() *ApplyPrintsArgs {
  return &ApplyPrintsArgs{}
}


func (p *ApplyPrintsArgs) GetCstr() string {
  return p.Cstr
}
func (p *ApplyPrintsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Cstr)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsArgs(%+v)", *p)
}

type ApplyPrintsResult struct {
}

func NewApplyPrintsResult() *ApplyPrintsResult {
  return &ApplyPrintsResult{}
}

func (p *ApplyPrintsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsLArgs struct {
  Cstr []byte `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsLArgs() *ApplyPrintsLArgs {
  return &ApplyPrintsLArgs{}
}


func (p *ApplyPrintsLArgs) GetCstr() []byte {
  return p.Cstr
}
func (p *ApplyPrintsLArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsLArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Cstr); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsLArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLArgs(%+v)", *p)
}

type ApplyPrintsLResult struct {
}

func NewApplyPrintsLResult() *ApplyPrintsLResult {
  return &ApplyPrintsLResult{}
}

func (p *ApplyPrintsLResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintiArgs struct {
  N int64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintiArgs() *ApplyPrintiArgs {
  return &ApplyPrintiArgs{}
}


func (p *ApplyPrintiArgs) GetN() int64 {
  return p.N
}
func (p *ApplyPrintiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.N = v
}
  return nil
}

func (p *ApplyPrintiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.N)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.n (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiArgs(%+v)", *p)
}

type ApplyPrintiResult struct {
}

func NewApplyPrintiResult() *ApplyPrintiResult {
  return &ApplyPrintiResult{}
}

func (p *ApplyPrintiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintuiArgs struct {
  N *Uint64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintuiArgs() *ApplyPrintuiArgs {
  return &ApplyPrintuiArgs{}
}

var ApplyPrintuiArgs_N_DEFAULT *Uint64
func (p *ApplyPrintuiArgs) GetN() *Uint64 {
  if !p.IsSetN() {
    return ApplyPrintuiArgs_N_DEFAULT
  }
return p.N
}
func (p *ApplyPrintuiArgs) IsSetN() bool {
  return p.N != nil
}

func (p *ApplyPrintuiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.N = &Uint64{}
  if err := p.N.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.N), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := p.N.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.N), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintuiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiArgs(%+v)", *p)
}

type ApplyPrintuiResult struct {
}

func NewApplyPrintuiResult() *ApplyPrintuiResult {
  return &ApplyPrintuiResult{}
}

func (p *ApplyPrintuiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrinti128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrinti128Args() *ApplyPrinti128Args {
  return &ApplyPrinti128Args{}
}


func (p *ApplyPrinti128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrinti128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrinti128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrinti128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Args(%+v)", *p)
}

type ApplyPrinti128Result struct {
}

func NewApplyPrinti128Result() *ApplyPrinti128Result {
  return &ApplyPrinti128Result{}
}

func (p *ApplyPrinti128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintui128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintui128Args() *ApplyPrintui128Args {
  return &ApplyPrintui128Args{}
}


func (p *ApplyPrintui128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintui128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintui128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintui128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Args(%+v)", *p)
}

type ApplyPrintui128Result struct {
}

func NewApplyPrintui128Result() *ApplyPrintui128Result {
  return &ApplyPrintui128Result{}
}

func (p *ApplyPrintui128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintsfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintsfArgs() *ApplyPrintsfArgs {
  return &ApplyPrintsfArgs{}
}


func (p *ApplyPrintsfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintsfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintsfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintsfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfArgs(%+v)", *p)
}

type ApplyPrintsfResult struct {
}

func NewApplyPrintsfResult() *ApplyPrintsfResult {
  return &ApplyPrintsfResult{}
}

func (p *ApplyPrintsfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintdfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintdfArgs() *ApplyPrintdfArgs {
  return &ApplyPrintdfArgs{}
}


func (p *ApplyPrintdfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintdfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintdfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintdfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfArgs(%+v)", *p)
}

type ApplyPrintdfResult struct {
}

func NewApplyPrintdfResult() *ApplyPrintdfResult {
  return &ApplyPrintdfResult{}
}

func (p *ApplyPrintdfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintqfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintqfArgs() *ApplyPrintqfArgs {
  return &ApplyPrintqfArgs{}
}


func (p *ApplyPrintqfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintqfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintqfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintqfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfArgs(%+v)", *p)
}

type ApplyPrintqfResult struct {
}

func NewApplyPrintqfResult() *ApplyPrintqfResult {
  return &ApplyPrintqfResult{}
}

func (p *ApplyPrintqfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyPrintnArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyPrintnArgs() *ApplyPrintnArgs {
  return &ApplyPrintnArgs{}
}

var ApplyPrintnArgs_Name_DEFAULT *Uint64
func (p *ApplyPrintnArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyPrintnArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyPrintnArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyPrintnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyPrintnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyPrintnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnArgs(%+v)", *p)
}

type ApplyPrintnResult struct {
}

func NewApplyPrintnResult() *ApplyPrintnResult {
  return &ApplyPrintnResult{}
}

func (p *ApplyPrintnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyPrinthexArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyPrinthexArgs() *ApplyPrinthexArgs {
  return &ApplyPrinthexArgs{}
}


func (p *ApplyPrinthexArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyPrinthexArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyPrinthexArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyPrinthexArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexArgs(%+v)", *p)
}

type ApplyPrinthexResult struct {
}

func NewApplyPrinthexResult() *ApplyPrinthexResult {
  return &ApplyPrinthexResult{}
}

func (p *ApplyPrinthexResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexResult(%+v)", *p)
}

type ApplyActionDataSizeArgs struct {
}

func NewApplyActionDataSizeArgs() *ApplyActionDataSizeArgs {
  return &ApplyActionDataSizeArgs{}
}

func (p *ApplyActionDataSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyActionDataSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyActionDataSizeResult() *ApplyActionDataSizeResult {
  return &ApplyActionDataSizeResult{}
}

var ApplyActionDataSizeResult_Success_DEFAULT int32
func (p *ApplyActionDataSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyActionDataSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyActionDataSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyActionDataSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyActionDataSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyActionDataSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeResult(%+v)", *p)
}

type ApplyReadActionDataArgs struct {
}

func NewApplyReadActionDataArgs() *ApplyReadActionDataArgs {
  return &ApplyReadActionDataArgs{}
}

func (p *ApplyReadActionDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadActionDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadActionDataResult() *ApplyReadActionDataResult {
  return &ApplyReadActionDataResult{}
}

var ApplyReadActionDataResult_Success_DEFAULT []byte

func (p *ApplyReadActionDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadActionDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadActionDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadActionDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadActionDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireRecipientArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireRecipientArgs() *ApplyRequireRecipientArgs {
  return &ApplyRequireRecipientArgs{}
}

var ApplyRequireRecipientArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireRecipientArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireRecipientArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireRecipientArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireRecipientArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireRecipientArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientArgs(%+v)", *p)
}

type ApplyRequireRecipientResult struct {
}

func NewApplyRequireRecipientResult() *ApplyRequireRecipientResult {
  return &ApplyRequireRecipientResult{}
}

func (p *ApplyRequireRecipientResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireAuthArgs() *ApplyRequireAuthArgs {
  return &ApplyRequireAuthArgs{}
}

var ApplyRequireAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthArgs(%+v)", *p)
}

type ApplyRequireAuthResult struct {
}

func NewApplyRequireAuthResult() *ApplyRequireAuthResult {
  return &ApplyRequireAuthResult{}
}

func (p *ApplyRequireAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyHasAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyHasAuthArgs() *ApplyHasAuthArgs {
  return &ApplyHasAuthArgs{}
}

var ApplyHasAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyHasAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyHasAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyHasAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyHasAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyHasAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyHasAuthResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyHasAuthResult() *ApplyHasAuthResult {
  return &ApplyHasAuthResult{}
}

var ApplyHasAuthResult_Success_DEFAULT bool
func (p *ApplyHasAuthResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyHasAuthResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyHasAuthResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyHasAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyHasAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyHasAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
//  - Permission
type ApplyRequireAuth2Args struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
}

func NewApplyRequireAuth2Args() *ApplyRequireAuth2Args {
  return &ApplyRequireAuth2Args{}
}

var ApplyRequireAuth2Args_Name_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuth2Args_Name_DEFAULT
  }
return p.Name
}
var ApplyRequireAuth2Args_Permission_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyRequireAuth2Args_Permission_DEFAULT
  }
return p.Permission
}
func (p *ApplyRequireAuth2Args) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuth2Args) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyRequireAuth2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Args(%+v)", *p)
}

type ApplyRequireAuth2Result struct {
}

func NewApplyRequireAuth2Result() *ApplyRequireAuth2Result {
  return &ApplyRequireAuth2Result{}
}

func (p *ApplyRequireAuth2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Result(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyIsAccountArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyIsAccountArgs() *ApplyIsAccountArgs {
  return &ApplyIsAccountArgs{}
}

var ApplyIsAccountArgs_Name_DEFAULT *Uint64
func (p *ApplyIsAccountArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyIsAccountArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyIsAccountArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyIsAccountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyIsAccountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsAccountResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsAccountResult() *ApplyIsAccountResult {
  return &ApplyIsAccountResult{}
}

var ApplyIsAccountResult_Success_DEFAULT bool
func (p *ApplyIsAccountResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsAccountResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsAccountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsAccountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsAccountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsAccountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountResult(%+v)", *p)
}

// Attributes:
//  - SerializedAction
type ApplySendInlineArgs struct {
  SerializedAction []byte `thrift:"serialized_action,1" db:"serialized_action" json:"serialized_action"`
}

func NewApplySendInlineArgs() *ApplySendInlineArgs {
  return &ApplySendInlineArgs{}
}


func (p *ApplySendInlineArgs) GetSerializedAction() []byte {
  return p.SerializedAction
}
func (p *ApplySendInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedAction = v
}
  return nil
}

func (p *ApplySendInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_action", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_action: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedAction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_action (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_action: ", p), err) }
  return err
}

func (p *ApplySendInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineArgs(%+v)", *p)
}

type ApplySendInlineResult struct {
}

func NewApplySendInlineResult() *ApplySendInlineResult {
  return &ApplySendInlineResult{}
}

func (p *ApplySendInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineResult(%+v)", *p)
}

// Attributes:
//  - SerializedData
type ApplySendContextFreeInlineArgs struct {
  SerializedData []byte `thrift:"serialized_data,1" db:"serialized_data" json:"serialized_data"`
}

func NewApplySendContextFreeInlineArgs() *ApplySendContextFreeInlineArgs {
  return &ApplySendContextFreeInlineArgs{}
}


func (p *ApplySendContextFreeInlineArgs) GetSerializedData() []byte {
  return p.SerializedData
}
func (p *ApplySendContextFreeInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedData = v
}
  return nil
}

func (p *ApplySendContextFreeInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_data: ", p), err) }
  return err
}

func (p *ApplySendContextFreeInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineArgs(%+v)", *p)
}

type ApplySendContextFreeInlineResult struct {
}

func NewApplySendContextFreeInlineResult() *ApplySendContextFreeInlineResult {
  return &ApplySendContextFreeInlineResult{}
}

func (p *ApplySendContextFreeInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineResult(%+v)", *p)
}

type ApplyPublicationTimeArgs struct {
}

func NewApplyPublicationTimeArgs() *ApplyPublicationTimeArgs {
  return &ApplyPublicationTimeArgs{}
}

func (p *ApplyPublicationTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyPublicationTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyPublicationTimeResult() *ApplyPublicationTimeResult {
  return &ApplyPublicationTimeResult{}
}

var ApplyPublicationTimeResult_Success_DEFAULT *Uint64
func (p *ApplyPublicationTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyPublicationTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyPublicationTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyPublicationTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyPublicationTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeResult(%+v)", *p)
}

type ApplyCurrentReceiverArgs struct {
}

func NewApplyCurrentReceiverArgs() *ApplyCurrentReceiverArgs {
  return &ApplyCurrentReceiverArgs{}
}

func (p *ApplyCurrentReceiverArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentReceiverResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentReceiverResult() *ApplyCurrentReceiverResult {
  return &ApplyCurrentReceiverResult{}
}

var ApplyCurrentReceiverResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentReceiverResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentReceiverResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentReceiverResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentReceiverResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentReceiverResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertArgs() *ApplyEosioAssertArgs {
  return &ApplyEosioAssertArgs{}
}


func (p *ApplyEosioAssertArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertArgs(%+v)", *p)
}

type ApplyEosioAssertResult struct {
}

func NewApplyEosioAssertResult() *ApplyEosioAssertResult {
  return &ApplyEosioAssertResult{}
}

func (p *ApplyEosioAssertResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertMessageArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertMessageArgs() *ApplyEosioAssertMessageArgs {
  return &ApplyEosioAssertMessageArgs{}
}


func (p *ApplyEosioAssertMessageArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertMessageArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertMessageArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageArgs(%+v)", *p)
}

type ApplyEosioAssertMessageResult struct {
}

func NewApplyEosioAssertMessageResult() *ApplyEosioAssertMessageResult {
  return &ApplyEosioAssertMessageResult{}
}

func (p *ApplyEosioAssertMessageResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Code
type ApplyEosioAssertCodeArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Code *Uint64 `thrift:"code,2" db:"code" json:"code"`
}

func NewApplyEosioAssertCodeArgs() *ApplyEosioAssertCodeArgs {
  return &ApplyEosioAssertCodeArgs{}
}


func (p *ApplyEosioAssertCodeArgs) GetTest() bool {
  return p.Test
}
var ApplyEosioAssertCodeArgs_Code_DEFAULT *Uint64
func (p *ApplyEosioAssertCodeArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyEosioAssertCodeArgs_Code_DEFAULT
  }
return p.Code
}
func (p *ApplyEosioAssertCodeArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyEosioAssertCodeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:code: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeArgs(%+v)", *p)
}

type ApplyEosioAssertCodeResult struct {
}

func NewApplyEosioAssertCodeResult() *ApplyEosioAssertCodeResult {
  return &ApplyEosioAssertCodeResult{}
}

func (p *ApplyEosioAssertCodeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeResult(%+v)", *p)
}

// Attributes:
//  - Code
type ApplyEosioExitArgs struct {
  Code int32 `thrift:"code,1" db:"code" json:"code"`
}

func NewApplyEosioExitArgs() *ApplyEosioExitArgs {
  return &ApplyEosioExitArgs{}
}


func (p *ApplyEosioExitArgs) GetCode() int32 {
  return p.Code
}
func (p *ApplyEosioExitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *ApplyEosioExitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyEosioExitArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitArgs(%+v)", *p)
}

type ApplyEosioExitResult struct {
}

func NewApplyEosioExitResult() *ApplyEosioExitResult {
  return &ApplyEosioExitResult{}
}

func (p *ApplyEosioExitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitResult(%+v)", *p)
}

type ApplyCurrentTimeArgs struct {
}

func NewApplyCurrentTimeArgs() *ApplyCurrentTimeArgs {
  return &ApplyCurrentTimeArgs{}
}

func (p *ApplyCurrentTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentTimeResult() *ApplyCurrentTimeResult {
  return &ApplyCurrentTimeResult{}
}

var ApplyCurrentTimeResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeResult(%+v)", *p)
}

// Attributes:
//  - FeatureDigest
type ApplyIsFeatureActivatedArgs struct {
  FeatureDigest []byte `thrift:"feature_digest,1" db:"feature_digest" json:"feature_digest"`
}

func NewApplyIsFeatureActivatedArgs() *ApplyIsFeatureActivatedArgs {
  return &ApplyIsFeatureActivatedArgs{}
}


func (p *ApplyIsFeatureActivatedArgs) GetFeatureDigest() []byte {
  return p.FeatureDigest
}
func (p *ApplyIsFeatureActivatedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FeatureDigest = v
}
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "feature_digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature_digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.FeatureDigest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.feature_digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature_digest: ", p), err) }
  return err
}

func (p *ApplyIsFeatureActivatedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsFeatureActivatedResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsFeatureActivatedResult() *ApplyIsFeatureActivatedResult {
  return &ApplyIsFeatureActivatedResult{}
}

var ApplyIsFeatureActivatedResult_Success_DEFAULT bool
func (p *ApplyIsFeatureActivatedResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsFeatureActivatedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsFeatureActivatedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsFeatureActivatedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsFeatureActivatedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsFeatureActivatedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedResult(%+v)", *p)
}

type ApplyGetSenderArgs struct {
}

func NewApplyGetSenderArgs() *ApplyGetSenderArgs {
  return &ApplyGetSenderArgs{}
}

func (p *ApplyGetSenderArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetSenderResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetSenderResult() *ApplyGetSenderResult {
  return &ApplyGetSenderResult{}
}

var ApplyGetSenderResult_Success_DEFAULT *Uint64
func (p *ApplyGetSenderResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyGetSenderResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyGetSenderResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetSenderResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyGetSenderResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetSenderResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderResult(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha256Args() *ApplyAssertSha256Args {
  return &ApplyAssertSha256Args{}
}


func (p *ApplyAssertSha256Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha256Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Args(%+v)", *p)
}

type ApplyAssertSha256Result struct {
}

func NewApplyAssertSha256Result() *ApplyAssertSha256Result {
  return &ApplyAssertSha256Result{}
}

func (p *ApplyAssertSha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha1Args() *ApplyAssertSha1Args {
  return &ApplyAssertSha1Args{}
}


func (p *ApplyAssertSha1Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha1Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Args(%+v)", *p)
}

type ApplyAssertSha1Result struct {
}

func NewApplyAssertSha1Result() *ApplyAssertSha1Result {
  return &ApplyAssertSha1Result{}
}

func (p *ApplyAssertSha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha512Args() *ApplyAssertSha512Args {
  return &ApplyAssertSha512Args{}
}


func (p *ApplyAssertSha512Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha512Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Args(%+v)", *p)
}

type ApplyAssertSha512Result struct {
}

func NewApplyAssertSha512Result() *ApplyAssertSha512Result {
  return &ApplyAssertSha512Result{}
}

func (p *ApplyAssertSha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertRipemd160Args() *ApplyAssertRipemd160Args {
  return &ApplyAssertRipemd160Args{}
}


func (p *ApplyAssertRipemd160Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertRipemd160Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Args(%+v)", *p)
}

type ApplyAssertRipemd160Result struct {
}

func NewApplyAssertRipemd160Result() *ApplyAssertRipemd160Result {
  return &ApplyAssertRipemd160Result{}
}

func (p *ApplyAssertRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha256Args() *ApplySha256Args {
  return &ApplySha256Args{}
}


func (p *ApplySha256Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha256Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha256Result() *ApplySha256Result {
  return &ApplySha256Result{}
}

var ApplySha256Result_Success_DEFAULT []byte

func (p *ApplySha256Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha256Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha1Args() *ApplySha1Args {
  return &ApplySha1Args{}
}


func (p *ApplySha1Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha1Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha1Result() *ApplySha1Result {
  return &ApplySha1Result{}
}

var ApplySha1Result_Success_DEFAULT []byte

func (p *ApplySha1Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha1Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha512Args() *ApplySha512Args {
  return &ApplySha512Args{}
}


func (p *ApplySha512Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha512Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha512Result() *ApplySha512Result {
  return &ApplySha512Result{}
}

var ApplySha512Result_Success_DEFAULT []byte

func (p *ApplySha512Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha512Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyRipemd160Args() *ApplyRipemd160Args {
  return &ApplyRipemd160Args{}
}


func (p *ApplyRipemd160Args) GetData() []byte {
  return p.Data
}
func (p *ApplyRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRipemd160Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRipemd160Result() *ApplyRipemd160Result {
  return &ApplyRipemd160Result{}
}

var ApplyRipemd160Result_Success_DEFAULT []byte

func (p *ApplyRipemd160Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRipemd160Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
type ApplyRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
}

func NewApplyRecoverKeyArgs() *ApplyRecoverKeyArgs {
  return &ApplyRecoverKeyArgs{}
}


func (p *ApplyRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}
func (p *ApplyRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRecoverKeyResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRecoverKeyResult() *ApplyRecoverKeyResult {
  return &ApplyRecoverKeyResult{}
}

var ApplyRecoverKeyResult_Success_DEFAULT []byte

func (p *ApplyRecoverKeyResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRecoverKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
//  - Pub
type ApplyAssertRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
  Pub []byte `thrift:"pub,3" db:"pub" json:"pub"`
}

func NewApplyAssertRecoverKeyArgs() *ApplyAssertRecoverKeyArgs {
  return &ApplyAssertRecoverKeyArgs{}
}


func (p *ApplyAssertRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyAssertRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}

func (p *ApplyAssertRecoverKeyArgs) GetPub() []byte {
  return p.Pub
}
func (p *ApplyAssertRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pub = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pub", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pub: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Pub); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pub (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pub: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyArgs(%+v)", *p)
}

type ApplyAssertRecoverKeyResult struct {
}

func NewApplyAssertRecoverKeyResult() *ApplyAssertRecoverKeyResult {
  return &ApplyAssertRecoverKeyResult{}
}

func (p *ApplyAssertRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
type ApplySendDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  SerializedTransaction []byte `thrift:"serialized_transaction,3" db:"serialized_transaction" json:"serialized_transaction"`
  ReplaceExisting int32 `thrift:"replace_existing,4" db:"replace_existing" json:"replace_existing"`
}

func NewApplySendDeferredArgs() *ApplySendDeferredArgs {
  return &ApplySendDeferredArgs{}
}


func (p *ApplySendDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
var ApplySendDeferredArgs_Payer_DEFAULT *Uint64
func (p *ApplySendDeferredArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplySendDeferredArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplySendDeferredArgs) GetSerializedTransaction() []byte {
  return p.SerializedTransaction
}

func (p *ApplySendDeferredArgs) GetReplaceExisting() int32 {
  return p.ReplaceExisting
}
func (p *ApplySendDeferredArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplySendDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.SerializedTransaction = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ReplaceExisting = v
}
  return nil
}

func (p *ApplySendDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_transaction", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serialized_transaction: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedTransaction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_transaction (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serialized_transaction: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "replace_existing", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:replace_existing: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ReplaceExisting)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.replace_existing (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:replace_existing: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredArgs(%+v)", *p)
}

type ApplySendDeferredResult struct {
}

func NewApplySendDeferredResult() *ApplySendDeferredResult {
  return &ApplySendDeferredResult{}
}

func (p *ApplySendDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredResult(%+v)", *p)
}

// Attributes:
//  - SenderID
type ApplyCancelDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
}

func NewApplyCancelDeferredArgs() *ApplyCancelDeferredArgs {
  return &ApplyCancelDeferredArgs{}
}


func (p *ApplyCancelDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
func (p *ApplyCancelDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplyCancelDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplyCancelDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCancelDeferredResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCancelDeferredResult() *ApplyCancelDeferredResult {
  return &ApplyCancelDeferredResult{}
}

var ApplyCancelDeferredResult_Success_DEFAULT int32
func (p *ApplyCancelDeferredResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCancelDeferredResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCancelDeferredResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCancelDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCancelDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCancelDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredResult(%+v)", *p)
}

type ApplyReadTransactionArgs struct {
}

func NewApplyReadTransactionArgs() *ApplyReadTransactionArgs {
  return &ApplyReadTransactionArgs{}
}

func (p *ApplyReadTransactionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadTransactionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadTransactionResult() *ApplyReadTransactionResult {
  return &ApplyReadTransactionResult{}
}

var ApplyReadTransactionResult_Success_DEFAULT []byte

func (p *ApplyReadTransactionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadTransactionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadTransactionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadTransactionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadTransactionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionResult(%+v)", *p)
}

type ApplyTransactionSizeArgs struct {
}

func NewApplyTransactionSizeArgs() *ApplyTransactionSizeArgs {
  return &ApplyTransactionSizeArgs{}
}

func (p *ApplyTransactionSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTransactionSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTransactionSizeResult() *ApplyTransactionSizeResult {
  return &ApplyTransactionSizeResult{}
}

var ApplyTransactionSizeResult_Success_DEFAULT int32
func (p *ApplyTransactionSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTransactionSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTransactionSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTransactionSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTransactionSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTransactionSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeResult(%+v)", *p)
}

type ApplyTaposBlockNumArgs struct {
}

func NewApplyTaposBlockNumArgs() *ApplyTaposBlockNumArgs {
  return &ApplyTaposBlockNumArgs{}
}

func (p *ApplyTaposBlockNumArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockNumResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockNumResult() *ApplyTaposBlockNumResult {
  return &ApplyTaposBlockNumResult{}
}

var ApplyTaposBlockNumResult_Success_DEFAULT int32
func (p *ApplyTaposBlockNumResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockNumResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockNumResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockNumResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockNumResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockNumResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumResult(%+v)", *p)
}

type ApplyTaposBlockPrefixArgs struct {
}

func NewApplyTaposBlockPrefixArgs() *ApplyTaposBlockPrefixArgs {
  return &ApplyTaposBlockPrefixArgs{}
}

func (p *ApplyTaposBlockPrefixArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockPrefixResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockPrefixResult() *ApplyTaposBlockPrefixResult {
  return &ApplyTaposBlockPrefixResult{}
}

var ApplyTaposBlockPrefixResult_Success_DEFAULT int32
func (p *ApplyTaposBlockPrefixResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockPrefixResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockPrefixResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockPrefixResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockPrefixResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockPrefixResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixResult(%+v)", *p)
}

type ApplyExpirationArgs struct {
}

func NewApplyExpirationArgs() *ApplyExpirationArgs {
  return &ApplyExpirationArgs{}
}

func (p *ApplyExpirationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyExpirationResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyExpirationResult() *ApplyExpirationResult {
  return &ApplyExpirationResult{}
}

var ApplyExpirationResult_Success_DEFAULT int64
func (p *ApplyExpirationResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyExpirationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyExpirationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyExpirationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyExpirationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyExpirationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationResult(%+v)", *p)
}

// Attributes:
//  - _type
//  - Index
type ApplyGetActionArgs struct {
  _type int32 `thrift:"_type,1" db:"_type" json:"_type"`
  Index int32 `thrift:"index,2" db:"index" json:"index"`
}

func NewApplyGetActionArgs() *ApplyGetActionArgs {
  return &ApplyGetActionArgs{}
}


func (p *ApplyGetActionArgs) Get_type() int32 {
  return p._type
}

func (p *ApplyGetActionArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p._type = v
}
  return nil
}

func (p *ApplyGetActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "_type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:_type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p._type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T._type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:_type: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:index: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetActionResult() *ApplyGetActionResult {
  return &ApplyGetActionResult{}
}

var ApplyGetActionResult_Success_DEFAULT []byte

func (p *ApplyGetActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionResult(%+v)", *p)
}

// Attributes:
//  - Index
type ApplyGetContextFreeDataArgs struct {
  Index int32 `thrift:"index,1" db:"index" json:"index"`
}

func NewApplyGetContextFreeDataArgs() *ApplyGetContextFreeDataArgs {
  return &ApplyGetContextFreeDataArgs{}
}


func (p *ApplyGetContextFreeDataArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetContextFreeDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetContextFreeDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:index: ", p), err) }
  return err
}

func (p *ApplyGetContextFreeDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetContextFreeDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetContextFreeDataResult() *ApplyGetContextFreeDataResult {
  return &ApplyGetContextFreeDataResult{}
}

var ApplyGetContextFreeDataResult_Success_DEFAULT []byte

func (p *ApplyGetContextFreeDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetContextFreeDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetContextFreeDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetContextFreeDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetContextFreeDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbStoreI64Args struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbStoreI64Args() *ApplyDbStoreI64Args {
  return &ApplyDbStoreI64Args{}
}

var ApplyDbStoreI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbStoreI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbStoreI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbStoreI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbStoreI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbStoreI64Args_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbStoreI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbStoreI64Args_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbStoreI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbStoreI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbStoreI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbStoreI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbStoreI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbStoreI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbStoreI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbStoreI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbStoreI64Result() *ApplyDbStoreI64Result {
  return &ApplyDbStoreI64Result{}
}

var ApplyDbStoreI64Result_Success_DEFAULT int32
func (p *ApplyDbStoreI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbStoreI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbStoreI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbStoreI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbStoreI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbStoreI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbUpdateI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbUpdateI64Args() *ApplyDbUpdateI64Args {
  return &ApplyDbUpdateI64Args{}
}


func (p *ApplyDbUpdateI64Args) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbUpdateI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbUpdateI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbUpdateI64Args_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbUpdateI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbUpdateI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbUpdateI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Args(%+v)", *p)
}

type ApplyDbUpdateI64Result struct {
}

func NewApplyDbUpdateI64Result() *ApplyDbUpdateI64Result {
  return &ApplyDbUpdateI64Result{}
}

func (p *ApplyDbUpdateI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbRemoveI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbRemoveI64Args() *ApplyDbRemoveI64Args {
  return &ApplyDbRemoveI64Args{}
}


func (p *ApplyDbRemoveI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbRemoveI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbRemoveI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbRemoveI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Args(%+v)", *p)
}

type ApplyDbRemoveI64Result struct {
}

func NewApplyDbRemoveI64Result() *ApplyDbRemoveI64Result {
  return &ApplyDbRemoveI64Result{}
}

func (p *ApplyDbRemoveI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbGetI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbGetI64Args() *ApplyDbGetI64Args {
  return &ApplyDbGetI64Args{}
}


func (p *ApplyDbGetI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbGetI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbGetI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbGetI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbGetI64Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbGetI64Result() *ApplyDbGetI64Result {
  return &ApplyDbGetI64Result{}
}

var ApplyDbGetI64Result_Success_DEFAULT []byte

func (p *ApplyDbGetI64Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyDbGetI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbGetI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyDbGetI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbGetI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbNextI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbNextI64Args() *ApplyDbNextI64Args {
  return &ApplyDbNextI64Args{}
}


func (p *ApplyDbNextI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbNextI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbNextI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbNextI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbNextI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbNextI64Result() *ApplyDbNextI64Result {
  return &ApplyDbNextI64Result{}
}

var ApplyDbNextI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbNextI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbNextI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbNextI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbNextI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbNextI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbPreviousI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbPreviousI64Args() *ApplyDbPreviousI64Args {
  return &ApplyDbPreviousI64Args{}
}


func (p *ApplyDbPreviousI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbPreviousI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbPreviousI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbPreviousI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbPreviousI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbPreviousI64Result() *ApplyDbPreviousI64Result {
  return &ApplyDbPreviousI64Result{}
}

var ApplyDbPreviousI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbPreviousI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbPreviousI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbPreviousI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbPreviousI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbPreviousI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbFindI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbFindI64Args() *ApplyDbFindI64Args {
  return &ApplyDbFindI64Args{}
}

var ApplyDbFindI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbFindI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbFindI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbFindI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbFindI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbFindI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbFindI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbFindI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbFindI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbFindI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbFindI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbFindI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbFindI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbFindI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbFindI64Result() *ApplyDbFindI64Result {
  return &ApplyDbFindI64Result{}
}

var ApplyDbFindI64Result_Success_DEFAULT int32
func (p *ApplyDbFindI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbFindI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbFindI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbFindI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbFindI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbFindI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbLowerboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbLowerboundI64Args() *ApplyDbLowerboundI64Args {
  return &ApplyDbLowerboundI64Args{}
}

var ApplyDbLowerboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbLowerboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbLowerboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbLowerboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbLowerboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbLowerboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbLowerboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbLowerboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbLowerboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbLowerboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbLowerboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbLowerboundI64Result() *ApplyDbLowerboundI64Result {
  return &ApplyDbLowerboundI64Result{}
}

var ApplyDbLowerboundI64Result_Success_DEFAULT int32
func (p *ApplyDbLowerboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbLowerboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbLowerboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbLowerboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbLowerboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbLowerboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbUpperboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbUpperboundI64Args() *ApplyDbUpperboundI64Args {
  return &ApplyDbUpperboundI64Args{}
}

var ApplyDbUpperboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbUpperboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbUpperboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbUpperboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbUpperboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbUpperboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbUpperboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbUpperboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbUpperboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbUpperboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbUpperboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbUpperboundI64Result() *ApplyDbUpperboundI64Result {
  return &ApplyDbUpperboundI64Result{}
}

var ApplyDbUpperboundI64Result_Success_DEFAULT int32
func (p *ApplyDbUpperboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbUpperboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbUpperboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbUpperboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbUpperboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbUpperboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbEndI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbEndI64Args() *ApplyDbEndI64Args {
  return &ApplyDbEndI64Args{}
}

var ApplyDbEndI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbEndI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbEndI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbEndI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbEndI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbEndI64Args_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbEndI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbEndI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbEndI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbEndI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbEndI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbEndI64Result() *ApplyDbEndI64Result {
  return &ApplyDbEndI64Result{}
}

var ApplyDbEndI64Result_Success_DEFAULT int32
func (p *ApplyDbEndI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbEndI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbEndI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbEndI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbEndI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbEndI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Result(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx64StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary *Uint64 `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64StoreArgs() *ApplyDbIdx64StoreArgs {
  return &ApplyDbIdx64StoreArgs{}
}

var ApplyDbIdx64StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx64StoreArgs_ID_DEFAULT
  }
return p.ID
}
var ApplyDbIdx64StoreArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64StoreArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64StoreResult() *ApplyDbIdx64StoreResult {
  return &ApplyDbIdx64StoreResult{}
}

var ApplyDbIdx64StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx64StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx64UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary *Uint64 `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64UpdateArgs() *ApplyDbIdx64UpdateArgs {
  return &ApplyDbIdx64UpdateArgs{}
}


func (p *ApplyDbIdx64UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx64UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64UpdateArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpdateArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64UpdateArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateArgs(%+v)", *p)
}

type ApplyDbIdx64UpdateResult struct {
}

func NewApplyDbIdx64UpdateResult() *ApplyDbIdx64UpdateResult {
  return &ApplyDbIdx64UpdateResult{}
}

func (p *ApplyDbIdx64UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64RemoveArgs() *ApplyDbIdx64RemoveArgs {
  return &ApplyDbIdx64RemoveArgs{}
}


func (p *ApplyDbIdx64RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveArgs(%+v)", *p)
}

type ApplyDbIdx64RemoveResult struct {
}

func NewApplyDbIdx64RemoveResult() *ApplyDbIdx64RemoveResult {
  return &ApplyDbIdx64RemoveResult{}
}

func (p *ApplyDbIdx64RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64NextArgs() *ApplyDbIdx64NextArgs {
  return &ApplyDbIdx64NextArgs{}
}


func (p *ApplyDbIdx64NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64NextResult() *ApplyDbIdx64NextResult {
  return &ApplyDbIdx64NextResult{}
}

var ApplyDbIdx64NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextResult(%+v)", *p)
}

// Attributes:
//  - Iteratory
type ApplyDbIdx64PreviousArgs struct {
  Iteratory int32 `thrift:"iteratory,1" db:"iteratory" json:"iteratory"`
}

func NewApplyDbIdx64PreviousArgs() *ApplyDbIdx64PreviousArgs {
  return &ApplyDbIdx64PreviousArgs{}
}


func (p *ApplyDbIdx64PreviousArgs) GetIteratory() int32 {
  return p.Iteratory
}
func (p *ApplyDbIdx64PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iteratory = v
}
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iteratory", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iteratory: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iteratory)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iteratory (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iteratory: ", p), err) }
  return err
}

func (p *ApplyDbIdx64PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64PreviousResult() *ApplyDbIdx64PreviousResult {
  return &ApplyDbIdx64PreviousResult{}
}

var ApplyDbIdx64PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx64FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx64FindPrimaryArgs() *ApplyDbIdx64FindPrimaryArgs {
  return &ApplyDbIdx64FindPrimaryArgs{}
}

var ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindPrimaryResult() *ApplyDbIdx64FindPrimaryResult {
  return &ApplyDbIdx64FindPrimaryResult{}
}

var ApplyDbIdx64FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx64FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx64FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64FindSecondaryArgs() *ApplyDbIdx64FindSecondaryArgs {
  return &ApplyDbIdx64FindSecondaryArgs{}
}

var ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindSecondaryResult() *ApplyDbIdx64FindSecondaryResult {
  return &ApplyDbIdx64FindSecondaryResult{}
}

var ApplyDbIdx64FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx64FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64LowerboundArgs() *ApplyDbIdx64LowerboundArgs {
  return &ApplyDbIdx64LowerboundArgs{}
}

var ApplyDbIdx64LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64LowerboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64LowerboundResult() *ApplyDbIdx64LowerboundResult {
  return &ApplyDbIdx64LowerboundResult{}
}

var ApplyDbIdx64LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64UpperboundArgs() *ApplyDbIdx64UpperboundArgs {
  return &ApplyDbIdx64UpperboundArgs{}
}

var ApplyDbIdx64UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64UpperboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64UpperboundResult() *ApplyDbIdx64UpperboundResult {
  return &ApplyDbIdx64UpperboundResult{}
}

var ApplyDbIdx64UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx64EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx64EndArgs() *ApplyDbIdx64EndArgs {
  return &ApplyDbIdx64EndArgs{}
}

var ApplyDbIdx64EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx64EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64EndResult() *ApplyDbIdx64EndResult {
  return &ApplyDbIdx64EndResult{}
}

var ApplyDbIdx64EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx64EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx128StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128StoreArgs() *ApplyDbIdx128StoreArgs {
  return &ApplyDbIdx128StoreArgs{}
}

var ApplyDbIdx128StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx128StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx128StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx128StoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx128StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128StoreResult() *ApplyDbIdx128StoreResult {
  return &ApplyDbIdx128StoreResult{}
}

var ApplyDbIdx128StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx128StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx128UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128UpdateArgs() *ApplyDbIdx128UpdateArgs {
  return &ApplyDbIdx128UpdateArgs{}
}


func (p *ApplyDbIdx128UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx128UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx128UpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateArgs(%+v)", *p)
}

type ApplyDbIdx128UpdateResult struct {
}

func NewApplyDbIdx128UpdateResult() *ApplyDbIdx128UpdateResult {
  return &ApplyDbIdx128UpdateResult{}
}

func (p *ApplyDbIdx128UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128RemoveArgs() *ApplyDbIdx128RemoveArgs {
  return &ApplyDbIdx128RemoveArgs{}
}


func (p *ApplyDbIdx128RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveArgs(%+v)", *p)
}

type ApplyDbIdx128RemoveResult struct {
}

func NewApplyDbIdx128RemoveResult() *ApplyDbIdx128RemoveResult {
  return &ApplyDbIdx128RemoveResult{}
}

func (p *ApplyDbIdx128RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128NextArgs() *ApplyDbIdx128NextArgs {
  return &ApplyDbIdx128NextArgs{}
}


func (p *ApplyDbIdx128NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128NextResult() *ApplyDbIdx128NextResult {
  return &ApplyDbIdx128NextResult{}
}

var ApplyDbIdx128NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128PreviousArgs() *ApplyDbIdx128PreviousArgs {
  return &ApplyDbIdx128PreviousArgs{}
}


func (p *ApplyDbIdx128PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128PreviousResult() *ApplyDbIdx128PreviousResult {
  return &ApplyDbIdx128PreviousResult{}
}

var ApplyDbIdx128PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx128FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx128FindPrimaryArgs() *ApplyDbIdx128FindPrimaryArgs {
  return &ApplyDbIdx128FindPrimaryArgs{}
}

var ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindPrimaryResult() *ApplyDbIdx128FindPrimaryResult {
  return &ApplyDbIdx128FindPrimaryResult{}
}

var ApplyDbIdx128FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx128FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx128FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128FindSecondaryArgs() *ApplyDbIdx128FindSecondaryArgs {
  return &ApplyDbIdx128FindSecondaryArgs{}
}

var ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128FindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindSecondaryResult() *ApplyDbIdx128FindSecondaryResult {
  return &ApplyDbIdx128FindSecondaryResult{}
}

var ApplyDbIdx128FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx128FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128LowerboundArgs() *ApplyDbIdx128LowerboundArgs {
  return &ApplyDbIdx128LowerboundArgs{}
}

var ApplyDbIdx128LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128LowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128LowerboundResult() *ApplyDbIdx128LowerboundResult {
  return &ApplyDbIdx128LowerboundResult{}
}

var ApplyDbIdx128LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128UpperboundArgs() *ApplyDbIdx128UpperboundArgs {
  return &ApplyDbIdx128UpperboundArgs{}
}

var ApplyDbIdx128UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128UpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128UpperboundResult() *ApplyDbIdx128UpperboundResult {
  return &ApplyDbIdx128UpperboundResult{}
}

var ApplyDbIdx128UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx128EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx128EndArgs() *ApplyDbIdx128EndArgs {
  return &ApplyDbIdx128EndArgs{}
}

var ApplyDbIdx128EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx128EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128EndResult() *ApplyDbIdx128EndResult {
  return &ApplyDbIdx128EndResult{}
}

var ApplyDbIdx128EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx128EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbIdx256StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbIdx256StoreArgs() *ApplyDbIdx256StoreArgs {
  return &ApplyDbIdx256StoreArgs{}
}

var ApplyDbIdx256StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx256StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx256StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx256StoreArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx256StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256StoreResult() *ApplyDbIdx256StoreResult {
  return &ApplyDbIdx256StoreResult{}
}

var ApplyDbIdx256StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx256StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbIdx256UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbIdx256UpdateArgs() *ApplyDbIdx256UpdateArgs {
  return &ApplyDbIdx256UpdateArgs{}
}


func (p *ApplyDbIdx256UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx256UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx256UpdateArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateArgs(%+v)", *p)
}

type ApplyDbIdx256UpdateResult struct {
}

func NewApplyDbIdx256UpdateResult() *ApplyDbIdx256UpdateResult {
  return &ApplyDbIdx256UpdateResult{}
}

func (p *ApplyDbIdx256UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256RemoveArgs() *ApplyDbIdx256RemoveArgs {
  return &ApplyDbIdx256RemoveArgs{}
}


func (p *ApplyDbIdx256RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveArgs(%+v)", *p)
}

type ApplyDbIdx256RemoveResult struct {
}

func NewApplyDbIdx256RemoveResult() *ApplyDbIdx256RemoveResult {
  return &ApplyDbIdx256RemoveResult{}
}

func (p *ApplyDbIdx256RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256NextArgs() *ApplyDbIdx256NextArgs {
  return &ApplyDbIdx256NextArgs{}
}


func (p *ApplyDbIdx256NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256NextResult() *ApplyDbIdx256NextResult {
  return &ApplyDbIdx256NextResult{}
}

var ApplyDbIdx256NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256PreviousArgs() *ApplyDbIdx256PreviousArgs {
  return &ApplyDbIdx256PreviousArgs{}
}


func (p *ApplyDbIdx256PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256PreviousResult() *ApplyDbIdx256PreviousResult {
  return &ApplyDbIdx256PreviousResult{}
}

var ApplyDbIdx256PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx256FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx256FindPrimaryArgs() *ApplyDbIdx256FindPrimaryArgs {
  return &ApplyDbIdx256FindPrimaryArgs{}
}

var ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindPrimaryResult() *ApplyDbIdx256FindPrimaryResult {
  return &ApplyDbIdx256FindPrimaryResult{}
}

var ApplyDbIdx256FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx256FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
type ApplyDbIdx256FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
}

func NewApplyDbIdx256FindSecondaryArgs() *ApplyDbIdx256FindSecondaryArgs {
  return &ApplyDbIdx256FindSecondaryArgs{}
}

var ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256FindSecondaryArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindSecondaryResult() *ApplyDbIdx256FindSecondaryResult {
  return &ApplyDbIdx256FindSecondaryResult{}
}

var ApplyDbIdx256FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx256FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256LowerboundArgs() *ApplyDbIdx256LowerboundArgs {
  return &ApplyDbIdx256LowerboundArgs{}
}

var ApplyDbIdx256LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256LowerboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256LowerboundResult() *ApplyDbIdx256LowerboundResult {
  return &ApplyDbIdx256LowerboundResult{}
}

var ApplyDbIdx256LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256UpperboundArgs() *ApplyDbIdx256UpperboundArgs {
  return &ApplyDbIdx256UpperboundArgs{}
}

var ApplyDbIdx256UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256UpperboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256UpperboundResult() *ApplyDbIdx256UpperboundResult {
  return &ApplyDbIdx256UpperboundResult{}
}

var ApplyDbIdx256UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx256EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx256EndArgs() *ApplyDbIdx256EndArgs {
  return &ApplyDbIdx256EndArgs{}
}

var ApplyDbIdx256EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx256EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256EndResult() *ApplyDbIdx256EndResult {
  return &ApplyDbIdx256EndResult{}
}

var ApplyDbIdx256EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx256EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleStoreArgs() *ApplyDbIdxDoubleStoreArgs {
  return &ApplyDbIdxDoubleStoreArgs{}
}

var ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleStoreResult() *ApplyDbIdxDoubleStoreResult {
  return &ApplyDbIdxDoubleStoreResult{}
}

var ApplyDbIdxDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleUpdateArgs() *ApplyDbIdxDoubleUpdateArgs {
  return &ApplyDbIdxDoubleUpdateArgs{}
}


func (p *ApplyDbIdxDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxDoubleUpdateResult struct {
}

func NewApplyDbIdxDoubleUpdateResult() *ApplyDbIdxDoubleUpdateResult {
  return &ApplyDbIdxDoubleUpdateResult{}
}

func (p *ApplyDbIdxDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleRemoveArgs() *ApplyDbIdxDoubleRemoveArgs {
  return &ApplyDbIdxDoubleRemoveArgs{}
}


func (p *ApplyDbIdxDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxDoubleRemoveResult struct {
}

func NewApplyDbIdxDoubleRemoveResult() *ApplyDbIdxDoubleRemoveResult {
  return &ApplyDbIdxDoubleRemoveResult{}
}

func (p *ApplyDbIdxDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleNextArgs() *ApplyDbIdxDoubleNextArgs {
  return &ApplyDbIdxDoubleNextArgs{}
}


func (p *ApplyDbIdxDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleNextResult() *ApplyDbIdxDoubleNextResult {
  return &ApplyDbIdxDoubleNextResult{}
}

var ApplyDbIdxDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoublePreviousArgs() *ApplyDbIdxDoublePreviousArgs {
  return &ApplyDbIdxDoublePreviousArgs{}
}


func (p *ApplyDbIdxDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoublePreviousResult() *ApplyDbIdxDoublePreviousResult {
  return &ApplyDbIdxDoublePreviousResult{}
}

var ApplyDbIdxDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleFindPrimaryArgs() *ApplyDbIdxDoubleFindPrimaryArgs {
  return &ApplyDbIdxDoubleFindPrimaryArgs{}
}

var ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindPrimaryResult() *ApplyDbIdxDoubleFindPrimaryResult {
  return &ApplyDbIdxDoubleFindPrimaryResult{}
}

var ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleFindSecondaryArgs() *ApplyDbIdxDoubleFindSecondaryArgs {
  return &ApplyDbIdxDoubleFindSecondaryArgs{}
}

var ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindSecondaryResult() *ApplyDbIdxDoubleFindSecondaryResult {
  return &ApplyDbIdxDoubleFindSecondaryResult{}
}

var ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleLowerboundArgs() *ApplyDbIdxDoubleLowerboundArgs {
  return &ApplyDbIdxDoubleLowerboundArgs{}
}

var ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleLowerboundResult() *ApplyDbIdxDoubleLowerboundResult {
  return &ApplyDbIdxDoubleLowerboundResult{}
}

var ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleUpperboundArgs() *ApplyDbIdxDoubleUpperboundArgs {
  return &ApplyDbIdxDoubleUpperboundArgs{}
}

var ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleUpperboundResult() *ApplyDbIdxDoubleUpperboundResult {
  return &ApplyDbIdxDoubleUpperboundResult{}
}

var ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxDoubleEndArgs() *ApplyDbIdxDoubleEndArgs {
  return &ApplyDbIdxDoubleEndArgs{}
}

var ApplyDbIdxDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleEndResult() *ApplyDbIdxDoubleEndResult {
  return &ApplyDbIdxDoubleEndResult{}
}

var ApplyDbIdxDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxLongDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleStoreArgs() *ApplyDbIdxLongDoubleStoreArgs {
  return &ApplyDbIdxLongDoubleStoreArgs{}
}

var ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxLongDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleStoreResult() *ApplyDbIdxLongDoubleStoreResult {
  return &ApplyDbIdxLongDoubleStoreResult{}
}

var ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxLongDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleUpdateArgs() *ApplyDbIdxLongDoubleUpdateArgs {
  return &ApplyDbIdxLongDoubleUpdateArgs{}
}


func (p *ApplyDbIdxLongDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleUpdateResult struct {
}

func NewApplyDbIdxLongDoubleUpdateResult() *ApplyDbIdxLongDoubleUpdateResult {
  return &ApplyDbIdxLongDoubleUpdateResult{}
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleRemoveArgs() *ApplyDbIdxLongDoubleRemoveArgs {
  return &ApplyDbIdxLongDoubleRemoveArgs{}
}


func (p *ApplyDbIdxLongDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleRemoveResult struct {
}

func NewApplyDbIdxLongDoubleRemoveResult() *ApplyDbIdxLongDoubleRemoveResult {
  return &ApplyDbIdxLongDoubleRemoveResult{}
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleNextArgs() *ApplyDbIdxLongDoubleNextArgs {
  return &ApplyDbIdxLongDoubleNextArgs{}
}


func (p *ApplyDbIdxLongDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleNextResult() *ApplyDbIdxLongDoubleNextResult {
  return &ApplyDbIdxLongDoubleNextResult{}
}

var ApplyDbIdxLongDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoublePreviousArgs() *ApplyDbIdxLongDoublePreviousArgs {
  return &ApplyDbIdxLongDoublePreviousArgs{}
}


func (p *ApplyDbIdxLongDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoublePreviousResult() *ApplyDbIdxLongDoublePreviousResult {
  return &ApplyDbIdxLongDoublePreviousResult{}
}

var ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxLongDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleFindPrimaryArgs() *ApplyDbIdxLongDoubleFindPrimaryArgs {
  return &ApplyDbIdxLongDoubleFindPrimaryArgs{}
}

var ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindPrimaryResult() *ApplyDbIdxLongDoubleFindPrimaryResult {
  return &ApplyDbIdxLongDoubleFindPrimaryResult{}
}

var ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxLongDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleFindSecondaryArgs() *ApplyDbIdxLongDoubleFindSecondaryArgs {
  return &ApplyDbIdxLongDoubleFindSecondaryArgs{}
}

var ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindSecondaryResult() *ApplyDbIdxLongDoubleFindSecondaryResult {
  return &ApplyDbIdxLongDoubleFindSecondaryResult{}
}

var ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleLowerboundArgs() *ApplyDbIdxLongDoubleLowerboundArgs {
  return &ApplyDbIdxLongDoubleLowerboundArgs{}
}

var ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleLowerboundResult() *ApplyDbIdxLongDoubleLowerboundResult {
  return &ApplyDbIdxLongDoubleLowerboundResult{}
}

var ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleUpperboundArgs() *ApplyDbIdxLongDoubleUpperboundArgs {
  return &ApplyDbIdxLongDoubleUpperboundArgs{}
}

var ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleUpperboundResult() *ApplyDbIdxLongDoubleUpperboundResult {
  return &ApplyDbIdxLongDoubleUpperboundResult{}
}

var ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxLongDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxLongDoubleEndArgs() *ApplyDbIdxLongDoubleEndArgs {
  return &ApplyDbIdxLongDoubleEndArgs{}
}

var ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxLongDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleEndResult() *ApplyDbIdxLongDoubleEndResult {
  return &ApplyDbIdxLongDoubleEndResult{}
}

var ApplyDbIdxLongDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndResult(%+v)", *p)
}


