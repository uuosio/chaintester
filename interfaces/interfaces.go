// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package interfaces

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// Attributes:
//  - Exc
type TransactionException struct {
  Exc string `thrift:"exc,1" db:"exc" json:"exc"`
}

func NewTransactionException() *TransactionException {
  return &TransactionException{}
}


func (p *TransactionException) GetExc() string {
  return p.Exc
}
func (p *TransactionException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TransactionException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Exc = v
}
  return nil
}

func (p *TransactionException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TransactionException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TransactionException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "exc", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:exc: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Exc)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.exc (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:exc: ", p), err) }
  return err
}

func (p *TransactionException) Equals(other *TransactionException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Exc != other.Exc { return false }
  return true
}

func (p *TransactionException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TransactionException(%+v)", *p)
}

func (p *TransactionException) Error() string {
  return p.String()
}

func (TransactionException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TransactionException)(nil)

// Attributes:
//  - ErrorMessage
type AssertException struct {
  ErrorMessage string `thrift:"error_message,1" db:"error_message" json:"error_message"`
}

func NewAssertException() *AssertException {
  return &AssertException{}
}


func (p *AssertException) GetErrorMessage() string {
  return p.ErrorMessage
}
func (p *AssertException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AssertException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ErrorMessage = v
}
  return nil
}

func (p *AssertException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AssertException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AssertException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "error_message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:error_message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ErrorMessage)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.error_message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:error_message: ", p), err) }
  return err
}

func (p *AssertException) Equals(other *AssertException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ErrorMessage != other.ErrorMessage { return false }
  return true
}

func (p *AssertException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AssertException(%+v)", *p)
}

func (p *AssertException) Error() string {
  return p.String()
}

func (AssertException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*AssertException)(nil)

// Attributes:
//  - RawArgs_
//  - JSONArgs_
type ActionArguments struct {
  RawArgs_ []byte `thrift:"raw_args,1" db:"raw_args" json:"raw_args,omitempty"`
  JSONArgs_ *string `thrift:"json_args,2" db:"json_args" json:"json_args,omitempty"`
}

func NewActionArguments() *ActionArguments {
  return &ActionArguments{}
}

var ActionArguments_RawArgs__DEFAULT []byte

func (p *ActionArguments) GetRawArgs_() []byte {
  return p.RawArgs_
}
var ActionArguments_JSONArgs__DEFAULT string
func (p *ActionArguments) GetJSONArgs_() string {
  if !p.IsSetJSONArgs_() {
    return ActionArguments_JSONArgs__DEFAULT
  }
return *p.JSONArgs_
}
func (p *ActionArguments) CountSetFieldsActionArguments() int {
  count := 0
  if (p.IsSetRawArgs_()) {
    count++
  }
  if (p.IsSetJSONArgs_()) {
    count++
  }
  return count

}

func (p *ActionArguments) IsSetRawArgs_() bool {
  return p.RawArgs_ != nil
}

func (p *ActionArguments) IsSetJSONArgs_() bool {
  return p.JSONArgs_ != nil
}

func (p *ActionArguments) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ActionArguments)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RawArgs_ = v
}
  return nil
}

func (p *ActionArguments)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.JSONArgs_ = &v
}
  return nil
}

func (p *ActionArguments) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsActionArguments(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "ActionArguments"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ActionArguments) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRawArgs_() {
    if err := oprot.WriteFieldBegin(ctx, "raw_args", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:raw_args: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.RawArgs_); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.raw_args (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:raw_args: ", p), err) }
  }
  return err
}

func (p *ActionArguments) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJSONArgs_() {
    if err := oprot.WriteFieldBegin(ctx, "json_args", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:json_args: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.JSONArgs_)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.json_args (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:json_args: ", p), err) }
  }
  return err
}

func (p *ActionArguments) Equals(other *ActionArguments) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.RawArgs_, other.RawArgs_) != 0 { return false }
  if p.JSONArgs_ != other.JSONArgs_ {
    if p.JSONArgs_ == nil || other.JSONArgs_ == nil {
      return false
    }
    if (*p.JSONArgs_) != (*other.JSONArgs_) { return false }
  }
  return true
}

func (p *ActionArguments) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ActionArguments(%+v)", *p)
}

// Attributes:
//  - Account
//  - Action
//  - Permissions
//  - Arguments
type Action struct {
  Account string `thrift:"account,1" db:"account" json:"account"`
  Action string `thrift:"action,2" db:"action" json:"action"`
  Permissions string `thrift:"permissions,3" db:"permissions" json:"permissions"`
  Arguments *ActionArguments `thrift:"arguments,4" db:"arguments" json:"arguments"`
}

func NewAction() *Action {
  return &Action{}
}


func (p *Action) GetAccount() string {
  return p.Account
}

func (p *Action) GetAction() string {
  return p.Action
}

func (p *Action) GetPermissions() string {
  return p.Permissions
}
var Action_Arguments_DEFAULT *ActionArguments
func (p *Action) GetArguments() *ActionArguments {
  if !p.IsSetArguments() {
    return Action_Arguments_DEFAULT
  }
return p.Arguments
}
func (p *Action) IsSetArguments() bool {
  return p.Arguments != nil
}

func (p *Action) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Action)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *Action)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *Action)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *Action)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Arguments = &ActionArguments{}
  if err := p.Arguments.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Arguments), err)
  }
  return nil
}

func (p *Action) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Action"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Action) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *Action) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:action: ", p), err) }
  return err
}

func (p *Action) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:permissions: ", p), err) }
  return err
}

func (p *Action) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := p.Arguments.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Arguments), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *Action) Equals(other *Action) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Account != other.Account { return false }
  if p.Action != other.Action { return false }
  if p.Permissions != other.Permissions { return false }
  if !p.Arguments.Equals(other.Arguments) { return false }
  return true
}

func (p *Action) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Action(%+v)", *p)
}

// Attributes:
//  - RawValue
type Uint64 struct {
  RawValue []byte `thrift:"rawValue,1" db:"rawValue" json:"rawValue"`
}

func NewUint64() *Uint64 {
  return &Uint64{}
}


func (p *Uint64) GetRawValue() []byte {
  return p.RawValue
}
func (p *Uint64) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Uint64)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RawValue = v
}
  return nil
}

func (p *Uint64) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Uint64"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Uint64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rawValue", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rawValue: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawValue); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rawValue (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rawValue: ", p), err) }
  return err
}

func (p *Uint64) Equals(other *Uint64) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.RawValue, other.RawValue) != 0 { return false }
  return true
}

func (p *Uint64) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Uint64(%+v)", *p)
}

// Attributes:
//  - Size
//  - Buffer
type DataBuffer struct {
  Size int32 `thrift:"size,1" db:"size" json:"size"`
  Buffer []byte `thrift:"buffer,2" db:"buffer" json:"buffer"`
}

func NewDataBuffer() *DataBuffer {
  return &DataBuffer{}
}


func (p *DataBuffer) GetSize() int32 {
  return p.Size
}

func (p *DataBuffer) GetBuffer() []byte {
  return p.Buffer
}
func (p *DataBuffer) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DataBuffer)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Size = v
}
  return nil
}

func (p *DataBuffer)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Buffer = v
}
  return nil
}

func (p *DataBuffer) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DataBuffer"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DataBuffer) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "size", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:size: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Size)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.size (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:size: ", p), err) }
  return err
}

func (p *DataBuffer) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "buffer", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:buffer: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Buffer); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.buffer (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:buffer: ", p), err) }
  return err
}

func (p *DataBuffer) Equals(other *DataBuffer) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Size != other.Size { return false }
  if bytes.Compare(p.Buffer, other.Buffer) != 0 { return false }
  return true
}

func (p *DataBuffer) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DataBuffer(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type NextPreviousReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewNextPreviousReturn() *NextPreviousReturn {
  return &NextPreviousReturn{}
}


func (p *NextPreviousReturn) GetIterator() int32 {
  return p.Iterator
}
var NextPreviousReturn_Primary_DEFAULT *Uint64
func (p *NextPreviousReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return NextPreviousReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *NextPreviousReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *NextPreviousReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NextPreviousReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *NextPreviousReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *NextPreviousReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NextPreviousReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NextPreviousReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *NextPreviousReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *NextPreviousReturn) Equals(other *NextPreviousReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *NextPreviousReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NextPreviousReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type IteratorPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewIteratorPrimaryReturn() *IteratorPrimaryReturn {
  return &IteratorPrimaryReturn{}
}


func (p *IteratorPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}
var IteratorPrimaryReturn_Primary_DEFAULT *Uint64
func (p *IteratorPrimaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return IteratorPrimaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *IteratorPrimaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *IteratorPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "IteratorPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IteratorPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) Equals(other *IteratorPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *IteratorPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IteratorPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
type FindPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
}

func NewFindPrimaryReturn() *FindPrimaryReturn {
  return &FindPrimaryReturn{}
}


func (p *FindPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *FindPrimaryReturn) GetSecondary() []byte {
  return p.Secondary
}
func (p *FindPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *FindPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) Equals(other *FindPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  return true
}

func (p *FindPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type FindSecondaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewFindSecondaryReturn() *FindSecondaryReturn {
  return &FindSecondaryReturn{}
}


func (p *FindSecondaryReturn) GetIterator() int32 {
  return p.Iterator
}
var FindSecondaryReturn_Primary_DEFAULT *Uint64
func (p *FindSecondaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return FindSecondaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *FindSecondaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *FindSecondaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindSecondaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindSecondaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *FindSecondaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindSecondaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindSecondaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) Equals(other *FindSecondaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *FindSecondaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindSecondaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
//  - Primary
type LowerBoundUpperBoundReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,3" db:"primary" json:"primary"`
}

func NewLowerBoundUpperBoundReturn() *LowerBoundUpperBoundReturn {
  return &LowerBoundUpperBoundReturn{}
}


func (p *LowerBoundUpperBoundReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *LowerBoundUpperBoundReturn) GetSecondary() []byte {
  return p.Secondary
}
var LowerBoundUpperBoundReturn_Primary_DEFAULT *Uint64
func (p *LowerBoundUpperBoundReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return LowerBoundUpperBoundReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *LowerBoundUpperBoundReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *LowerBoundUpperBoundReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LowerBoundUpperBoundReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LowerBoundUpperBoundReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:primary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) Equals(other *LowerBoundUpperBoundReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *LowerBoundUpperBoundReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LowerBoundUpperBoundReturn(%+v)", *p)
}

// Attributes:
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
type GetResourceLimitsReturn struct {
  RAMBytes int64 `thrift:"ram_bytes,1" db:"ram_bytes" json:"ram_bytes"`
  NetWeight int64 `thrift:"net_weight,2" db:"net_weight" json:"net_weight"`
  CPUWeight int64 `thrift:"cpu_weight,3" db:"cpu_weight" json:"cpu_weight"`
}

func NewGetResourceLimitsReturn() *GetResourceLimitsReturn {
  return &GetResourceLimitsReturn{}
}


func (p *GetResourceLimitsReturn) GetRAMBytes() int64 {
  return p.RAMBytes
}

func (p *GetResourceLimitsReturn) GetNetWeight() int64 {
  return p.NetWeight
}

func (p *GetResourceLimitsReturn) GetCPUWeight() int64 {
  return p.CPUWeight
}
func (p *GetResourceLimitsReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RAMBytes = v
}
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NetWeight = v
}
  return nil
}

func (p *GetResourceLimitsReturn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.CPUWeight = v
}
  return nil
}

func (p *GetResourceLimitsReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetResourceLimitsReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetResourceLimitsReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ram_bytes", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ram_bytes: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RAMBytes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ram_bytes (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ram_bytes: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "net_weight", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:net_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NetWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.net_weight (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:net_weight: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cpu_weight", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:cpu_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CPUWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cpu_weight (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:cpu_weight: ", p), err) }
  return err
}

func (p *GetResourceLimitsReturn) Equals(other *GetResourceLimitsReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.RAMBytes != other.RAMBytes { return false }
  if p.NetWeight != other.NetWeight { return false }
  if p.CPUWeight != other.CPUWeight { return false }
  return true
}

func (p *GetResourceLimitsReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetResourceLimitsReturn(%+v)", *p)
}

type IPCChainTester interface {
  InitVMAPI(ctx context.Context) (_err error)
  InitApplyRequest(ctx context.Context) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Dylib
  SetNativeContract(ctx context.Context, id int32, contract string, dylib string) (_r bool, _err error)
  // Parameters:
  //  - Enable
  EnableDebugging(ctx context.Context, enable bool) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Enable
  EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error)
  // Parameters:
  //  - Abi
  PackAbi(ctx context.Context, abi string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - ActionArgs_
  PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - RawArgs_
  UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error)
  // Parameters:
  //  - Initialize
  NewChain_(ctx context.Context, initialize bool) (_r int32, _err error)
  // Parameters:
  //  - ID
  FreeChain(ctx context.Context, id int32) (_r int32, _err error)
  // Parameters:
  //  - ID
  GetInfo(ctx context.Context, id int32) (_r string, _err error)
  // Parameters:
  //  - KeyType
  CreateKey(ctx context.Context, key_type string) (_r string, _err error)
  // Parameters:
  //  - ID
  //  - Account
  GetAccount(ctx context.Context, id int32, account string) (_r string, _err error)
  // Parameters:
  //  - ID
  //  - Creator
  //  - Account
  //  - OwnerKey
  //  - ActiveKey
  //  - RAMBytes
  //  - StakeNet
  //  - StakeCPU
  CreateAccount(ctx context.Context, id int32, creator string, account string, owner_key string, active_key string, ram_bytes int64, stake_net int64, stake_cpu int64) (_r string, _err error)
  // Parameters:
  //  - ID
  //  - PubKey
  //  - PrivKey
  ImportKey(ctx context.Context, id int32, pub_key string, priv_key string) (_r bool, _err error)
  // Parameters:
  //  - ID
  //  - Transaction
  //  - AvailableKeys
  GetRequiredKeys(ctx context.Context, id int32, transaction string, available_keys []string) (_r string, _err error)
  // Parameters:
  //  - ID
  //  - NextBlockSkipSeconds
  ProduceBlock(ctx context.Context, id int32, next_block_skip_seconds int64) (_err error)
  // Parameters:
  //  - ID
  //  - Account
  //  - Action
  //  - Arguments
  //  - Permissions
  PushAction(ctx context.Context, id int32, account string, action string, arguments *ActionArguments, permissions string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Actions
  PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Account
  //  - Wasm
  //  - Abi
  DeployContract(ctx context.Context, id int32, account string, wasm string, abi string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - JSON
  //  - Code
  //  - Scope
  //  - Table
  //  - LowerBound
  //  - UpperBound
  //  - Limit
  //  - KeyType
  //  - IndexPosition
  //  - Reverse
  //  - ShowPayer
  GetTableRows(ctx context.Context, id int32, json bool, code string, scope string, table string, lower_bound string, upper_bound string, limit int64, key_type string, index_position string, reverse bool, show_payer bool) (_r string, _err error)
}

type IPCChainTesterClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewIPCChainTesterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewIPCChainTesterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewIPCChainTesterClient(c thrift.TClient) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: c,
  }
}

func (p *IPCChainTesterClient) Client_() thrift.TClient {
  return p.c
}

func (p *IPCChainTesterClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *IPCChainTesterClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *IPCChainTesterClient) InitVMAPI(ctx context.Context) (_err error) {
  var _args0 IPCChainTesterInitVMAPIArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_vm_api", &_args0, nil); err != nil {
    return err
  }
  return nil
}

func (p *IPCChainTesterClient) InitApplyRequest(ctx context.Context) (_err error) {
  var _args1 IPCChainTesterInitApplyRequestArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_apply_request", &_args1, nil); err != nil {
    return err
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
//  - Dylib
func (p *IPCChainTesterClient) SetNativeContract(ctx context.Context, id int32, contract string, dylib string) (_r bool, _err error) {
  var _args2 IPCChainTesterSetNativeContractArgs
  _args2.ID = id
  _args2.Contract = contract
  _args2.Dylib = dylib
  var _result4 IPCChainTesterSetNativeContractResult
  var _meta3 thrift.ResponseMeta
  _meta3, _err = p.Client_().Call(ctx, "set_native_contract", &_args2, &_result4)
  p.SetLastResponseMeta_(_meta3)
  if _err != nil {
    return
  }
  return _result4.GetSuccess(), nil
}

// Parameters:
//  - Enable
func (p *IPCChainTesterClient) EnableDebugging(ctx context.Context, enable bool) (_err error) {
  var _args5 IPCChainTesterEnableDebuggingArgs
  _args5.Enable = enable
  var _result7 IPCChainTesterEnableDebuggingResult
  var _meta6 thrift.ResponseMeta
  _meta6, _err = p.Client_().Call(ctx, "enable_debugging", &_args5, &_result7)
  p.SetLastResponseMeta_(_meta6)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
//  - Enable
func (p *IPCChainTesterClient) EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error) {
  var _args8 IPCChainTesterEnableDebugContractArgs
  _args8.ID = id
  _args8.Contract = contract
  _args8.Enable = enable
  var _result10 IPCChainTesterEnableDebugContractResult
  var _meta9 thrift.ResponseMeta
  _meta9, _err = p.Client_().Call(ctx, "enable_debug_contract", &_args8, &_result10)
  p.SetLastResponseMeta_(_meta9)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
func (p *IPCChainTesterClient) IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error) {
  var _args11 IPCChainTesterIsDebugContractEnabledArgs
  _args11.ID = id
  _args11.Contract = contract
  var _result13 IPCChainTesterIsDebugContractEnabledResult
  var _meta12 thrift.ResponseMeta
  _meta12, _err = p.Client_().Call(ctx, "is_debug_contract_enabled", &_args11, &_result13)
  p.SetLastResponseMeta_(_meta12)
  if _err != nil {
    return
  }
  return _result13.GetSuccess(), nil
}

// Parameters:
//  - Abi
func (p *IPCChainTesterClient) PackAbi(ctx context.Context, abi string) (_r []byte, _err error) {
  var _args14 IPCChainTesterPackAbiArgs
  _args14.Abi = abi
  var _result16 IPCChainTesterPackAbiResult
  var _meta15 thrift.ResponseMeta
  _meta15, _err = p.Client_().Call(ctx, "pack_abi", &_args14, &_result16)
  p.SetLastResponseMeta_(_meta15)
  if _err != nil {
    return
  }
  return _result16.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
func (p *IPCChainTesterClient) PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error) {
  var _args17 IPCChainTesterPackActionArgsArgs
  _args17.ID = id
  _args17.Contract = contract
  _args17.Action = action
  _args17.ActionArgs_ = action_args
  var _result19 IPCChainTesterPackActionArgsResult
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "pack_action_args", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  return _result19.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
func (p *IPCChainTesterClient) UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error) {
  var _args20 IPCChainTesterUnpackActionArgsArgs
  _args20.ID = id
  _args20.Contract = contract
  _args20.Action = action
  _args20.RawArgs_ = raw_args
  var _result22 IPCChainTesterUnpackActionArgsResult
  var _meta21 thrift.ResponseMeta
  _meta21, _err = p.Client_().Call(ctx, "unpack_action_args", &_args20, &_result22)
  p.SetLastResponseMeta_(_meta21)
  if _err != nil {
    return
  }
  return _result22.GetSuccess(), nil
}

// Parameters:
//  - Initialize
func (p *IPCChainTesterClient) NewChain_(ctx context.Context, initialize bool) (_r int32, _err error) {
  var _args23 IPCChainTesterNewChainArgs_
  _args23.Initialize = initialize
  var _result25 IPCChainTesterNewChainResult_
  var _meta24 thrift.ResponseMeta
  _meta24, _err = p.Client_().Call(ctx, "new_chain", &_args23, &_result25)
  p.SetLastResponseMeta_(_meta24)
  if _err != nil {
    return
  }
  return _result25.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) FreeChain(ctx context.Context, id int32) (_r int32, _err error) {
  var _args26 IPCChainTesterFreeChainArgs
  _args26.ID = id
  var _result28 IPCChainTesterFreeChainResult
  var _meta27 thrift.ResponseMeta
  _meta27, _err = p.Client_().Call(ctx, "free_chain", &_args26, &_result28)
  p.SetLastResponseMeta_(_meta27)
  if _err != nil {
    return
  }
  return _result28.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) GetInfo(ctx context.Context, id int32) (_r string, _err error) {
  var _args29 IPCChainTesterGetInfoArgs
  _args29.ID = id
  var _result31 IPCChainTesterGetInfoResult
  var _meta30 thrift.ResponseMeta
  _meta30, _err = p.Client_().Call(ctx, "get_info", &_args29, &_result31)
  p.SetLastResponseMeta_(_meta30)
  if _err != nil {
    return
  }
  return _result31.GetSuccess(), nil
}

// Parameters:
//  - KeyType
func (p *IPCChainTesterClient) CreateKey(ctx context.Context, key_type string) (_r string, _err error) {
  var _args32 IPCChainTesterCreateKeyArgs
  _args32.KeyType = key_type
  var _result34 IPCChainTesterCreateKeyResult
  var _meta33 thrift.ResponseMeta
  _meta33, _err = p.Client_().Call(ctx, "create_key", &_args32, &_result34)
  p.SetLastResponseMeta_(_meta33)
  if _err != nil {
    return
  }
  return _result34.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Account
func (p *IPCChainTesterClient) GetAccount(ctx context.Context, id int32, account string) (_r string, _err error) {
  var _args35 IPCChainTesterGetAccountArgs
  _args35.ID = id
  _args35.Account = account
  var _result37 IPCChainTesterGetAccountResult
  var _meta36 thrift.ResponseMeta
  _meta36, _err = p.Client_().Call(ctx, "get_account", &_args35, &_result37)
  p.SetLastResponseMeta_(_meta36)
  if _err != nil {
    return
  }
  return _result37.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Creator
//  - Account
//  - OwnerKey
//  - ActiveKey
//  - RAMBytes
//  - StakeNet
//  - StakeCPU
func (p *IPCChainTesterClient) CreateAccount(ctx context.Context, id int32, creator string, account string, owner_key string, active_key string, ram_bytes int64, stake_net int64, stake_cpu int64) (_r string, _err error) {
  var _args38 IPCChainTesterCreateAccountArgs
  _args38.ID = id
  _args38.Creator = creator
  _args38.Account = account
  _args38.OwnerKey = owner_key
  _args38.ActiveKey = active_key
  _args38.RAMBytes = ram_bytes
  _args38.StakeNet = stake_net
  _args38.StakeCPU = stake_cpu
  var _result40 IPCChainTesterCreateAccountResult
  var _meta39 thrift.ResponseMeta
  _meta39, _err = p.Client_().Call(ctx, "create_account", &_args38, &_result40)
  p.SetLastResponseMeta_(_meta39)
  if _err != nil {
    return
  }
  return _result40.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - PubKey
//  - PrivKey
func (p *IPCChainTesterClient) ImportKey(ctx context.Context, id int32, pub_key string, priv_key string) (_r bool, _err error) {
  var _args41 IPCChainTesterImportKeyArgs
  _args41.ID = id
  _args41.PubKey = pub_key
  _args41.PrivKey = priv_key
  var _result43 IPCChainTesterImportKeyResult
  var _meta42 thrift.ResponseMeta
  _meta42, _err = p.Client_().Call(ctx, "import_key", &_args41, &_result43)
  p.SetLastResponseMeta_(_meta42)
  if _err != nil {
    return
  }
  return _result43.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Transaction
//  - AvailableKeys
func (p *IPCChainTesterClient) GetRequiredKeys(ctx context.Context, id int32, transaction string, available_keys []string) (_r string, _err error) {
  var _args44 IPCChainTesterGetRequiredKeysArgs
  _args44.ID = id
  _args44.Transaction = transaction
  _args44.AvailableKeys = available_keys
  var _result46 IPCChainTesterGetRequiredKeysResult
  var _meta45 thrift.ResponseMeta
  _meta45, _err = p.Client_().Call(ctx, "get_required_keys", &_args44, &_result46)
  p.SetLastResponseMeta_(_meta45)
  if _err != nil {
    return
  }
  return _result46.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - NextBlockSkipSeconds
func (p *IPCChainTesterClient) ProduceBlock(ctx context.Context, id int32, next_block_skip_seconds int64) (_err error) {
  var _args47 IPCChainTesterProduceBlockArgs
  _args47.ID = id
  _args47.NextBlockSkipSeconds = next_block_skip_seconds
  var _result49 IPCChainTesterProduceBlockResult
  var _meta48 thrift.ResponseMeta
  _meta48, _err = p.Client_().Call(ctx, "produce_block", &_args47, &_result49)
  p.SetLastResponseMeta_(_meta48)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
func (p *IPCChainTesterClient) PushAction(ctx context.Context, id int32, account string, action string, arguments *ActionArguments, permissions string) (_r []byte, _err error) {
  var _args50 IPCChainTesterPushActionArgs
  _args50.ID = id
  _args50.Account = account
  _args50.Action = action
  _args50.Arguments = arguments
  _args50.Permissions = permissions
  var _result52 IPCChainTesterPushActionResult
  var _meta51 thrift.ResponseMeta
  _meta51, _err = p.Client_().Call(ctx, "push_action", &_args50, &_result52)
  p.SetLastResponseMeta_(_meta51)
  if _err != nil {
    return
  }
  return _result52.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Actions
func (p *IPCChainTesterClient) PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error) {
  var _args53 IPCChainTesterPushActionsArgs
  _args53.ID = id
  _args53.Actions = actions
  var _result55 IPCChainTesterPushActionsResult
  var _meta54 thrift.ResponseMeta
  _meta54, _err = p.Client_().Call(ctx, "push_actions", &_args53, &_result55)
  p.SetLastResponseMeta_(_meta54)
  if _err != nil {
    return
  }
  return _result55.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Account
//  - Wasm
//  - Abi
func (p *IPCChainTesterClient) DeployContract(ctx context.Context, id int32, account string, wasm string, abi string) (_r []byte, _err error) {
  var _args56 IPCChainTesterDeployContractArgs
  _args56.ID = id
  _args56.Account = account
  _args56.Wasm = wasm
  _args56.Abi = abi
  var _result58 IPCChainTesterDeployContractResult
  var _meta57 thrift.ResponseMeta
  _meta57, _err = p.Client_().Call(ctx, "deploy_contract", &_args56, &_result58)
  p.SetLastResponseMeta_(_meta57)
  if _err != nil {
    return
  }
  return _result58.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - JSON
//  - Code
//  - Scope
//  - Table
//  - LowerBound
//  - UpperBound
//  - Limit
//  - KeyType
//  - IndexPosition
//  - Reverse
//  - ShowPayer
func (p *IPCChainTesterClient) GetTableRows(ctx context.Context, id int32, json bool, code string, scope string, table string, lower_bound string, upper_bound string, limit int64, key_type string, index_position string, reverse bool, show_payer bool) (_r string, _err error) {
  var _args59 IPCChainTesterGetTableRowsArgs
  _args59.ID = id
  _args59.JSON = json
  _args59.Code = code
  _args59.Scope = scope
  _args59.Table = table
  _args59.LowerBound = lower_bound
  _args59.UpperBound = upper_bound
  _args59.Limit = limit
  _args59.KeyType = key_type
  _args59.IndexPosition = index_position
  _args59.Reverse = reverse
  _args59.ShowPayer = show_payer
  var _result61 IPCChainTesterGetTableRowsResult
  var _meta60 thrift.ResponseMeta
  _meta60, _err = p.Client_().Call(ctx, "get_table_rows", &_args59, &_result61)
  p.SetLastResponseMeta_(_meta60)
  if _err != nil {
    return
  }
  return _result61.GetSuccess(), nil
}

type IPCChainTesterProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler IPCChainTester
}

func (p *IPCChainTesterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *IPCChainTesterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *IPCChainTesterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewIPCChainTesterProcessor(handler IPCChainTester) *IPCChainTesterProcessor {

  self62 := &IPCChainTesterProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self62.processorMap["init_vm_api"] = &iPCChainTesterProcessorInitVMAPI{handler:handler}
  self62.processorMap["init_apply_request"] = &iPCChainTesterProcessorInitApplyRequest{handler:handler}
  self62.processorMap["set_native_contract"] = &iPCChainTesterProcessorSetNativeContract{handler:handler}
  self62.processorMap["enable_debugging"] = &iPCChainTesterProcessorEnableDebugging{handler:handler}
  self62.processorMap["enable_debug_contract"] = &iPCChainTesterProcessorEnableDebugContract{handler:handler}
  self62.processorMap["is_debug_contract_enabled"] = &iPCChainTesterProcessorIsDebugContractEnabled{handler:handler}
  self62.processorMap["pack_abi"] = &iPCChainTesterProcessorPackAbi{handler:handler}
  self62.processorMap["pack_action_args"] = &iPCChainTesterProcessorPackActionArgs_{handler:handler}
  self62.processorMap["unpack_action_args"] = &iPCChainTesterProcessorUnpackActionArgs_{handler:handler}
  self62.processorMap["new_chain"] = &iPCChainTesterProcessorNewChain_{handler:handler}
  self62.processorMap["free_chain"] = &iPCChainTesterProcessorFreeChain{handler:handler}
  self62.processorMap["get_info"] = &iPCChainTesterProcessorGetInfo{handler:handler}
  self62.processorMap["create_key"] = &iPCChainTesterProcessorCreateKey{handler:handler}
  self62.processorMap["get_account"] = &iPCChainTesterProcessorGetAccount{handler:handler}
  self62.processorMap["create_account"] = &iPCChainTesterProcessorCreateAccount{handler:handler}
  self62.processorMap["import_key"] = &iPCChainTesterProcessorImportKey{handler:handler}
  self62.processorMap["get_required_keys"] = &iPCChainTesterProcessorGetRequiredKeys{handler:handler}
  self62.processorMap["produce_block"] = &iPCChainTesterProcessorProduceBlock{handler:handler}
  self62.processorMap["push_action"] = &iPCChainTesterProcessorPushAction{handler:handler}
  self62.processorMap["push_actions"] = &iPCChainTesterProcessorPushActions{handler:handler}
  self62.processorMap["deploy_contract"] = &iPCChainTesterProcessorDeployContract{handler:handler}
  self62.processorMap["get_table_rows"] = &iPCChainTesterProcessorGetTableRows{handler:handler}
return self62
}

func (p *IPCChainTesterProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x63 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x63.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x63

}

type iPCChainTesterProcessorInitVMAPI struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitVMAPI) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitVMAPIArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitVMAPI(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorInitApplyRequest struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitApplyRequest(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorSetNativeContract struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorSetNativeContract) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterSetNativeContractArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_native_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterSetNativeContractResult{}
  var retval bool
  if retval, err2 = p.handler.SetNativeContract(ctx, args.ID, args.Contract, args.Dylib); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_native_contract: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_native_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_native_contract", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorEnableDebugging struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorEnableDebugging) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterEnableDebuggingArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debugging", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterEnableDebuggingResult{}
  if err2 = p.handler.EnableDebugging(ctx, args.Enable); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enable_debugging: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debugging", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "enable_debugging", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorEnableDebugContract struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorEnableDebugContract) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterEnableDebugContractArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterEnableDebugContractResult{}
  if err2 = p.handler.EnableDebugContract(ctx, args.ID, args.Contract, args.Enable); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enable_debug_contract: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorIsDebugContractEnabled struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorIsDebugContractEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterIsDebugContractEnabledArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterIsDebugContractEnabledResult{}
  var retval bool
  if retval, err2 = p.handler.IsDebugContractEnabled(ctx, args.ID, args.Contract); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_debug_contract_enabled: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackAbi struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackAbi) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackAbiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackAbiResult{}
  var retval []byte
  if retval, err2 = p.handler.PackAbi(ctx, args.Abi); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_abi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_abi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.PackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.ActionArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorUnpackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorUnpackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterUnpackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterUnpackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.UnpackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.RawArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unpack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorNewChain_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorNewChain_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterNewChainArgs_{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterNewChainResult_{}
  var retval int32
  if retval, err2 = p.handler.NewChain_(ctx, args.Initialize); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing new_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "new_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorFreeChain struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorFreeChain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterFreeChainArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterFreeChainResult{}
  var retval int32
  if retval, err2 = p.handler.FreeChain(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing free_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "free_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorGetInfo struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorGetInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterGetInfoArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_info", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterGetInfoResult{}
  var retval string
  if retval, err2 = p.handler.GetInfo(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_info: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_info", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_info", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorCreateKey struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorCreateKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterCreateKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "create_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterCreateKeyResult{}
  var retval string
  if retval, err2 = p.handler.CreateKey(ctx, args.KeyType); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing create_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "create_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "create_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorGetAccount struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorGetAccount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterGetAccountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterGetAccountResult{}
  var retval string
  if retval, err2 = p.handler.GetAccount(ctx, args.ID, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_account: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_account", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorCreateAccount struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorCreateAccount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterCreateAccountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "create_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterCreateAccountResult{}
  var retval string
  if retval, err2 = p.handler.CreateAccount(ctx, args.ID, args.Creator, args.Account, args.OwnerKey, args.ActiveKey, args.RAMBytes, args.StakeNet, args.StakeCPU); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing create_account: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "create_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "create_account", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorImportKey struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorImportKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterImportKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "import_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterImportKeyResult{}
  var retval bool
  if retval, err2 = p.handler.ImportKey(ctx, args.ID, args.PubKey, args.PrivKey); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing import_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "import_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "import_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorGetRequiredKeys struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorGetRequiredKeys) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterGetRequiredKeysArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_required_keys", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterGetRequiredKeysResult{}
  var retval string
  if retval, err2 = p.handler.GetRequiredKeys(ctx, args.ID, args.Transaction, args.AvailableKeys); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_required_keys: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_required_keys", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_required_keys", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorProduceBlock struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorProduceBlock) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterProduceBlockArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterProduceBlockResult{}
  if err2 = p.handler.ProduceBlock(ctx, args.ID, args.NextBlockSkipSeconds); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing produce_block: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "produce_block", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushAction struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionResult{}
  var retval []byte
  if retval, err2 = p.handler.PushAction(ctx, args.ID, args.Account, args.Action, args.Arguments, args.Permissions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushActions struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionsResult{}
  var retval []byte
  if retval, err2 = p.handler.PushActions(ctx, args.ID, args.Actions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorDeployContract struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorDeployContract) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterDeployContractArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deploy_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterDeployContractResult{}
  var retval []byte
  if retval, err2 = p.handler.DeployContract(ctx, args.ID, args.Account, args.Wasm, args.Abi); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deploy_contract: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "deploy_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "deploy_contract", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorGetTableRows struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorGetTableRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterGetTableRowsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterGetTableRowsResult{}
  var retval string
  if retval, err2 = p.handler.GetTableRows(ctx, args.ID, args.JSON, args.Code, args.Scope, args.Table, args.LowerBound, args.UpperBound, args.Limit, args.KeyType, args.IndexPosition, args.Reverse, args.ShowPayer); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_table_rows: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_table_rows", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type IPCChainTesterInitVMAPIArgs struct {
}

func NewIPCChainTesterInitVMAPIArgs() *IPCChainTesterInitVMAPIArgs {
  return &IPCChainTesterInitVMAPIArgs{}
}

func (p *IPCChainTesterInitVMAPIArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_vm_api_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitVMAPIArgs(%+v)", *p)
}

type IPCChainTesterInitApplyRequestArgs struct {
}

func NewIPCChainTesterInitApplyRequestArgs() *IPCChainTesterInitApplyRequestArgs {
  return &IPCChainTesterInitApplyRequestArgs{}
}

func (p *IPCChainTesterInitApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Dylib
type IPCChainTesterSetNativeContractArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Dylib string `thrift:"dylib,3" db:"dylib" json:"dylib"`
}

func NewIPCChainTesterSetNativeContractArgs() *IPCChainTesterSetNativeContractArgs {
  return &IPCChainTesterSetNativeContractArgs{}
}


func (p *IPCChainTesterSetNativeContractArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterSetNativeContractArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterSetNativeContractArgs) GetDylib() string {
  return p.Dylib
}
func (p *IPCChainTesterSetNativeContractArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterSetNativeContractArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterSetNativeContractArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterSetNativeContractArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Dylib = v
}
  return nil
}

func (p *IPCChainTesterSetNativeContractArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_native_contract_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterSetNativeContractArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterSetNativeContractArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterSetNativeContractArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dylib", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dylib: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Dylib)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dylib (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dylib: ", p), err) }
  return err
}

func (p *IPCChainTesterSetNativeContractArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterSetNativeContractArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterSetNativeContractResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterSetNativeContractResult() *IPCChainTesterSetNativeContractResult {
  return &IPCChainTesterSetNativeContractResult{}
}

var IPCChainTesterSetNativeContractResult_Success_DEFAULT bool
func (p *IPCChainTesterSetNativeContractResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return IPCChainTesterSetNativeContractResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterSetNativeContractResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterSetNativeContractResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterSetNativeContractResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterSetNativeContractResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_native_contract_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterSetNativeContractResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterSetNativeContractResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterSetNativeContractResult(%+v)", *p)
}

// Attributes:
//  - Enable
type IPCChainTesterEnableDebuggingArgs struct {
  Enable bool `thrift:"enable,1" db:"enable" json:"enable"`
}

func NewIPCChainTesterEnableDebuggingArgs() *IPCChainTesterEnableDebuggingArgs {
  return &IPCChainTesterEnableDebuggingArgs{}
}


func (p *IPCChainTesterEnableDebuggingArgs) GetEnable() bool {
  return p.Enable
}
func (p *IPCChainTesterEnableDebuggingArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebuggingArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Enable = v
}
  return nil
}

func (p *IPCChainTesterEnableDebuggingArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debugging_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebuggingArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "enable", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:enable: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Enable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.enable (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:enable: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebuggingArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebuggingArgs(%+v)", *p)
}

type IPCChainTesterEnableDebuggingResult struct {
}

func NewIPCChainTesterEnableDebuggingResult() *IPCChainTesterEnableDebuggingResult {
  return &IPCChainTesterEnableDebuggingResult{}
}

func (p *IPCChainTesterEnableDebuggingResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebuggingResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debugging_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebuggingResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebuggingResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Enable
type IPCChainTesterEnableDebugContractArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Enable bool `thrift:"enable,3" db:"enable" json:"enable"`
}

func NewIPCChainTesterEnableDebugContractArgs() *IPCChainTesterEnableDebugContractArgs {
  return &IPCChainTesterEnableDebugContractArgs{}
}


func (p *IPCChainTesterEnableDebugContractArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterEnableDebugContractArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterEnableDebugContractArgs) GetEnable() bool {
  return p.Enable
}
func (p *IPCChainTesterEnableDebugContractArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Enable = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "enable", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:enable: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Enable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.enable (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:enable: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractArgs(%+v)", *p)
}

type IPCChainTesterEnableDebugContractResult struct {
}

func NewIPCChainTesterEnableDebugContractResult() *IPCChainTesterEnableDebugContractResult {
  return &IPCChainTesterEnableDebugContractResult{}
}

func (p *IPCChainTesterEnableDebugContractResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
type IPCChainTesterIsDebugContractEnabledArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
}

func NewIPCChainTesterIsDebugContractEnabledArgs() *IPCChainTesterIsDebugContractEnabledArgs {
  return &IPCChainTesterIsDebugContractEnabledArgs{}
}


func (p *IPCChainTesterIsDebugContractEnabledArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) GetContract() string {
  return p.Contract
}
func (p *IPCChainTesterIsDebugContractEnabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterIsDebugContractEnabledResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterIsDebugContractEnabledResult() *IPCChainTesterIsDebugContractEnabledResult {
  return &IPCChainTesterIsDebugContractEnabledResult{}
}

var IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT bool
func (p *IPCChainTesterIsDebugContractEnabledResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterIsDebugContractEnabledResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledResult(%+v)", *p)
}

// Attributes:
//  - Abi
type IPCChainTesterPackAbiArgs struct {
  Abi string `thrift:"abi,1" db:"abi" json:"abi"`
}

func NewIPCChainTesterPackAbiArgs() *IPCChainTesterPackAbiArgs {
  return &IPCChainTesterPackAbiArgs{}
}


func (p *IPCChainTesterPackAbiArgs) GetAbi() string {
  return p.Abi
}
func (p *IPCChainTesterPackAbiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Abi = v
}
  return nil
}

func (p *IPCChainTesterPackAbiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "abi", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:abi: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Abi)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.abi (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:abi: ", p), err) }
  return err
}

func (p *IPCChainTesterPackAbiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackAbiResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackAbiResult() *IPCChainTesterPackAbiResult {
  return &IPCChainTesterPackAbiResult{}
}

var IPCChainTesterPackAbiResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackAbiResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackAbiResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackAbiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackAbiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackAbiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
type IPCChainTesterPackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  ActionArgs_ string `thrift:"action_args,4" db:"action_args" json:"action_args"`
}

func NewIPCChainTesterPackActionArgsArgs() *IPCChainTesterPackActionArgsArgs {
  return &IPCChainTesterPackActionArgsArgs{}
}


func (p *IPCChainTesterPackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterPackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterPackActionArgsArgs) GetActionArgs_() string {
  return p.ActionArgs_
}
func (p *IPCChainTesterPackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ActionArgs_ = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:action_args: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ActionArgs_)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:action_args: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackActionArgsResult() *IPCChainTesterPackActionArgsResult {
  return &IPCChainTesterPackActionArgsResult{}
}

var IPCChainTesterPackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
type IPCChainTesterUnpackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  RawArgs_ []byte `thrift:"raw_args,4" db:"raw_args" json:"raw_args"`
}

func NewIPCChainTesterUnpackActionArgsArgs() *IPCChainTesterUnpackActionArgsArgs {
  return &IPCChainTesterUnpackActionArgsArgs{}
}


func (p *IPCChainTesterUnpackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetRawArgs_() []byte {
  return p.RawArgs_
}
func (p *IPCChainTesterUnpackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.RawArgs_ = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "raw_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:raw_args: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawArgs_); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.raw_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:raw_args: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterUnpackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterUnpackActionArgsResult() *IPCChainTesterUnpackActionArgsResult {
  return &IPCChainTesterUnpackActionArgsResult{}
}

var IPCChainTesterUnpackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterUnpackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterUnpackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterUnpackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsResult(%+v)", *p)
}

// Attributes:
//  - Initialize
type IPCChainTesterNewChainArgs_ struct {
  Initialize bool `thrift:"initialize,1" db:"initialize" json:"initialize"`
}

func NewIPCChainTesterNewChainArgs_() *IPCChainTesterNewChainArgs_ {
  return &IPCChainTesterNewChainArgs_{}
}


func (p *IPCChainTesterNewChainArgs_) GetInitialize() bool {
  return p.Initialize
}
func (p *IPCChainTesterNewChainArgs_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainArgs_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Initialize = v
}
  return nil
}

func (p *IPCChainTesterNewChainArgs_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainArgs_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "initialize", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:initialize: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Initialize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.initialize (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:initialize: ", p), err) }
  return err
}

func (p *IPCChainTesterNewChainArgs_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainArgs_(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterNewChainResult_ struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterNewChainResult_() *IPCChainTesterNewChainResult_ {
  return &IPCChainTesterNewChainResult_{}
}

var IPCChainTesterNewChainResult__Success_DEFAULT int32
func (p *IPCChainTesterNewChainResult_) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterNewChainResult__Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterNewChainResult_) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterNewChainResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainResult_)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterNewChainResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainResult_) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterNewChainResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainResult_(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterFreeChainArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterFreeChainArgs() *IPCChainTesterFreeChainArgs {
  return &IPCChainTesterFreeChainArgs{}
}


func (p *IPCChainTesterFreeChainArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterFreeChainArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterFreeChainArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterFreeChainArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterFreeChainResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterFreeChainResult() *IPCChainTesterFreeChainResult {
  return &IPCChainTesterFreeChainResult{}
}

var IPCChainTesterFreeChainResult_Success_DEFAULT int32
func (p *IPCChainTesterFreeChainResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterFreeChainResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterFreeChainResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterFreeChainResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterFreeChainResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterFreeChainResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainResult(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterGetInfoArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterGetInfoArgs() *IPCChainTesterGetInfoArgs {
  return &IPCChainTesterGetInfoArgs{}
}


func (p *IPCChainTesterGetInfoArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterGetInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetInfoArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterGetInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_info_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterGetInfoArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterGetInfoResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterGetInfoResult() *IPCChainTesterGetInfoResult {
  return &IPCChainTesterGetInfoResult{}
}

var IPCChainTesterGetInfoResult_Success_DEFAULT string
func (p *IPCChainTesterGetInfoResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterGetInfoResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterGetInfoResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterGetInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetInfoResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterGetInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_info_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetInfoResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterGetInfoResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetInfoResult(%+v)", *p)
}

// Attributes:
//  - KeyType
type IPCChainTesterCreateKeyArgs struct {
  KeyType string `thrift:"key_type,1" db:"key_type" json:"key_type"`
}

func NewIPCChainTesterCreateKeyArgs() *IPCChainTesterCreateKeyArgs {
  return &IPCChainTesterCreateKeyArgs{}
}


func (p *IPCChainTesterCreateKeyArgs) GetKeyType() string {
  return p.KeyType
}
func (p *IPCChainTesterCreateKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterCreateKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.KeyType = v
}
  return nil
}

func (p *IPCChainTesterCreateKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "create_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterCreateKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_type", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key_type: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.KeyType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key_type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key_type: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterCreateKeyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterCreateKeyResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterCreateKeyResult() *IPCChainTesterCreateKeyResult {
  return &IPCChainTesterCreateKeyResult{}
}

var IPCChainTesterCreateKeyResult_Success_DEFAULT string
func (p *IPCChainTesterCreateKeyResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterCreateKeyResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterCreateKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterCreateKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterCreateKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterCreateKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "create_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterCreateKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterCreateKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterCreateKeyResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Account
type IPCChainTesterGetAccountArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Account string `thrift:"account,2" db:"account" json:"account"`
}

func NewIPCChainTesterGetAccountArgs() *IPCChainTesterGetAccountArgs {
  return &IPCChainTesterGetAccountArgs{}
}


func (p *IPCChainTesterGetAccountArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterGetAccountArgs) GetAccount() string {
  return p.Account
}
func (p *IPCChainTesterGetAccountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetAccountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterGetAccountArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterGetAccountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetAccountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterGetAccountArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:account: ", p), err) }
  return err
}

func (p *IPCChainTesterGetAccountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetAccountArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterGetAccountResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterGetAccountResult() *IPCChainTesterGetAccountResult {
  return &IPCChainTesterGetAccountResult{}
}

var IPCChainTesterGetAccountResult_Success_DEFAULT string
func (p *IPCChainTesterGetAccountResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterGetAccountResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterGetAccountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterGetAccountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetAccountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterGetAccountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetAccountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterGetAccountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetAccountResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Creator
//  - Account
//  - OwnerKey
//  - ActiveKey
//  - RAMBytes
//  - StakeNet
//  - StakeCPU
type IPCChainTesterCreateAccountArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Creator string `thrift:"creator,2" db:"creator" json:"creator"`
  Account string `thrift:"account,3" db:"account" json:"account"`
  OwnerKey string `thrift:"owner_key,4" db:"owner_key" json:"owner_key"`
  ActiveKey string `thrift:"active_key,5" db:"active_key" json:"active_key"`
  RAMBytes int64 `thrift:"ram_bytes,6" db:"ram_bytes" json:"ram_bytes"`
  StakeNet int64 `thrift:"stake_net,7" db:"stake_net" json:"stake_net"`
  StakeCPU int64 `thrift:"stake_cpu,8" db:"stake_cpu" json:"stake_cpu"`
}

func NewIPCChainTesterCreateAccountArgs() *IPCChainTesterCreateAccountArgs {
  return &IPCChainTesterCreateAccountArgs{}
}


func (p *IPCChainTesterCreateAccountArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterCreateAccountArgs) GetCreator() string {
  return p.Creator
}

func (p *IPCChainTesterCreateAccountArgs) GetAccount() string {
  return p.Account
}

func (p *IPCChainTesterCreateAccountArgs) GetOwnerKey() string {
  return p.OwnerKey
}

func (p *IPCChainTesterCreateAccountArgs) GetActiveKey() string {
  return p.ActiveKey
}

func (p *IPCChainTesterCreateAccountArgs) GetRAMBytes() int64 {
  return p.RAMBytes
}

func (p *IPCChainTesterCreateAccountArgs) GetStakeNet() int64 {
  return p.StakeNet
}

func (p *IPCChainTesterCreateAccountArgs) GetStakeCPU() int64 {
  return p.StakeCPU
}
func (p *IPCChainTesterCreateAccountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Creator = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.OwnerKey = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.ActiveKey = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.RAMBytes = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.StakeNet = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.StakeCPU = v
}
  return nil
}

func (p *IPCChainTesterCreateAccountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "create_account_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterCreateAccountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "creator", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:creator: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Creator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.creator (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:creator: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:account: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "owner_key", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:owner_key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OwnerKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.owner_key (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:owner_key: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "active_key", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:active_key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ActiveKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.active_key (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:active_key: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ram_bytes", thrift.I64, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:ram_bytes: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RAMBytes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ram_bytes (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:ram_bytes: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "stake_net", thrift.I64, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:stake_net: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.StakeNet)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.stake_net (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:stake_net: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "stake_cpu", thrift.I64, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:stake_cpu: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.StakeCPU)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.stake_cpu (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:stake_cpu: ", p), err) }
  return err
}

func (p *IPCChainTesterCreateAccountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterCreateAccountArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterCreateAccountResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterCreateAccountResult() *IPCChainTesterCreateAccountResult {
  return &IPCChainTesterCreateAccountResult{}
}

var IPCChainTesterCreateAccountResult_Success_DEFAULT string
func (p *IPCChainTesterCreateAccountResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterCreateAccountResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterCreateAccountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterCreateAccountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterCreateAccountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterCreateAccountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "create_account_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterCreateAccountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterCreateAccountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterCreateAccountResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - PubKey
//  - PrivKey
type IPCChainTesterImportKeyArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  PubKey string `thrift:"pub_key,2" db:"pub_key" json:"pub_key"`
  PrivKey string `thrift:"priv_key,3" db:"priv_key" json:"priv_key"`
}

func NewIPCChainTesterImportKeyArgs() *IPCChainTesterImportKeyArgs {
  return &IPCChainTesterImportKeyArgs{}
}


func (p *IPCChainTesterImportKeyArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterImportKeyArgs) GetPubKey() string {
  return p.PubKey
}

func (p *IPCChainTesterImportKeyArgs) GetPrivKey() string {
  return p.PrivKey
}
func (p *IPCChainTesterImportKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterImportKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterImportKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PubKey = v
}
  return nil
}

func (p *IPCChainTesterImportKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PrivKey = v
}
  return nil
}

func (p *IPCChainTesterImportKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "import_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterImportKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterImportKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pub_key", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pub_key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.PubKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pub_key (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pub_key: ", p), err) }
  return err
}

func (p *IPCChainTesterImportKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "priv_key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:priv_key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.PrivKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.priv_key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:priv_key: ", p), err) }
  return err
}

func (p *IPCChainTesterImportKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterImportKeyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterImportKeyResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterImportKeyResult() *IPCChainTesterImportKeyResult {
  return &IPCChainTesterImportKeyResult{}
}

var IPCChainTesterImportKeyResult_Success_DEFAULT bool
func (p *IPCChainTesterImportKeyResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return IPCChainTesterImportKeyResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterImportKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterImportKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterImportKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterImportKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "import_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterImportKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterImportKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterImportKeyResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Transaction
//  - AvailableKeys
type IPCChainTesterGetRequiredKeysArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Transaction string `thrift:"transaction,2" db:"transaction" json:"transaction"`
  AvailableKeys []string `thrift:"available_keys,3" db:"available_keys" json:"available_keys"`
}

func NewIPCChainTesterGetRequiredKeysArgs() *IPCChainTesterGetRequiredKeysArgs {
  return &IPCChainTesterGetRequiredKeysArgs{}
}


func (p *IPCChainTesterGetRequiredKeysArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterGetRequiredKeysArgs) GetTransaction() string {
  return p.Transaction
}

func (p *IPCChainTesterGetRequiredKeysArgs) GetAvailableKeys() []string {
  return p.AvailableKeys
}
func (p *IPCChainTesterGetRequiredKeysArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetRequiredKeysArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterGetRequiredKeysArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Transaction = v
}
  return nil
}

func (p *IPCChainTesterGetRequiredKeysArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.AvailableKeys =  tSlice
  for i := 0; i < size; i ++ {
var _elem64 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem64 = v
}
    p.AvailableKeys = append(p.AvailableKeys, _elem64)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IPCChainTesterGetRequiredKeysArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_required_keys_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetRequiredKeysArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterGetRequiredKeysArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "transaction", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:transaction: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Transaction)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.transaction (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:transaction: ", p), err) }
  return err
}

func (p *IPCChainTesterGetRequiredKeysArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "available_keys", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:available_keys: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.AvailableKeys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.AvailableKeys {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:available_keys: ", p), err) }
  return err
}

func (p *IPCChainTesterGetRequiredKeysArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetRequiredKeysArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterGetRequiredKeysResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterGetRequiredKeysResult() *IPCChainTesterGetRequiredKeysResult {
  return &IPCChainTesterGetRequiredKeysResult{}
}

var IPCChainTesterGetRequiredKeysResult_Success_DEFAULT string
func (p *IPCChainTesterGetRequiredKeysResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterGetRequiredKeysResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterGetRequiredKeysResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterGetRequiredKeysResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetRequiredKeysResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterGetRequiredKeysResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_required_keys_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetRequiredKeysResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterGetRequiredKeysResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetRequiredKeysResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - NextBlockSkipSeconds
type IPCChainTesterProduceBlockArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  NextBlockSkipSeconds int64 `thrift:"next_block_skip_seconds,2" db:"next_block_skip_seconds" json:"next_block_skip_seconds"`
}

func NewIPCChainTesterProduceBlockArgs() *IPCChainTesterProduceBlockArgs {
  return &IPCChainTesterProduceBlockArgs{}
}


func (p *IPCChainTesterProduceBlockArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterProduceBlockArgs) GetNextBlockSkipSeconds() int64 {
  return p.NextBlockSkipSeconds
}
func (p *IPCChainTesterProduceBlockArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterProduceBlockArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NextBlockSkipSeconds = v
}
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterProduceBlockArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "next_block_skip_seconds", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:next_block_skip_seconds: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NextBlockSkipSeconds)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.next_block_skip_seconds (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:next_block_skip_seconds: ", p), err) }
  return err
}

func (p *IPCChainTesterProduceBlockArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockArgs(%+v)", *p)
}

type IPCChainTesterProduceBlockResult struct {
}

func NewIPCChainTesterProduceBlockResult() *IPCChainTesterProduceBlockResult {
  return &IPCChainTesterProduceBlockResult{}
}

func (p *IPCChainTesterProduceBlockResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
type IPCChainTesterPushActionArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Account string `thrift:"account,2" db:"account" json:"account"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  Arguments *ActionArguments `thrift:"arguments,4" db:"arguments" json:"arguments"`
  Permissions string `thrift:"permissions,5" db:"permissions" json:"permissions"`
}

func NewIPCChainTesterPushActionArgs() *IPCChainTesterPushActionArgs {
  return &IPCChainTesterPushActionArgs{}
}


func (p *IPCChainTesterPushActionArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionArgs) GetAccount() string {
  return p.Account
}

func (p *IPCChainTesterPushActionArgs) GetAction() string {
  return p.Action
}
var IPCChainTesterPushActionArgs_Arguments_DEFAULT *ActionArguments
func (p *IPCChainTesterPushActionArgs) GetArguments() *ActionArguments {
  if !p.IsSetArguments() {
    return IPCChainTesterPushActionArgs_Arguments_DEFAULT
  }
return p.Arguments
}

func (p *IPCChainTesterPushActionArgs) GetPermissions() string {
  return p.Permissions
}
func (p *IPCChainTesterPushActionArgs) IsSetArguments() bool {
  return p.Arguments != nil
}

func (p *IPCChainTesterPushActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Arguments = &ActionArguments{}
  if err := p.Arguments.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Arguments), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:account: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := p.Arguments.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Arguments), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:permissions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPushActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPushActionResult() *IPCChainTesterPushActionResult {
  return &IPCChainTesterPushActionResult{}
}

var IPCChainTesterPushActionResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPushActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Actions
type IPCChainTesterPushActionsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Actions []*Action `thrift:"actions,2" db:"actions" json:"actions"`
}

func NewIPCChainTesterPushActionsArgs() *IPCChainTesterPushActionsArgs {
  return &IPCChainTesterPushActionsArgs{}
}


func (p *IPCChainTesterPushActionsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *IPCChainTesterPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem65 := &Action{}
    if err := _elem65.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem65), err)
    }
    p.Actions = append(p.Actions, _elem65)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:actions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPushActionsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPushActionsResult() *IPCChainTesterPushActionsResult {
  return &IPCChainTesterPushActionsResult{}
}

var IPCChainTesterPushActionsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Account
//  - Wasm
//  - Abi
type IPCChainTesterDeployContractArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Account string `thrift:"account,2" db:"account" json:"account"`
  Wasm string `thrift:"wasm,3" db:"wasm" json:"wasm"`
  Abi string `thrift:"abi,4" db:"abi" json:"abi"`
}

func NewIPCChainTesterDeployContractArgs() *IPCChainTesterDeployContractArgs {
  return &IPCChainTesterDeployContractArgs{}
}


func (p *IPCChainTesterDeployContractArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterDeployContractArgs) GetAccount() string {
  return p.Account
}

func (p *IPCChainTesterDeployContractArgs) GetWasm() string {
  return p.Wasm
}

func (p *IPCChainTesterDeployContractArgs) GetAbi() string {
  return p.Abi
}
func (p *IPCChainTesterDeployContractArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterDeployContractArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterDeployContractArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterDeployContractArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Wasm = v
}
  return nil
}

func (p *IPCChainTesterDeployContractArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Abi = v
}
  return nil
}

func (p *IPCChainTesterDeployContractArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deploy_contract_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterDeployContractArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterDeployContractArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:account: ", p), err) }
  return err
}

func (p *IPCChainTesterDeployContractArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "wasm", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:wasm: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Wasm)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.wasm (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:wasm: ", p), err) }
  return err
}

func (p *IPCChainTesterDeployContractArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "abi", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:abi: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Abi)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.abi (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:abi: ", p), err) }
  return err
}

func (p *IPCChainTesterDeployContractArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterDeployContractArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterDeployContractResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterDeployContractResult() *IPCChainTesterDeployContractResult {
  return &IPCChainTesterDeployContractResult{}
}

var IPCChainTesterDeployContractResult_Success_DEFAULT []byte

func (p *IPCChainTesterDeployContractResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterDeployContractResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterDeployContractResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterDeployContractResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterDeployContractResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deploy_contract_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterDeployContractResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterDeployContractResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterDeployContractResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - JSON
//  - Code
//  - Scope
//  - Table
//  - LowerBound
//  - UpperBound
//  - Limit
//  - KeyType
//  - IndexPosition
//  - Reverse
//  - ShowPayer
type IPCChainTesterGetTableRowsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  JSON bool `thrift:"json,2" db:"json" json:"json"`
  Code string `thrift:"code,3" db:"code" json:"code"`
  Scope string `thrift:"scope,4" db:"scope" json:"scope"`
  Table string `thrift:"table,5" db:"table" json:"table"`
  LowerBound string `thrift:"lower_bound,6" db:"lower_bound" json:"lower_bound"`
  UpperBound string `thrift:"upper_bound,7" db:"upper_bound" json:"upper_bound"`
  Limit int64 `thrift:"limit,8" db:"limit" json:"limit"`
  KeyType string `thrift:"key_type,9" db:"key_type" json:"key_type"`
  IndexPosition string `thrift:"index_position,10" db:"index_position" json:"index_position"`
  Reverse bool `thrift:"reverse,11" db:"reverse" json:"reverse"`
  ShowPayer bool `thrift:"show_payer,12" db:"show_payer" json:"show_payer"`
}

func NewIPCChainTesterGetTableRowsArgs() *IPCChainTesterGetTableRowsArgs {
  return &IPCChainTesterGetTableRowsArgs{}
}


func (p *IPCChainTesterGetTableRowsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterGetTableRowsArgs) GetJSON() bool {
  return p.JSON
}

func (p *IPCChainTesterGetTableRowsArgs) GetCode() string {
  return p.Code
}

func (p *IPCChainTesterGetTableRowsArgs) GetScope() string {
  return p.Scope
}

func (p *IPCChainTesterGetTableRowsArgs) GetTable() string {
  return p.Table
}

func (p *IPCChainTesterGetTableRowsArgs) GetLowerBound() string {
  return p.LowerBound
}

func (p *IPCChainTesterGetTableRowsArgs) GetUpperBound() string {
  return p.UpperBound
}

func (p *IPCChainTesterGetTableRowsArgs) GetLimit() int64 {
  return p.Limit
}

func (p *IPCChainTesterGetTableRowsArgs) GetKeyType() string {
  return p.KeyType
}

func (p *IPCChainTesterGetTableRowsArgs) GetIndexPosition() string {
  return p.IndexPosition
}

func (p *IPCChainTesterGetTableRowsArgs) GetReverse() bool {
  return p.Reverse
}

func (p *IPCChainTesterGetTableRowsArgs) GetShowPayer() bool {
  return p.ShowPayer
}
func (p *IPCChainTesterGetTableRowsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.JSON = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Scope = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.LowerBound = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.UpperBound = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.Limit = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.KeyType = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.IndexPosition = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.Reverse = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.ShowPayer = v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_table_rows_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetTableRowsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "json", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:json: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.JSON)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.json (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:json: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:code: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:code: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:scope: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Scope)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.scope (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:scope: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:table: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Table)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:table: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lower_bound", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:lower_bound: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.LowerBound)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.lower_bound (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:lower_bound: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "upper_bound", thrift.STRING, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:upper_bound: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.UpperBound)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.upper_bound (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:upper_bound: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:limit: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Limit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.limit (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:limit: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_type", thrift.STRING, 9); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:key_type: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.KeyType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key_type (9) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 9:key_type: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index_position", thrift.STRING, 10); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:index_position: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.IndexPosition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index_position (10) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 10:index_position: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reverse", thrift.BOOL, 11); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:reverse: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Reverse)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reverse (11) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 11:reverse: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "show_payer", thrift.BOOL, 12); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:show_payer: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.ShowPayer)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.show_payer (12) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 12:show_payer: ", p), err) }
  return err
}

func (p *IPCChainTesterGetTableRowsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetTableRowsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterGetTableRowsResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterGetTableRowsResult() *IPCChainTesterGetTableRowsResult {
  return &IPCChainTesterGetTableRowsResult{}
}

var IPCChainTesterGetTableRowsResult_Success_DEFAULT string
func (p *IPCChainTesterGetTableRowsResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return IPCChainTesterGetTableRowsResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterGetTableRowsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterGetTableRowsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterGetTableRowsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterGetTableRowsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_table_rows_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterGetTableRowsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterGetTableRowsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterGetTableRowsResult(%+v)", *p)
}


type PushActions interface {
  // Parameters:
  //  - Actions
  PushActions(ctx context.Context, actions []*Action) (_r int32, _err error)
}

type PushActionsClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewPushActionsClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewPushActionsClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewPushActionsClient(c thrift.TClient) *PushActionsClient {
  return &PushActionsClient{
    c: c,
  }
}

func (p *PushActionsClient) Client_() thrift.TClient {
  return p.c
}

func (p *PushActionsClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *PushActionsClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Actions
func (p *PushActionsClient) PushActions(ctx context.Context, actions []*Action) (_r int32, _err error) {
  var _args144 PushActionsPushActionsArgs
  _args144.Actions = actions
  var _result146 PushActionsPushActionsResult
  var _meta145 thrift.ResponseMeta
  _meta145, _err = p.Client_().Call(ctx, "push_actions", &_args144, &_result146)
  p.SetLastResponseMeta_(_meta145)
  if _err != nil {
    return
  }
  return _result146.GetSuccess(), nil
}

type PushActionsProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler PushActions
}

func (p *PushActionsProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *PushActionsProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *PushActionsProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewPushActionsProcessor(handler PushActions) *PushActionsProcessor {

  self147 := &PushActionsProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self147.processorMap["push_actions"] = &pushActionsProcessorPushActions{handler:handler}
return self147
}

func (p *PushActionsProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x148 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x148.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x148

}

type pushActionsProcessorPushActions struct {
  handler PushActions
}

func (p *pushActionsProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PushActionsPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := PushActionsPushActionsResult{}
  var retval int32
  if retval, err2 = p.handler.PushActions(ctx, args.Actions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Actions
type PushActionsPushActionsArgs struct {
  Actions []*Action `thrift:"actions,1" db:"actions" json:"actions"`
}

func NewPushActionsPushActionsArgs() *PushActionsPushActionsArgs {
  return &PushActionsPushActionsArgs{}
}


func (p *PushActionsPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *PushActionsPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem149 := &Action{}
    if err := _elem149.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem149), err)
    }
    p.Actions = append(p.Actions, _elem149)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:actions: ", p), err) }
  return err
}

func (p *PushActionsPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type PushActionsPushActionsResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewPushActionsPushActionsResult() *PushActionsPushActionsResult {
  return &PushActionsPushActionsResult{}
}

var PushActionsPushActionsResult_Success_DEFAULT int32
func (p *PushActionsPushActionsResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return PushActionsPushActionsResult_Success_DEFAULT
  }
return *p.Success
}
func (p *PushActionsPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *PushActionsPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *PushActionsPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *PushActionsPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsResult(%+v)", *p)
}


type ApplyRequest interface {
  // Parameters:
  //  - Receiver
  //  - FirstReceiver
  //  - Action
  //  - ChainTesterId
  ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64, chainTesterId int32) (_r int32, _err error)
  // Parameters:
  //  - ChainTesterId
  ApplyEnd(ctx context.Context, chainTesterId int32) (_r int32, _err error)
}

type ApplyRequestClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyRequestClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyRequestClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyRequestClient(c thrift.TClient) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: c,
  }
}

func (p *ApplyRequestClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyRequestClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyRequestClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Receiver
//  - FirstReceiver
//  - Action
//  - ChainTesterId
func (p *ApplyRequestClient) ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64, chainTesterId int32) (_r int32, _err error) {
  var _args156 ApplyRequestApplyRequestArgs
  _args156.Receiver = receiver
  _args156.FirstReceiver = firstReceiver
  _args156.Action = action
  _args156.ChainTesterId = chainTesterId
  var _result158 ApplyRequestApplyRequestResult
  var _meta157 thrift.ResponseMeta
  _meta157, _err = p.Client_().Call(ctx, "apply_request", &_args156, &_result158)
  p.SetLastResponseMeta_(_meta157)
  if _err != nil {
    return
  }
  return _result158.GetSuccess(), nil
}

// Parameters:
//  - ChainTesterId
func (p *ApplyRequestClient) ApplyEnd(ctx context.Context, chainTesterId int32) (_r int32, _err error) {
  var _args159 ApplyRequestApplyEndArgs
  _args159.ChainTesterId = chainTesterId
  var _result161 ApplyRequestApplyEndResult
  var _meta160 thrift.ResponseMeta
  _meta160, _err = p.Client_().Call(ctx, "apply_end", &_args159, &_result161)
  p.SetLastResponseMeta_(_meta160)
  if _err != nil {
    return
  }
  return _result161.GetSuccess(), nil
}

type ApplyRequestProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ApplyRequest
}

func (p *ApplyRequestProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyRequestProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyRequestProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyRequestProcessor(handler ApplyRequest) *ApplyRequestProcessor {

  self162 := &ApplyRequestProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self162.processorMap["apply_request"] = &applyRequestProcessorApplyRequest{handler:handler}
  self162.processorMap["apply_end"] = &applyRequestProcessorApplyEnd{handler:handler}
return self162
}

func (p *ApplyRequestProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x163 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x163.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x163

}

type applyRequestProcessorApplyRequest struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyRequestResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyRequest(ctx, args.Receiver, args.FirstReceiver, args.Action, args.ChainTesterId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_request: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_request", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyRequestProcessorApplyEnd struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyEndResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyEnd(ctx, args.ChainTesterId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Receiver
//  - FirstReceiver
//  - Action
//  - ChainTesterId
type ApplyRequestApplyRequestArgs struct {
  Receiver *Uint64 `thrift:"receiver,1" db:"receiver" json:"receiver"`
  FirstReceiver *Uint64 `thrift:"firstReceiver,2" db:"firstReceiver" json:"firstReceiver"`
  Action *Uint64 `thrift:"action,3" db:"action" json:"action"`
  ChainTesterId int32 `thrift:"chainTesterId,4" db:"chainTesterId" json:"chainTesterId"`
}

func NewApplyRequestApplyRequestArgs() *ApplyRequestApplyRequestArgs {
  return &ApplyRequestApplyRequestArgs{}
}

var ApplyRequestApplyRequestArgs_Receiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetReceiver() *Uint64 {
  if !p.IsSetReceiver() {
    return ApplyRequestApplyRequestArgs_Receiver_DEFAULT
  }
return p.Receiver
}
var ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetFirstReceiver() *Uint64 {
  if !p.IsSetFirstReceiver() {
    return ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT
  }
return p.FirstReceiver
}
var ApplyRequestApplyRequestArgs_Action_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetAction() *Uint64 {
  if !p.IsSetAction() {
    return ApplyRequestApplyRequestArgs_Action_DEFAULT
  }
return p.Action
}

func (p *ApplyRequestApplyRequestArgs) GetChainTesterId() int32 {
  return p.ChainTesterId
}
func (p *ApplyRequestApplyRequestArgs) IsSetReceiver() bool {
  return p.Receiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetFirstReceiver() bool {
  return p.FirstReceiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetAction() bool {
  return p.Action != nil
}

func (p *ApplyRequestApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Receiver = &Uint64{}
  if err := p.Receiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Receiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.FirstReceiver = &Uint64{}
  if err := p.FirstReceiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.FirstReceiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Action = &Uint64{}
  if err := p.Action.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Action), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ChainTesterId = v
}
  return nil
}

func (p *ApplyRequestApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "receiver", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:receiver: ", p), err) }
  if err := p.Receiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Receiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:receiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "firstReceiver", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:firstReceiver: ", p), err) }
  if err := p.FirstReceiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.FirstReceiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:firstReceiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := p.Action.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Action), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "chainTesterId", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:chainTesterId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ChainTesterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.chainTesterId (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:chainTesterId: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyRequestResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyRequestResult() *ApplyRequestApplyRequestResult {
  return &ApplyRequestApplyRequestResult{}
}

var ApplyRequestApplyRequestResult_Success_DEFAULT int32
func (p *ApplyRequestApplyRequestResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyRequestResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyRequestResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyRequestResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyRequestResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyRequestResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestResult(%+v)", *p)
}

// Attributes:
//  - ChainTesterId
type ApplyRequestApplyEndArgs struct {
  ChainTesterId int32 `thrift:"chainTesterId,1" db:"chainTesterId" json:"chainTesterId"`
}

func NewApplyRequestApplyEndArgs() *ApplyRequestApplyEndArgs {
  return &ApplyRequestApplyEndArgs{}
}


func (p *ApplyRequestApplyEndArgs) GetChainTesterId() int32 {
  return p.ChainTesterId
}
func (p *ApplyRequestApplyEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ChainTesterId = v
}
  return nil
}

func (p *ApplyRequestApplyEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "chainTesterId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:chainTesterId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ChainTesterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.chainTesterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:chainTesterId: ", p), err) }
  return err
}

func (p *ApplyRequestApplyEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyEndResult() *ApplyRequestApplyEndResult {
  return &ApplyRequestApplyEndResult{}
}

var ApplyRequestApplyEndResult_Success_DEFAULT int32
func (p *ApplyRequestApplyEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndResult(%+v)", *p)
}


type Apply interface {
  EndApply(ctx context.Context) (_r int32, _err error)
  GetActiveProducers(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - Account
  GetResourceLimits(ctx context.Context, account *Uint64) (_r *GetResourceLimitsReturn, _err error)
  // Parameters:
  //  - Account
  //  - RAMBytes
  //  - NetWeight
  //  - CPUWeight
  SetResourceLimits(ctx context.Context, account *Uint64, ram_bytes int64, net_weight int64, cpu_weight int64) (_err error)
  // Parameters:
  //  - ProducerData
  SetProposedProducers(ctx context.Context, producer_data []byte) (_r int64, _err error)
  // Parameters:
  //  - ProducerDataFormat
  //  - ProducerData
  SetProposedProducersEx(ctx context.Context, producer_data_format *Uint64, producer_data []byte) (_r int64, _err error)
  // Parameters:
  //  - Account
  IsPrivileged(ctx context.Context, account *Uint64) (_r bool, _err error)
  // Parameters:
  //  - Account
  //  - IsPriv
  SetPrivileged(ctx context.Context, account *Uint64, is_priv bool) (_err error)
  // Parameters:
  //  - Data
  SetBlockchainParametersPacked(ctx context.Context, data []byte) (_err error)
  GetBlockchainParametersPacked(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - FeatureDigest
  PreactivateFeature(ctx context.Context, feature_digest []byte) (_err error)
  // Parameters:
  //  - TrxData
  //  - PubkeysData
  //  - PermsData
  CheckTransactionAuthorization(ctx context.Context, trx_data []byte, pubkeys_data []byte, perms_data []byte) (_r int32, _err error)
  // Parameters:
  //  - Account
  //  - Permission
  //  - PubkeysData
  //  - PermsData
  //  - DelayUs
  CheckPermissionAuthorization(ctx context.Context, account *Uint64, permission *Uint64, pubkeys_data []byte, perms_data []byte, delay_us *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Account
  //  - Permission
  GetPermissionLastUsed(ctx context.Context, account *Uint64, permission *Uint64) (_r int64, _err error)
  // Parameters:
  //  - Account
  GetAccountCreationTime(ctx context.Context, account *Uint64) (_r int64, _err error)
  // Parameters:
  //  - Cstr
  Prints(ctx context.Context, cstr string) (_err error)
  // Parameters:
  //  - Cstr
  PrintsL(ctx context.Context, cstr []byte) (_err error)
  // Parameters:
  //  - N
  Printi(ctx context.Context, n int64) (_err error)
  // Parameters:
  //  - N
  Printui(ctx context.Context, n *Uint64) (_err error)
  // Parameters:
  //  - Value
  Printi128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printui128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printsf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printdf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printqf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Name
  Printn(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Data
  Printhex(ctx context.Context, data []byte) (_err error)
  ActionDataSize(ctx context.Context) (_r int32, _err error)
  ReadActionData(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - Name
  RequireRecipient(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  RequireAuth(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - Name
  //  - Permission
  RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error)
  // Parameters:
  //  - Name
  IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - SerializedAction
  SendInline(ctx context.Context, serialized_action []byte) (_err error)
  // Parameters:
  //  - SerializedData
  SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error)
  PublicationTime(ctx context.Context) (_r *Uint64, _err error)
  CurrentReceiver(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssert(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Code
  EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error)
  // Parameters:
  //  - Code
  EosioExit(ctx context.Context, code int32) (_err error)
  CurrentTime(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - FeatureDigest
  IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error)
  GetSender(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  Sha256(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha1(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha512(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  //  - Pub
  AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error)
  // Parameters:
  //  - SenderID
  //  - Payer
  //  - SerializedTransaction
  //  - ReplaceExisting
  SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error)
  // Parameters:
  //  - SenderID
  CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error)
  ReadTransaction(ctx context.Context) (_r []byte, _err error)
  TransactionSize(ctx context.Context) (_r int32, _err error)
  TaposBlockNum(ctx context.Context) (_r int32, _err error)
  TaposBlockPrefix(ctx context.Context) (_r int32, _err error)
  Expiration(ctx context.Context) (_r int64, _err error)
  // Parameters:
  //  - _type
  //  - Index
  GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Index
  GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbRemoveI64(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error)
  // Parameters:
  //  - Iterator
  DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iteratory
  DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Data
  SetActionReturnValue(ctx context.Context, data []byte) (_err error)
  // Parameters:
  //  - Account
  //  - StructVersion
  GetCodeHash(ctx context.Context, account *Uint64, struct_version int64) (_r []byte, _err error)
  GetBlockNum(ctx context.Context) (_r int64, _err error)
  // Parameters:
  //  - Data
  //  - Keccak
  Sha3(ctx context.Context, data []byte, keccak int32) (_r []byte, _err error)
  // Parameters:
  //  - Rounds
  //  - State
  //  - Msg
  //  - T0Offset
  //  - T1Offset
  //  - Final
  Blake2F(ctx context.Context, rounds int64, state []byte, msg []byte, t0_offset []byte, t1_offset []byte, final int32) (_r []byte, _err error)
  // Parameters:
  //  - Sig
  //  - Dig
  K1Recover(ctx context.Context, sig []byte, dig []byte) (_r []byte, _err error)
  // Parameters:
  //  - Op1
  //  - Op2
  AltBn128Add(ctx context.Context, op1 []byte, op2 []byte) (_r []byte, _err error)
  // Parameters:
  //  - G1
  //  - Scalar
  AltBn128Mul(ctx context.Context, g1 []byte, scalar []byte) (_r []byte, _err error)
  // Parameters:
  //  - Pairs
  AltBn128Pair(ctx context.Context, pairs []byte) (_r int32, _err error)
  // Parameters:
  //  - Base
  //  - Exp
  //  - Mod
  ModExp(ctx context.Context, base []byte, exp []byte, mod []byte) (_r []byte, _err error)
}

type ApplyClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyClient(c thrift.TClient) *ApplyClient {
  return &ApplyClient{
    c: c,
  }
}

func (p *ApplyClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *ApplyClient) EndApply(ctx context.Context) (_r int32, _err error) {
  var _args184 ApplyEndApplyArgs
  var _result186 ApplyEndApplyResult
  var _meta185 thrift.ResponseMeta
  _meta185, _err = p.Client_().Call(ctx, "end_apply", &_args184, &_result186)
  p.SetLastResponseMeta_(_meta185)
  if _err != nil {
    return
  }
  return _result186.GetSuccess(), nil
}

func (p *ApplyClient) GetActiveProducers(ctx context.Context) (_r []byte, _err error) {
  var _args187 ApplyGetActiveProducersArgs
  var _result189 ApplyGetActiveProducersResult
  var _meta188 thrift.ResponseMeta
  _meta188, _err = p.Client_().Call(ctx, "get_active_producers", &_args187, &_result189)
  p.SetLastResponseMeta_(_meta188)
  if _err != nil {
    return
  }
  return _result189.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) GetResourceLimits(ctx context.Context, account *Uint64) (_r *GetResourceLimitsReturn, _err error) {
  var _args190 ApplyGetResourceLimitsArgs
  _args190.Account = account
  var _result192 ApplyGetResourceLimitsResult
  var _meta191 thrift.ResponseMeta
  _meta191, _err = p.Client_().Call(ctx, "get_resource_limits", &_args190, &_result192)
  p.SetLastResponseMeta_(_meta191)
  if _err != nil {
    return
  }
  if _ret193 := _result192.GetSuccess(); _ret193 != nil {
    return _ret193, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get_resource_limits failed: unknown result")
}

// Parameters:
//  - Account
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
func (p *ApplyClient) SetResourceLimits(ctx context.Context, account *Uint64, ram_bytes int64, net_weight int64, cpu_weight int64) (_err error) {
  var _args194 ApplySetResourceLimitsArgs
  _args194.Account = account
  _args194.RAMBytes = ram_bytes
  _args194.NetWeight = net_weight
  _args194.CPUWeight = cpu_weight
  var _result196 ApplySetResourceLimitsResult
  var _meta195 thrift.ResponseMeta
  _meta195, _err = p.Client_().Call(ctx, "set_resource_limits", &_args194, &_result196)
  p.SetLastResponseMeta_(_meta195)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ProducerData
func (p *ApplyClient) SetProposedProducers(ctx context.Context, producer_data []byte) (_r int64, _err error) {
  var _args197 ApplySetProposedProducersArgs
  _args197.ProducerData = producer_data
  var _result199 ApplySetProposedProducersResult
  var _meta198 thrift.ResponseMeta
  _meta198, _err = p.Client_().Call(ctx, "set_proposed_producers", &_args197, &_result199)
  p.SetLastResponseMeta_(_meta198)
  if _err != nil {
    return
  }
  return _result199.GetSuccess(), nil
}

// Parameters:
//  - ProducerDataFormat
//  - ProducerData
func (p *ApplyClient) SetProposedProducersEx(ctx context.Context, producer_data_format *Uint64, producer_data []byte) (_r int64, _err error) {
  var _args200 ApplySetProposedProducersExArgs
  _args200.ProducerDataFormat = producer_data_format
  _args200.ProducerData = producer_data
  var _result202 ApplySetProposedProducersExResult
  var _meta201 thrift.ResponseMeta
  _meta201, _err = p.Client_().Call(ctx, "set_proposed_producers_ex", &_args200, &_result202)
  p.SetLastResponseMeta_(_meta201)
  if _err != nil {
    return
  }
  return _result202.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) IsPrivileged(ctx context.Context, account *Uint64) (_r bool, _err error) {
  var _args203 ApplyIsPrivilegedArgs
  _args203.Account = account
  var _result205 ApplyIsPrivilegedResult
  var _meta204 thrift.ResponseMeta
  _meta204, _err = p.Client_().Call(ctx, "is_privileged", &_args203, &_result205)
  p.SetLastResponseMeta_(_meta204)
  if _err != nil {
    return
  }
  return _result205.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - IsPriv
func (p *ApplyClient) SetPrivileged(ctx context.Context, account *Uint64, is_priv bool) (_err error) {
  var _args206 ApplySetPrivilegedArgs
  _args206.Account = account
  _args206.IsPriv = is_priv
  var _result208 ApplySetPrivilegedResult
  var _meta207 thrift.ResponseMeta
  _meta207, _err = p.Client_().Call(ctx, "set_privileged", &_args206, &_result208)
  p.SetLastResponseMeta_(_meta207)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) SetBlockchainParametersPacked(ctx context.Context, data []byte) (_err error) {
  var _args209 ApplySetBlockchainParametersPackedArgs
  _args209.Data = data
  var _result211 ApplySetBlockchainParametersPackedResult
  var _meta210 thrift.ResponseMeta
  _meta210, _err = p.Client_().Call(ctx, "set_blockchain_parameters_packed", &_args209, &_result211)
  p.SetLastResponseMeta_(_meta210)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) GetBlockchainParametersPacked(ctx context.Context) (_r []byte, _err error) {
  var _args212 ApplyGetBlockchainParametersPackedArgs
  var _result214 ApplyGetBlockchainParametersPackedResult
  var _meta213 thrift.ResponseMeta
  _meta213, _err = p.Client_().Call(ctx, "get_blockchain_parameters_packed", &_args212, &_result214)
  p.SetLastResponseMeta_(_meta213)
  if _err != nil {
    return
  }
  return _result214.GetSuccess(), nil
}

// Parameters:
//  - FeatureDigest
func (p *ApplyClient) PreactivateFeature(ctx context.Context, feature_digest []byte) (_err error) {
  var _args215 ApplyPreactivateFeatureArgs
  _args215.FeatureDigest = feature_digest
  var _result217 ApplyPreactivateFeatureResult
  var _meta216 thrift.ResponseMeta
  _meta216, _err = p.Client_().Call(ctx, "preactivate_feature", &_args215, &_result217)
  p.SetLastResponseMeta_(_meta216)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - TrxData
//  - PubkeysData
//  - PermsData
func (p *ApplyClient) CheckTransactionAuthorization(ctx context.Context, trx_data []byte, pubkeys_data []byte, perms_data []byte) (_r int32, _err error) {
  var _args218 ApplyCheckTransactionAuthorizationArgs
  _args218.TrxData = trx_data
  _args218.PubkeysData = pubkeys_data
  _args218.PermsData = perms_data
  var _result220 ApplyCheckTransactionAuthorizationResult
  var _meta219 thrift.ResponseMeta
  _meta219, _err = p.Client_().Call(ctx, "check_transaction_authorization", &_args218, &_result220)
  p.SetLastResponseMeta_(_meta219)
  if _err != nil {
    return
  }
  return _result220.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - Permission
//  - PubkeysData
//  - PermsData
//  - DelayUs
func (p *ApplyClient) CheckPermissionAuthorization(ctx context.Context, account *Uint64, permission *Uint64, pubkeys_data []byte, perms_data []byte, delay_us *Uint64) (_r int32, _err error) {
  var _args221 ApplyCheckPermissionAuthorizationArgs
  _args221.Account = account
  _args221.Permission = permission
  _args221.PubkeysData = pubkeys_data
  _args221.PermsData = perms_data
  _args221.DelayUs = delay_us
  var _result223 ApplyCheckPermissionAuthorizationResult
  var _meta222 thrift.ResponseMeta
  _meta222, _err = p.Client_().Call(ctx, "check_permission_authorization", &_args221, &_result223)
  p.SetLastResponseMeta_(_meta222)
  if _err != nil {
    return
  }
  return _result223.GetSuccess(), nil
}

// Parameters:
//  - Account
//  - Permission
func (p *ApplyClient) GetPermissionLastUsed(ctx context.Context, account *Uint64, permission *Uint64) (_r int64, _err error) {
  var _args224 ApplyGetPermissionLastUsedArgs
  _args224.Account = account
  _args224.Permission = permission
  var _result226 ApplyGetPermissionLastUsedResult
  var _meta225 thrift.ResponseMeta
  _meta225, _err = p.Client_().Call(ctx, "get_permission_last_used", &_args224, &_result226)
  p.SetLastResponseMeta_(_meta225)
  if _err != nil {
    return
  }
  return _result226.GetSuccess(), nil
}

// Parameters:
//  - Account
func (p *ApplyClient) GetAccountCreationTime(ctx context.Context, account *Uint64) (_r int64, _err error) {
  var _args227 ApplyGetAccountCreationTimeArgs
  _args227.Account = account
  var _result229 ApplyGetAccountCreationTimeResult
  var _meta228 thrift.ResponseMeta
  _meta228, _err = p.Client_().Call(ctx, "get_account_creation_time", &_args227, &_result229)
  p.SetLastResponseMeta_(_meta228)
  if _err != nil {
    return
  }
  return _result229.GetSuccess(), nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) Prints(ctx context.Context, cstr string) (_err error) {
  var _args230 ApplyPrintsArgs
  _args230.Cstr = cstr
  var _result232 ApplyPrintsResult
  var _meta231 thrift.ResponseMeta
  _meta231, _err = p.Client_().Call(ctx, "prints", &_args230, &_result232)
  p.SetLastResponseMeta_(_meta231)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) PrintsL(ctx context.Context, cstr []byte) (_err error) {
  var _args233 ApplyPrintsLArgs
  _args233.Cstr = cstr
  var _result235 ApplyPrintsLResult
  var _meta234 thrift.ResponseMeta
  _meta234, _err = p.Client_().Call(ctx, "prints_l", &_args233, &_result235)
  p.SetLastResponseMeta_(_meta234)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printi(ctx context.Context, n int64) (_err error) {
  var _args236 ApplyPrintiArgs
  _args236.N = n
  var _result238 ApplyPrintiResult
  var _meta237 thrift.ResponseMeta
  _meta237, _err = p.Client_().Call(ctx, "printi", &_args236, &_result238)
  p.SetLastResponseMeta_(_meta237)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printui(ctx context.Context, n *Uint64) (_err error) {
  var _args239 ApplyPrintuiArgs
  _args239.N = n
  var _result241 ApplyPrintuiResult
  var _meta240 thrift.ResponseMeta
  _meta240, _err = p.Client_().Call(ctx, "printui", &_args239, &_result241)
  p.SetLastResponseMeta_(_meta240)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printi128(ctx context.Context, value []byte) (_err error) {
  var _args242 ApplyPrinti128Args
  _args242.Value = value
  var _result244 ApplyPrinti128Result
  var _meta243 thrift.ResponseMeta
  _meta243, _err = p.Client_().Call(ctx, "printi128", &_args242, &_result244)
  p.SetLastResponseMeta_(_meta243)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printui128(ctx context.Context, value []byte) (_err error) {
  var _args245 ApplyPrintui128Args
  _args245.Value = value
  var _result247 ApplyPrintui128Result
  var _meta246 thrift.ResponseMeta
  _meta246, _err = p.Client_().Call(ctx, "printui128", &_args245, &_result247)
  p.SetLastResponseMeta_(_meta246)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printsf(ctx context.Context, value []byte) (_err error) {
  var _args248 ApplyPrintsfArgs
  _args248.Value = value
  var _result250 ApplyPrintsfResult
  var _meta249 thrift.ResponseMeta
  _meta249, _err = p.Client_().Call(ctx, "printsf", &_args248, &_result250)
  p.SetLastResponseMeta_(_meta249)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printdf(ctx context.Context, value []byte) (_err error) {
  var _args251 ApplyPrintdfArgs
  _args251.Value = value
  var _result253 ApplyPrintdfResult
  var _meta252 thrift.ResponseMeta
  _meta252, _err = p.Client_().Call(ctx, "printdf", &_args251, &_result253)
  p.SetLastResponseMeta_(_meta252)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printqf(ctx context.Context, value []byte) (_err error) {
  var _args254 ApplyPrintqfArgs
  _args254.Value = value
  var _result256 ApplyPrintqfResult
  var _meta255 thrift.ResponseMeta
  _meta255, _err = p.Client_().Call(ctx, "printqf", &_args254, &_result256)
  p.SetLastResponseMeta_(_meta255)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) Printn(ctx context.Context, name *Uint64) (_err error) {
  var _args257 ApplyPrintnArgs
  _args257.Name = name
  var _result259 ApplyPrintnResult
  var _meta258 thrift.ResponseMeta
  _meta258, _err = p.Client_().Call(ctx, "printn", &_args257, &_result259)
  p.SetLastResponseMeta_(_meta258)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Printhex(ctx context.Context, data []byte) (_err error) {
  var _args260 ApplyPrinthexArgs
  _args260.Data = data
  var _result262 ApplyPrinthexResult
  var _meta261 thrift.ResponseMeta
  _meta261, _err = p.Client_().Call(ctx, "printhex", &_args260, &_result262)
  p.SetLastResponseMeta_(_meta261)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) ActionDataSize(ctx context.Context) (_r int32, _err error) {
  var _args263 ApplyActionDataSizeArgs
  var _result265 ApplyActionDataSizeResult
  var _meta264 thrift.ResponseMeta
  _meta264, _err = p.Client_().Call(ctx, "action_data_size", &_args263, &_result265)
  p.SetLastResponseMeta_(_meta264)
  if _err != nil {
    return
  }
  return _result265.GetSuccess(), nil
}

func (p *ApplyClient) ReadActionData(ctx context.Context) (_r []byte, _err error) {
  var _args266 ApplyReadActionDataArgs
  var _result268 ApplyReadActionDataResult
  var _meta267 thrift.ResponseMeta
  _meta267, _err = p.Client_().Call(ctx, "read_action_data", &_args266, &_result268)
  p.SetLastResponseMeta_(_meta267)
  if _err != nil {
    return
  }
  return _result268.GetSuccess(), nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireRecipient(ctx context.Context, name *Uint64) (_err error) {
  var _args269 ApplyRequireRecipientArgs
  _args269.Name = name
  var _result271 ApplyRequireRecipientResult
  var _meta270 thrift.ResponseMeta
  _meta270, _err = p.Client_().Call(ctx, "require_recipient", &_args269, &_result271)
  p.SetLastResponseMeta_(_meta270)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireAuth(ctx context.Context, name *Uint64) (_err error) {
  var _args272 ApplyRequireAuthArgs
  _args272.Name = name
  var _result274 ApplyRequireAuthResult
  var _meta273 thrift.ResponseMeta
  _meta273, _err = p.Client_().Call(ctx, "require_auth", &_args272, &_result274)
  p.SetLastResponseMeta_(_meta273)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args275 ApplyHasAuthArgs
  _args275.Name = name
  var _result277 ApplyHasAuthResult
  var _meta276 thrift.ResponseMeta
  _meta276, _err = p.Client_().Call(ctx, "has_auth", &_args275, &_result277)
  p.SetLastResponseMeta_(_meta276)
  if _err != nil {
    return
  }
  return _result277.GetSuccess(), nil
}

// Parameters:
//  - Name
//  - Permission
func (p *ApplyClient) RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error) {
  var _args278 ApplyRequireAuth2Args
  _args278.Name = name
  _args278.Permission = permission
  var _result280 ApplyRequireAuth2Result
  var _meta279 thrift.ResponseMeta
  _meta279, _err = p.Client_().Call(ctx, "require_auth2", &_args278, &_result280)
  p.SetLastResponseMeta_(_meta279)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args281 ApplyIsAccountArgs
  _args281.Name = name
  var _result283 ApplyIsAccountResult
  var _meta282 thrift.ResponseMeta
  _meta282, _err = p.Client_().Call(ctx, "is_account", &_args281, &_result283)
  p.SetLastResponseMeta_(_meta282)
  if _err != nil {
    return
  }
  return _result283.GetSuccess(), nil
}

// Parameters:
//  - SerializedAction
func (p *ApplyClient) SendInline(ctx context.Context, serialized_action []byte) (_err error) {
  var _args284 ApplySendInlineArgs
  _args284.SerializedAction = serialized_action
  var _result286 ApplySendInlineResult
  var _meta285 thrift.ResponseMeta
  _meta285, _err = p.Client_().Call(ctx, "send_inline", &_args284, &_result286)
  p.SetLastResponseMeta_(_meta285)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SerializedData
func (p *ApplyClient) SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error) {
  var _args287 ApplySendContextFreeInlineArgs
  _args287.SerializedData = serialized_data
  var _result289 ApplySendContextFreeInlineResult
  var _meta288 thrift.ResponseMeta
  _meta288, _err = p.Client_().Call(ctx, "send_context_free_inline", &_args287, &_result289)
  p.SetLastResponseMeta_(_meta288)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) PublicationTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args290 ApplyPublicationTimeArgs
  var _result292 ApplyPublicationTimeResult
  var _meta291 thrift.ResponseMeta
  _meta291, _err = p.Client_().Call(ctx, "publication_time", &_args290, &_result292)
  p.SetLastResponseMeta_(_meta291)
  if _err != nil {
    return
  }
  if _ret293 := _result292.GetSuccess(); _ret293 != nil {
    return _ret293, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "publication_time failed: unknown result")
}

func (p *ApplyClient) CurrentReceiver(ctx context.Context) (_r *Uint64, _err error) {
  var _args294 ApplyCurrentReceiverArgs
  var _result296 ApplyCurrentReceiverResult
  var _meta295 thrift.ResponseMeta
  _meta295, _err = p.Client_().Call(ctx, "current_receiver", &_args294, &_result296)
  p.SetLastResponseMeta_(_meta295)
  if _err != nil {
    return
  }
  if _ret297 := _result296.GetSuccess(); _ret297 != nil {
    return _ret297, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_receiver failed: unknown result")
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssert(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args298 ApplyEosioAssertArgs
  _args298.Test = test
  _args298.Msg = msg
  var _result300 ApplyEosioAssertResult
  var _meta299 thrift.ResponseMeta
  _meta299, _err = p.Client_().Call(ctx, "eosio_assert", &_args298, &_result300)
  p.SetLastResponseMeta_(_meta299)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args301 ApplyEosioAssertMessageArgs
  _args301.Test = test
  _args301.Msg = msg
  var _result303 ApplyEosioAssertMessageResult
  var _meta302 thrift.ResponseMeta
  _meta302, _err = p.Client_().Call(ctx, "eosio_assert_message", &_args301, &_result303)
  p.SetLastResponseMeta_(_meta302)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Code
func (p *ApplyClient) EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error) {
  var _args304 ApplyEosioAssertCodeArgs
  _args304.Test = test
  _args304.Code = code
  var _result306 ApplyEosioAssertCodeResult
  var _meta305 thrift.ResponseMeta
  _meta305, _err = p.Client_().Call(ctx, "eosio_assert_code", &_args304, &_result306)
  p.SetLastResponseMeta_(_meta305)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Code
func (p *ApplyClient) EosioExit(ctx context.Context, code int32) (_err error) {
  var _args307 ApplyEosioExitArgs
  _args307.Code = code
  var _result309 ApplyEosioExitResult
  var _meta308 thrift.ResponseMeta
  _meta308, _err = p.Client_().Call(ctx, "eosio_exit", &_args307, &_result309)
  p.SetLastResponseMeta_(_meta308)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) CurrentTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args310 ApplyCurrentTimeArgs
  var _result312 ApplyCurrentTimeResult
  var _meta311 thrift.ResponseMeta
  _meta311, _err = p.Client_().Call(ctx, "current_time", &_args310, &_result312)
  p.SetLastResponseMeta_(_meta311)
  if _err != nil {
    return
  }
  if _ret313 := _result312.GetSuccess(); _ret313 != nil {
    return _ret313, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_time failed: unknown result")
}

// Parameters:
//  - FeatureDigest
func (p *ApplyClient) IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error) {
  var _args314 ApplyIsFeatureActivatedArgs
  _args314.FeatureDigest = feature_digest
  var _result316 ApplyIsFeatureActivatedResult
  var _meta315 thrift.ResponseMeta
  _meta315, _err = p.Client_().Call(ctx, "is_feature_activated", &_args314, &_result316)
  p.SetLastResponseMeta_(_meta315)
  if _err != nil {
    return
  }
  return _result316.GetSuccess(), nil
}

func (p *ApplyClient) GetSender(ctx context.Context) (_r *Uint64, _err error) {
  var _args317 ApplyGetSenderArgs
  var _result319 ApplyGetSenderResult
  var _meta318 thrift.ResponseMeta
  _meta318, _err = p.Client_().Call(ctx, "get_sender", &_args317, &_result319)
  p.SetLastResponseMeta_(_meta318)
  if _err != nil {
    return
  }
  if _ret320 := _result319.GetSuccess(); _ret320 != nil {
    return _ret320, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get_sender failed: unknown result")
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args321 ApplyAssertSha256Args
  _args321.Data = data
  _args321.Hash = hash
  var _result323 ApplyAssertSha256Result
  var _meta322 thrift.ResponseMeta
  _meta322, _err = p.Client_().Call(ctx, "assert_sha256", &_args321, &_result323)
  p.SetLastResponseMeta_(_meta322)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args324 ApplyAssertSha1Args
  _args324.Data = data
  _args324.Hash = hash
  var _result326 ApplyAssertSha1Result
  var _meta325 thrift.ResponseMeta
  _meta325, _err = p.Client_().Call(ctx, "assert_sha1", &_args324, &_result326)
  p.SetLastResponseMeta_(_meta325)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args327 ApplyAssertSha512Args
  _args327.Data = data
  _args327.Hash = hash
  var _result329 ApplyAssertSha512Result
  var _meta328 thrift.ResponseMeta
  _meta328, _err = p.Client_().Call(ctx, "assert_sha512", &_args327, &_result329)
  p.SetLastResponseMeta_(_meta328)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args330 ApplyAssertRipemd160Args
  _args330.Data = data
  _args330.Hash = hash
  var _result332 ApplyAssertRipemd160Result
  var _meta331 thrift.ResponseMeta
  _meta331, _err = p.Client_().Call(ctx, "assert_ripemd160", &_args330, &_result332)
  p.SetLastResponseMeta_(_meta331)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha256(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args333 ApplySha256Args
  _args333.Data = data
  var _result335 ApplySha256Result
  var _meta334 thrift.ResponseMeta
  _meta334, _err = p.Client_().Call(ctx, "sha256", &_args333, &_result335)
  p.SetLastResponseMeta_(_meta334)
  if _err != nil {
    return
  }
  return _result335.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha1(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args336 ApplySha1Args
  _args336.Data = data
  var _result338 ApplySha1Result
  var _meta337 thrift.ResponseMeta
  _meta337, _err = p.Client_().Call(ctx, "sha1", &_args336, &_result338)
  p.SetLastResponseMeta_(_meta337)
  if _err != nil {
    return
  }
  return _result338.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha512(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args339 ApplySha512Args
  _args339.Data = data
  var _result341 ApplySha512Result
  var _meta340 thrift.ResponseMeta
  _meta340, _err = p.Client_().Call(ctx, "sha512", &_args339, &_result341)
  p.SetLastResponseMeta_(_meta340)
  if _err != nil {
    return
  }
  return _result341.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args342 ApplyRipemd160Args
  _args342.Data = data
  var _result344 ApplyRipemd160Result
  var _meta343 thrift.ResponseMeta
  _meta343, _err = p.Client_().Call(ctx, "ripemd160", &_args342, &_result344)
  p.SetLastResponseMeta_(_meta343)
  if _err != nil {
    return
  }
  return _result344.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
func (p *ApplyClient) RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error) {
  var _args345 ApplyRecoverKeyArgs
  _args345.Digest = digest
  _args345.Sig = sig
  var _result347 ApplyRecoverKeyResult
  var _meta346 thrift.ResponseMeta
  _meta346, _err = p.Client_().Call(ctx, "recover_key", &_args345, &_result347)
  p.SetLastResponseMeta_(_meta346)
  if _err != nil {
    return
  }
  return _result347.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
//  - Pub
func (p *ApplyClient) AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error) {
  var _args348 ApplyAssertRecoverKeyArgs
  _args348.Digest = digest
  _args348.Sig = sig
  _args348.Pub = pub
  var _result350 ApplyAssertRecoverKeyResult
  var _meta349 thrift.ResponseMeta
  _meta349, _err = p.Client_().Call(ctx, "assert_recover_key", &_args348, &_result350)
  p.SetLastResponseMeta_(_meta349)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
func (p *ApplyClient) SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error) {
  var _args351 ApplySendDeferredArgs
  _args351.SenderID = sender_id
  _args351.Payer = payer
  _args351.SerializedTransaction = serialized_transaction
  _args351.ReplaceExisting = replace_existing
  var _result353 ApplySendDeferredResult
  var _meta352 thrift.ResponseMeta
  _meta352, _err = p.Client_().Call(ctx, "send_deferred", &_args351, &_result353)
  p.SetLastResponseMeta_(_meta352)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
func (p *ApplyClient) CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error) {
  var _args354 ApplyCancelDeferredArgs
  _args354.SenderID = sender_id
  var _result356 ApplyCancelDeferredResult
  var _meta355 thrift.ResponseMeta
  _meta355, _err = p.Client_().Call(ctx, "cancel_deferred", &_args354, &_result356)
  p.SetLastResponseMeta_(_meta355)
  if _err != nil {
    return
  }
  return _result356.GetSuccess(), nil
}

func (p *ApplyClient) ReadTransaction(ctx context.Context) (_r []byte, _err error) {
  var _args357 ApplyReadTransactionArgs
  var _result359 ApplyReadTransactionResult
  var _meta358 thrift.ResponseMeta
  _meta358, _err = p.Client_().Call(ctx, "read_transaction", &_args357, &_result359)
  p.SetLastResponseMeta_(_meta358)
  if _err != nil {
    return
  }
  return _result359.GetSuccess(), nil
}

func (p *ApplyClient) TransactionSize(ctx context.Context) (_r int32, _err error) {
  var _args360 ApplyTransactionSizeArgs
  var _result362 ApplyTransactionSizeResult
  var _meta361 thrift.ResponseMeta
  _meta361, _err = p.Client_().Call(ctx, "transaction_size", &_args360, &_result362)
  p.SetLastResponseMeta_(_meta361)
  if _err != nil {
    return
  }
  return _result362.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockNum(ctx context.Context) (_r int32, _err error) {
  var _args363 ApplyTaposBlockNumArgs
  var _result365 ApplyTaposBlockNumResult
  var _meta364 thrift.ResponseMeta
  _meta364, _err = p.Client_().Call(ctx, "tapos_block_num", &_args363, &_result365)
  p.SetLastResponseMeta_(_meta364)
  if _err != nil {
    return
  }
  return _result365.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockPrefix(ctx context.Context) (_r int32, _err error) {
  var _args366 ApplyTaposBlockPrefixArgs
  var _result368 ApplyTaposBlockPrefixResult
  var _meta367 thrift.ResponseMeta
  _meta367, _err = p.Client_().Call(ctx, "tapos_block_prefix", &_args366, &_result368)
  p.SetLastResponseMeta_(_meta367)
  if _err != nil {
    return
  }
  return _result368.GetSuccess(), nil
}

func (p *ApplyClient) Expiration(ctx context.Context) (_r int64, _err error) {
  var _args369 ApplyExpirationArgs
  var _result371 ApplyExpirationResult
  var _meta370 thrift.ResponseMeta
  _meta370, _err = p.Client_().Call(ctx, "expiration", &_args369, &_result371)
  p.SetLastResponseMeta_(_meta370)
  if _err != nil {
    return
  }
  return _result371.GetSuccess(), nil
}

// Parameters:
//  - _type
//  - Index
func (p *ApplyClient) GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error) {
  var _args372 ApplyGetActionArgs
  _args372._type = _type
  _args372.Index = index
  var _result374 ApplyGetActionResult
  var _meta373 thrift.ResponseMeta
  _meta373, _err = p.Client_().Call(ctx, "get_action", &_args372, &_result374)
  p.SetLastResponseMeta_(_meta373)
  if _err != nil {
    return
  }
  return _result374.GetSuccess(), nil
}

// Parameters:
//  - Index
func (p *ApplyClient) GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error) {
  var _args375 ApplyGetContextFreeDataArgs
  _args375.Index = index
  var _result377 ApplyGetContextFreeDataResult
  var _meta376 thrift.ResponseMeta
  _meta376, _err = p.Client_().Call(ctx, "get_context_free_data", &_args375, &_result377)
  p.SetLastResponseMeta_(_meta376)
  if _err != nil {
    return
  }
  return _result377.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args378 ApplyDbStoreI64Args
  _args378.Scope = scope
  _args378.Table = table
  _args378.Payer = payer
  _args378.ID = id
  _args378.Data = data
  var _result380 ApplyDbStoreI64Result
  var _meta379 thrift.ResponseMeta
  _meta379, _err = p.Client_().Call(ctx, "db_store_i64", &_args378, &_result380)
  p.SetLastResponseMeta_(_meta379)
  if _err != nil {
    return
  }
  return _result380.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args381 ApplyDbUpdateI64Args
  _args381.Iterator = iterator
  _args381.Payer = payer
  _args381.Data = data
  var _result383 ApplyDbUpdateI64Result
  var _meta382 thrift.ResponseMeta
  _meta382, _err = p.Client_().Call(ctx, "db_update_i64", &_args381, &_result383)
  p.SetLastResponseMeta_(_meta382)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbRemoveI64(ctx context.Context, iterator int32) (_err error) {
  var _args384 ApplyDbRemoveI64Args
  _args384.Iterator = iterator
  var _result386 ApplyDbRemoveI64Result
  var _meta385 thrift.ResponseMeta
  _meta385, _err = p.Client_().Call(ctx, "db_remove_i64", &_args384, &_result386)
  p.SetLastResponseMeta_(_meta385)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error) {
  var _args387 ApplyDbGetI64Args
  _args387.Iterator = iterator
  var _result389 ApplyDbGetI64Result
  var _meta388 thrift.ResponseMeta
  _meta388, _err = p.Client_().Call(ctx, "db_get_i64", &_args387, &_result389)
  p.SetLastResponseMeta_(_meta388)
  if _err != nil {
    return
  }
  return _result389.GetSuccess(), nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args390 ApplyDbNextI64Args
  _args390.Iterator = iterator
  var _result392 ApplyDbNextI64Result
  var _meta391 thrift.ResponseMeta
  _meta391, _err = p.Client_().Call(ctx, "db_next_i64", &_args390, &_result392)
  p.SetLastResponseMeta_(_meta391)
  if _err != nil {
    return
  }
  if _ret393 := _result392.GetSuccess(); _ret393 != nil {
    return _ret393, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_next_i64 failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args394 ApplyDbPreviousI64Args
  _args394.Iterator = iterator
  var _result396 ApplyDbPreviousI64Result
  var _meta395 thrift.ResponseMeta
  _meta395, _err = p.Client_().Call(ctx, "db_previous_i64", &_args394, &_result396)
  p.SetLastResponseMeta_(_meta395)
  if _err != nil {
    return
  }
  if _ret397 := _result396.GetSuccess(); _ret397 != nil {
    return _ret397, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_previous_i64 failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args398 ApplyDbFindI64Args
  _args398.Code = code
  _args398.Scope = scope
  _args398.Table = table
  _args398.ID = id
  var _result400 ApplyDbFindI64Result
  var _meta399 thrift.ResponseMeta
  _meta399, _err = p.Client_().Call(ctx, "db_find_i64", &_args398, &_result400)
  p.SetLastResponseMeta_(_meta399)
  if _err != nil {
    return
  }
  return _result400.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args401 ApplyDbLowerboundI64Args
  _args401.Code = code
  _args401.Scope = scope
  _args401.Table = table
  _args401.ID = id
  var _result403 ApplyDbLowerboundI64Result
  var _meta402 thrift.ResponseMeta
  _meta402, _err = p.Client_().Call(ctx, "db_lowerbound_i64", &_args401, &_result403)
  p.SetLastResponseMeta_(_meta402)
  if _err != nil {
    return
  }
  return _result403.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args404 ApplyDbUpperboundI64Args
  _args404.Code = code
  _args404.Scope = scope
  _args404.Table = table
  _args404.ID = id
  var _result406 ApplyDbUpperboundI64Result
  var _meta405 thrift.ResponseMeta
  _meta405, _err = p.Client_().Call(ctx, "db_upperbound_i64", &_args404, &_result406)
  p.SetLastResponseMeta_(_meta405)
  if _err != nil {
    return
  }
  return _result406.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args407 ApplyDbEndI64Args
  _args407.Code = code
  _args407.Scope = scope
  _args407.Table = table
  var _result409 ApplyDbEndI64Result
  var _meta408 thrift.ResponseMeta
  _meta408, _err = p.Client_().Call(ctx, "db_end_i64", &_args407, &_result409)
  p.SetLastResponseMeta_(_meta408)
  if _err != nil {
    return
  }
  return _result409.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error) {
  var _args410 ApplyDbIdx64StoreArgs
  _args410.Scope = scope
  _args410.Table = table
  _args410.Payer = payer
  _args410.ID = id
  _args410.Secondary = secondary
  var _result412 ApplyDbIdx64StoreResult
  var _meta411 thrift.ResponseMeta
  _meta411, _err = p.Client_().Call(ctx, "db_idx64_store", &_args410, &_result412)
  p.SetLastResponseMeta_(_meta411)
  if _err != nil {
    return
  }
  return _result412.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error) {
  var _args413 ApplyDbIdx64UpdateArgs
  _args413.Iterator = iterator
  _args413.Payer = payer
  _args413.Secondary = secondary
  var _result415 ApplyDbIdx64UpdateResult
  var _meta414 thrift.ResponseMeta
  _meta414, _err = p.Client_().Call(ctx, "db_idx64_update", &_args413, &_result415)
  p.SetLastResponseMeta_(_meta414)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Remove(ctx context.Context, iterator int32) (_err error) {
  var _args416 ApplyDbIdx64RemoveArgs
  _args416.Iterator = iterator
  var _result418 ApplyDbIdx64RemoveResult
  var _meta417 thrift.ResponseMeta
  _meta417, _err = p.Client_().Call(ctx, "db_idx64_remove", &_args416, &_result418)
  p.SetLastResponseMeta_(_meta417)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args419 ApplyDbIdx64NextArgs
  _args419.Iterator = iterator
  var _result421 ApplyDbIdx64NextResult
  var _meta420 thrift.ResponseMeta
  _meta420, _err = p.Client_().Call(ctx, "db_idx64_next", &_args419, &_result421)
  p.SetLastResponseMeta_(_meta420)
  if _err != nil {
    return
  }
  if _ret422 := _result421.GetSuccess(); _ret422 != nil {
    return _ret422, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_next failed: unknown result")
}

// Parameters:
//  - Iteratory
func (p *ApplyClient) DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error) {
  var _args423 ApplyDbIdx64PreviousArgs
  _args423.Iteratory = iteratory
  var _result425 ApplyDbIdx64PreviousResult
  var _meta424 thrift.ResponseMeta
  _meta424, _err = p.Client_().Call(ctx, "db_idx64_previous", &_args423, &_result425)
  p.SetLastResponseMeta_(_meta424)
  if _err != nil {
    return
  }
  if _ret426 := _result425.GetSuccess(); _ret426 != nil {
    return _ret426, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args427 ApplyDbIdx64FindPrimaryArgs
  _args427.Code = code
  _args427.Scope = scope
  _args427.Table = table
  _args427.Primary = primary
  var _result429 ApplyDbIdx64FindPrimaryResult
  var _meta428 thrift.ResponseMeta
  _meta428, _err = p.Client_().Call(ctx, "db_idx64_find_primary", &_args427, &_result429)
  p.SetLastResponseMeta_(_meta428)
  if _err != nil {
    return
  }
  if _ret430 := _result429.GetSuccess(); _ret430 != nil {
    return _ret430, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error) {
  var _args431 ApplyDbIdx64FindSecondaryArgs
  _args431.Code = code
  _args431.Scope = scope
  _args431.Table = table
  _args431.Secondary = secondary
  var _result433 ApplyDbIdx64FindSecondaryResult
  var _meta432 thrift.ResponseMeta
  _meta432, _err = p.Client_().Call(ctx, "db_idx64_find_secondary", &_args431, &_result433)
  p.SetLastResponseMeta_(_meta432)
  if _err != nil {
    return
  }
  if _ret434 := _result433.GetSuccess(); _ret434 != nil {
    return _ret434, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args435 ApplyDbIdx64LowerboundArgs
  _args435.Code = code
  _args435.Scope = scope
  _args435.Table = table
  _args435.Secondary = secondary
  _args435.Primary = primary
  var _result437 ApplyDbIdx64LowerboundResult
  var _meta436 thrift.ResponseMeta
  _meta436, _err = p.Client_().Call(ctx, "db_idx64_lowerbound", &_args435, &_result437)
  p.SetLastResponseMeta_(_meta436)
  if _err != nil {
    return
  }
  if _ret438 := _result437.GetSuccess(); _ret438 != nil {
    return _ret438, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args439 ApplyDbIdx64UpperboundArgs
  _args439.Code = code
  _args439.Scope = scope
  _args439.Table = table
  _args439.Secondary = secondary
  _args439.Primary = primary
  var _result441 ApplyDbIdx64UpperboundResult
  var _meta440 thrift.ResponseMeta
  _meta440, _err = p.Client_().Call(ctx, "db_idx64_upperbound", &_args439, &_result441)
  p.SetLastResponseMeta_(_meta440)
  if _err != nil {
    return
  }
  if _ret442 := _result441.GetSuccess(); _ret442 != nil {
    return _ret442, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args443 ApplyDbIdx64EndArgs
  _args443.Code = code
  _args443.Scope = scope
  _args443.Table = table
  var _result445 ApplyDbIdx64EndResult
  var _meta444 thrift.ResponseMeta
  _meta444, _err = p.Client_().Call(ctx, "db_idx64_end", &_args443, &_result445)
  p.SetLastResponseMeta_(_meta444)
  if _err != nil {
    return
  }
  return _result445.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args446 ApplyDbIdx128StoreArgs
  _args446.Scope = scope
  _args446.Table = table
  _args446.Payer = payer
  _args446.ID = id
  _args446.Secondary = secondary
  var _result448 ApplyDbIdx128StoreResult
  var _meta447 thrift.ResponseMeta
  _meta447, _err = p.Client_().Call(ctx, "db_idx128_store", &_args446, &_result448)
  p.SetLastResponseMeta_(_meta447)
  if _err != nil {
    return
  }
  return _result448.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args449 ApplyDbIdx128UpdateArgs
  _args449.Iterator = iterator
  _args449.Payer = payer
  _args449.Secondary = secondary
  var _result451 ApplyDbIdx128UpdateResult
  var _meta450 thrift.ResponseMeta
  _meta450, _err = p.Client_().Call(ctx, "db_idx128_update", &_args449, &_result451)
  p.SetLastResponseMeta_(_meta450)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Remove(ctx context.Context, iterator int32) (_err error) {
  var _args452 ApplyDbIdx128RemoveArgs
  _args452.Iterator = iterator
  var _result454 ApplyDbIdx128RemoveResult
  var _meta453 thrift.ResponseMeta
  _meta453, _err = p.Client_().Call(ctx, "db_idx128_remove", &_args452, &_result454)
  p.SetLastResponseMeta_(_meta453)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args455 ApplyDbIdx128NextArgs
  _args455.Iterator = iterator
  var _result457 ApplyDbIdx128NextResult
  var _meta456 thrift.ResponseMeta
  _meta456, _err = p.Client_().Call(ctx, "db_idx128_next", &_args455, &_result457)
  p.SetLastResponseMeta_(_meta456)
  if _err != nil {
    return
  }
  if _ret458 := _result457.GetSuccess(); _ret458 != nil {
    return _ret458, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args459 ApplyDbIdx128PreviousArgs
  _args459.Iterator = iterator
  var _result461 ApplyDbIdx128PreviousResult
  var _meta460 thrift.ResponseMeta
  _meta460, _err = p.Client_().Call(ctx, "db_idx128_previous", &_args459, &_result461)
  p.SetLastResponseMeta_(_meta460)
  if _err != nil {
    return
  }
  if _ret462 := _result461.GetSuccess(); _ret462 != nil {
    return _ret462, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args463 ApplyDbIdx128FindPrimaryArgs
  _args463.Code = code
  _args463.Scope = scope
  _args463.Table = table
  _args463.Primary = primary
  var _result465 ApplyDbIdx128FindPrimaryResult
  var _meta464 thrift.ResponseMeta
  _meta464, _err = p.Client_().Call(ctx, "db_idx128_find_primary", &_args463, &_result465)
  p.SetLastResponseMeta_(_meta464)
  if _err != nil {
    return
  }
  if _ret466 := _result465.GetSuccess(); _ret466 != nil {
    return _ret466, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args467 ApplyDbIdx128FindSecondaryArgs
  _args467.Code = code
  _args467.Scope = scope
  _args467.Table = table
  _args467.Secondary = secondary
  var _result469 ApplyDbIdx128FindSecondaryResult
  var _meta468 thrift.ResponseMeta
  _meta468, _err = p.Client_().Call(ctx, "db_idx128_find_secondary", &_args467, &_result469)
  p.SetLastResponseMeta_(_meta468)
  if _err != nil {
    return
  }
  if _ret470 := _result469.GetSuccess(); _ret470 != nil {
    return _ret470, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args471 ApplyDbIdx128LowerboundArgs
  _args471.Code = code
  _args471.Scope = scope
  _args471.Table = table
  _args471.Secondary = secondary
  _args471.Primary = primary
  var _result473 ApplyDbIdx128LowerboundResult
  var _meta472 thrift.ResponseMeta
  _meta472, _err = p.Client_().Call(ctx, "db_idx128_lowerbound", &_args471, &_result473)
  p.SetLastResponseMeta_(_meta472)
  if _err != nil {
    return
  }
  if _ret474 := _result473.GetSuccess(); _ret474 != nil {
    return _ret474, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args475 ApplyDbIdx128UpperboundArgs
  _args475.Code = code
  _args475.Scope = scope
  _args475.Table = table
  _args475.Secondary = secondary
  _args475.Primary = primary
  var _result477 ApplyDbIdx128UpperboundResult
  var _meta476 thrift.ResponseMeta
  _meta476, _err = p.Client_().Call(ctx, "db_idx128_upperbound", &_args475, &_result477)
  p.SetLastResponseMeta_(_meta476)
  if _err != nil {
    return
  }
  if _ret478 := _result477.GetSuccess(); _ret478 != nil {
    return _ret478, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args479 ApplyDbIdx128EndArgs
  _args479.Code = code
  _args479.Scope = scope
  _args479.Table = table
  var _result481 ApplyDbIdx128EndResult
  var _meta480 thrift.ResponseMeta
  _meta480, _err = p.Client_().Call(ctx, "db_idx128_end", &_args479, &_result481)
  p.SetLastResponseMeta_(_meta480)
  if _err != nil {
    return
  }
  return _result481.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args482 ApplyDbIdx256StoreArgs
  _args482.Scope = scope
  _args482.Table = table
  _args482.Payer = payer
  _args482.ID = id
  _args482.Data = data
  var _result484 ApplyDbIdx256StoreResult
  var _meta483 thrift.ResponseMeta
  _meta483, _err = p.Client_().Call(ctx, "db_idx256_store", &_args482, &_result484)
  p.SetLastResponseMeta_(_meta483)
  if _err != nil {
    return
  }
  return _result484.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args485 ApplyDbIdx256UpdateArgs
  _args485.Iterator = iterator
  _args485.Payer = payer
  _args485.Data = data
  var _result487 ApplyDbIdx256UpdateResult
  var _meta486 thrift.ResponseMeta
  _meta486, _err = p.Client_().Call(ctx, "db_idx256_update", &_args485, &_result487)
  p.SetLastResponseMeta_(_meta486)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Remove(ctx context.Context, iterator int32) (_err error) {
  var _args488 ApplyDbIdx256RemoveArgs
  _args488.Iterator = iterator
  var _result490 ApplyDbIdx256RemoveResult
  var _meta489 thrift.ResponseMeta
  _meta489, _err = p.Client_().Call(ctx, "db_idx256_remove", &_args488, &_result490)
  p.SetLastResponseMeta_(_meta489)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args491 ApplyDbIdx256NextArgs
  _args491.Iterator = iterator
  var _result493 ApplyDbIdx256NextResult
  var _meta492 thrift.ResponseMeta
  _meta492, _err = p.Client_().Call(ctx, "db_idx256_next", &_args491, &_result493)
  p.SetLastResponseMeta_(_meta492)
  if _err != nil {
    return
  }
  if _ret494 := _result493.GetSuccess(); _ret494 != nil {
    return _ret494, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args495 ApplyDbIdx256PreviousArgs
  _args495.Iterator = iterator
  var _result497 ApplyDbIdx256PreviousResult
  var _meta496 thrift.ResponseMeta
  _meta496, _err = p.Client_().Call(ctx, "db_idx256_previous", &_args495, &_result497)
  p.SetLastResponseMeta_(_meta496)
  if _err != nil {
    return
  }
  if _ret498 := _result497.GetSuccess(); _ret498 != nil {
    return _ret498, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args499 ApplyDbIdx256FindPrimaryArgs
  _args499.Code = code
  _args499.Scope = scope
  _args499.Table = table
  _args499.Primary = primary
  var _result501 ApplyDbIdx256FindPrimaryResult
  var _meta500 thrift.ResponseMeta
  _meta500, _err = p.Client_().Call(ctx, "db_idx256_find_primary", &_args499, &_result501)
  p.SetLastResponseMeta_(_meta500)
  if _err != nil {
    return
  }
  if _ret502 := _result501.GetSuccess(); _ret502 != nil {
    return _ret502, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
func (p *ApplyClient) DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error) {
  var _args503 ApplyDbIdx256FindSecondaryArgs
  _args503.Code = code
  _args503.Scope = scope
  _args503.Table = table
  _args503.Data = data
  var _result505 ApplyDbIdx256FindSecondaryResult
  var _meta504 thrift.ResponseMeta
  _meta504, _err = p.Client_().Call(ctx, "db_idx256_find_secondary", &_args503, &_result505)
  p.SetLastResponseMeta_(_meta504)
  if _err != nil {
    return
  }
  if _ret506 := _result505.GetSuccess(); _ret506 != nil {
    return _ret506, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args507 ApplyDbIdx256LowerboundArgs
  _args507.Code = code
  _args507.Scope = scope
  _args507.Table = table
  _args507.Data = data
  _args507.Primary = primary
  var _result509 ApplyDbIdx256LowerboundResult
  var _meta508 thrift.ResponseMeta
  _meta508, _err = p.Client_().Call(ctx, "db_idx256_lowerbound", &_args507, &_result509)
  p.SetLastResponseMeta_(_meta508)
  if _err != nil {
    return
  }
  if _ret510 := _result509.GetSuccess(); _ret510 != nil {
    return _ret510, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args511 ApplyDbIdx256UpperboundArgs
  _args511.Code = code
  _args511.Scope = scope
  _args511.Table = table
  _args511.Data = data
  _args511.Primary = primary
  var _result513 ApplyDbIdx256UpperboundResult
  var _meta512 thrift.ResponseMeta
  _meta512, _err = p.Client_().Call(ctx, "db_idx256_upperbound", &_args511, &_result513)
  p.SetLastResponseMeta_(_meta512)
  if _err != nil {
    return
  }
  if _ret514 := _result513.GetSuccess(); _ret514 != nil {
    return _ret514, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args515 ApplyDbIdx256EndArgs
  _args515.Code = code
  _args515.Scope = scope
  _args515.Table = table
  var _result517 ApplyDbIdx256EndResult
  var _meta516 thrift.ResponseMeta
  _meta516, _err = p.Client_().Call(ctx, "db_idx256_end", &_args515, &_result517)
  p.SetLastResponseMeta_(_meta516)
  if _err != nil {
    return
  }
  return _result517.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args518 ApplyDbIdxDoubleStoreArgs
  _args518.Scope = scope
  _args518.Table = table
  _args518.Payer = payer
  _args518.ID = id
  _args518.Secondary = secondary
  var _result520 ApplyDbIdxDoubleStoreResult
  var _meta519 thrift.ResponseMeta
  _meta519, _err = p.Client_().Call(ctx, "db_idx_double_store", &_args518, &_result520)
  p.SetLastResponseMeta_(_meta519)
  if _err != nil {
    return
  }
  return _result520.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args521 ApplyDbIdxDoubleUpdateArgs
  _args521.Iterator = iterator
  _args521.Payer = payer
  _args521.Secondary = secondary
  var _result523 ApplyDbIdxDoubleUpdateResult
  var _meta522 thrift.ResponseMeta
  _meta522, _err = p.Client_().Call(ctx, "db_idx_double_update", &_args521, &_result523)
  p.SetLastResponseMeta_(_meta522)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args524 ApplyDbIdxDoubleRemoveArgs
  _args524.Iterator = iterator
  var _result526 ApplyDbIdxDoubleRemoveResult
  var _meta525 thrift.ResponseMeta
  _meta525, _err = p.Client_().Call(ctx, "db_idx_double_remove", &_args524, &_result526)
  p.SetLastResponseMeta_(_meta525)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args527 ApplyDbIdxDoubleNextArgs
  _args527.Iterator = iterator
  var _result529 ApplyDbIdxDoubleNextResult
  var _meta528 thrift.ResponseMeta
  _meta528, _err = p.Client_().Call(ctx, "db_idx_double_next", &_args527, &_result529)
  p.SetLastResponseMeta_(_meta528)
  if _err != nil {
    return
  }
  if _ret530 := _result529.GetSuccess(); _ret530 != nil {
    return _ret530, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args531 ApplyDbIdxDoublePreviousArgs
  _args531.Iterator = iterator
  var _result533 ApplyDbIdxDoublePreviousResult
  var _meta532 thrift.ResponseMeta
  _meta532, _err = p.Client_().Call(ctx, "db_idx_double_previous", &_args531, &_result533)
  p.SetLastResponseMeta_(_meta532)
  if _err != nil {
    return
  }
  if _ret534 := _result533.GetSuccess(); _ret534 != nil {
    return _ret534, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args535 ApplyDbIdxDoubleFindPrimaryArgs
  _args535.Code = code
  _args535.Scope = scope
  _args535.Table = table
  _args535.Primary = primary
  var _result537 ApplyDbIdxDoubleFindPrimaryResult
  var _meta536 thrift.ResponseMeta
  _meta536, _err = p.Client_().Call(ctx, "db_idx_double_find_primary", &_args535, &_result537)
  p.SetLastResponseMeta_(_meta536)
  if _err != nil {
    return
  }
  if _ret538 := _result537.GetSuccess(); _ret538 != nil {
    return _ret538, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args539 ApplyDbIdxDoubleFindSecondaryArgs
  _args539.Code = code
  _args539.Scope = scope
  _args539.Table = table
  _args539.Secondary = secondary
  var _result541 ApplyDbIdxDoubleFindSecondaryResult
  var _meta540 thrift.ResponseMeta
  _meta540, _err = p.Client_().Call(ctx, "db_idx_double_find_secondary", &_args539, &_result541)
  p.SetLastResponseMeta_(_meta540)
  if _err != nil {
    return
  }
  if _ret542 := _result541.GetSuccess(); _ret542 != nil {
    return _ret542, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args543 ApplyDbIdxDoubleLowerboundArgs
  _args543.Code = code
  _args543.Scope = scope
  _args543.Table = table
  _args543.Secondary = secondary
  _args543.Primary = primary
  var _result545 ApplyDbIdxDoubleLowerboundResult
  var _meta544 thrift.ResponseMeta
  _meta544, _err = p.Client_().Call(ctx, "db_idx_double_lowerbound", &_args543, &_result545)
  p.SetLastResponseMeta_(_meta544)
  if _err != nil {
    return
  }
  if _ret546 := _result545.GetSuccess(); _ret546 != nil {
    return _ret546, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args547 ApplyDbIdxDoubleUpperboundArgs
  _args547.Code = code
  _args547.Scope = scope
  _args547.Table = table
  _args547.Secondary = secondary
  _args547.Primary = primary
  var _result549 ApplyDbIdxDoubleUpperboundResult
  var _meta548 thrift.ResponseMeta
  _meta548, _err = p.Client_().Call(ctx, "db_idx_double_upperbound", &_args547, &_result549)
  p.SetLastResponseMeta_(_meta548)
  if _err != nil {
    return
  }
  if _ret550 := _result549.GetSuccess(); _ret550 != nil {
    return _ret550, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args551 ApplyDbIdxDoubleEndArgs
  _args551.Code = code
  _args551.Scope = scope
  _args551.Table = table
  var _result553 ApplyDbIdxDoubleEndResult
  var _meta552 thrift.ResponseMeta
  _meta552, _err = p.Client_().Call(ctx, "db_idx_double_end", &_args551, &_result553)
  p.SetLastResponseMeta_(_meta552)
  if _err != nil {
    return
  }
  return _result553.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args554 ApplyDbIdxLongDoubleStoreArgs
  _args554.Scope = scope
  _args554.Table = table
  _args554.Payer = payer
  _args554.ID = id
  _args554.Secondary = secondary
  var _result556 ApplyDbIdxLongDoubleStoreResult
  var _meta555 thrift.ResponseMeta
  _meta555, _err = p.Client_().Call(ctx, "db_idx_long_double_store", &_args554, &_result556)
  p.SetLastResponseMeta_(_meta555)
  if _err != nil {
    return
  }
  return _result556.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args557 ApplyDbIdxLongDoubleUpdateArgs
  _args557.Iterator = iterator
  _args557.Payer = payer
  _args557.Secondary = secondary
  var _result559 ApplyDbIdxLongDoubleUpdateResult
  var _meta558 thrift.ResponseMeta
  _meta558, _err = p.Client_().Call(ctx, "db_idx_long_double_update", &_args557, &_result559)
  p.SetLastResponseMeta_(_meta558)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args560 ApplyDbIdxLongDoubleRemoveArgs
  _args560.Iterator = iterator
  var _result562 ApplyDbIdxLongDoubleRemoveResult
  var _meta561 thrift.ResponseMeta
  _meta561, _err = p.Client_().Call(ctx, "db_idx_long_double_remove", &_args560, &_result562)
  p.SetLastResponseMeta_(_meta561)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args563 ApplyDbIdxLongDoubleNextArgs
  _args563.Iterator = iterator
  var _result565 ApplyDbIdxLongDoubleNextResult
  var _meta564 thrift.ResponseMeta
  _meta564, _err = p.Client_().Call(ctx, "db_idx_long_double_next", &_args563, &_result565)
  p.SetLastResponseMeta_(_meta564)
  if _err != nil {
    return
  }
  if _ret566 := _result565.GetSuccess(); _ret566 != nil {
    return _ret566, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args567 ApplyDbIdxLongDoublePreviousArgs
  _args567.Iterator = iterator
  var _result569 ApplyDbIdxLongDoublePreviousResult
  var _meta568 thrift.ResponseMeta
  _meta568, _err = p.Client_().Call(ctx, "db_idx_long_double_previous", &_args567, &_result569)
  p.SetLastResponseMeta_(_meta568)
  if _err != nil {
    return
  }
  if _ret570 := _result569.GetSuccess(); _ret570 != nil {
    return _ret570, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args571 ApplyDbIdxLongDoubleFindPrimaryArgs
  _args571.Code = code
  _args571.Scope = scope
  _args571.Table = table
  _args571.Primary = primary
  var _result573 ApplyDbIdxLongDoubleFindPrimaryResult
  var _meta572 thrift.ResponseMeta
  _meta572, _err = p.Client_().Call(ctx, "db_idx_long_double_find_primary", &_args571, &_result573)
  p.SetLastResponseMeta_(_meta572)
  if _err != nil {
    return
  }
  if _ret574 := _result573.GetSuccess(); _ret574 != nil {
    return _ret574, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args575 ApplyDbIdxLongDoubleFindSecondaryArgs
  _args575.Code = code
  _args575.Scope = scope
  _args575.Table = table
  _args575.Secondary = secondary
  var _result577 ApplyDbIdxLongDoubleFindSecondaryResult
  var _meta576 thrift.ResponseMeta
  _meta576, _err = p.Client_().Call(ctx, "db_idx_long_double_find_secondary", &_args575, &_result577)
  p.SetLastResponseMeta_(_meta576)
  if _err != nil {
    return
  }
  if _ret578 := _result577.GetSuccess(); _ret578 != nil {
    return _ret578, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args579 ApplyDbIdxLongDoubleLowerboundArgs
  _args579.Code = code
  _args579.Scope = scope
  _args579.Table = table
  _args579.Secondary = secondary
  _args579.Primary = primary
  var _result581 ApplyDbIdxLongDoubleLowerboundResult
  var _meta580 thrift.ResponseMeta
  _meta580, _err = p.Client_().Call(ctx, "db_idx_long_double_lowerbound", &_args579, &_result581)
  p.SetLastResponseMeta_(_meta580)
  if _err != nil {
    return
  }
  if _ret582 := _result581.GetSuccess(); _ret582 != nil {
    return _ret582, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args583 ApplyDbIdxLongDoubleUpperboundArgs
  _args583.Code = code
  _args583.Scope = scope
  _args583.Table = table
  _args583.Secondary = secondary
  _args583.Primary = primary
  var _result585 ApplyDbIdxLongDoubleUpperboundResult
  var _meta584 thrift.ResponseMeta
  _meta584, _err = p.Client_().Call(ctx, "db_idx_long_double_upperbound", &_args583, &_result585)
  p.SetLastResponseMeta_(_meta584)
  if _err != nil {
    return
  }
  if _ret586 := _result585.GetSuccess(); _ret586 != nil {
    return _ret586, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args587 ApplyDbIdxLongDoubleEndArgs
  _args587.Code = code
  _args587.Scope = scope
  _args587.Table = table
  var _result589 ApplyDbIdxLongDoubleEndResult
  var _meta588 thrift.ResponseMeta
  _meta588, _err = p.Client_().Call(ctx, "db_idx_long_double_end", &_args587, &_result589)
  p.SetLastResponseMeta_(_meta588)
  if _err != nil {
    return
  }
  return _result589.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) SetActionReturnValue(ctx context.Context, data []byte) (_err error) {
  var _args590 ApplySetActionReturnValueArgs
  _args590.Data = data
  var _result592 ApplySetActionReturnValueResult
  var _meta591 thrift.ResponseMeta
  _meta591, _err = p.Client_().Call(ctx, "set_action_return_value", &_args590, &_result592)
  p.SetLastResponseMeta_(_meta591)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Account
//  - StructVersion
func (p *ApplyClient) GetCodeHash(ctx context.Context, account *Uint64, struct_version int64) (_r []byte, _err error) {
  var _args593 ApplyGetCodeHashArgs
  _args593.Account = account
  _args593.StructVersion = struct_version
  var _result595 ApplyGetCodeHashResult
  var _meta594 thrift.ResponseMeta
  _meta594, _err = p.Client_().Call(ctx, "get_code_hash", &_args593, &_result595)
  p.SetLastResponseMeta_(_meta594)
  if _err != nil {
    return
  }
  return _result595.GetSuccess(), nil
}

func (p *ApplyClient) GetBlockNum(ctx context.Context) (_r int64, _err error) {
  var _args596 ApplyGetBlockNumArgs
  var _result598 ApplyGetBlockNumResult
  var _meta597 thrift.ResponseMeta
  _meta597, _err = p.Client_().Call(ctx, "get_block_num", &_args596, &_result598)
  p.SetLastResponseMeta_(_meta597)
  if _err != nil {
    return
  }
  return _result598.GetSuccess(), nil
}

// Parameters:
//  - Data
//  - Keccak
func (p *ApplyClient) Sha3(ctx context.Context, data []byte, keccak int32) (_r []byte, _err error) {
  var _args599 ApplySha3Args
  _args599.Data = data
  _args599.Keccak = keccak
  var _result601 ApplySha3Result
  var _meta600 thrift.ResponseMeta
  _meta600, _err = p.Client_().Call(ctx, "sha3", &_args599, &_result601)
  p.SetLastResponseMeta_(_meta600)
  if _err != nil {
    return
  }
  return _result601.GetSuccess(), nil
}

// Parameters:
//  - Rounds
//  - State
//  - Msg
//  - T0Offset
//  - T1Offset
//  - Final
func (p *ApplyClient) Blake2F(ctx context.Context, rounds int64, state []byte, msg []byte, t0_offset []byte, t1_offset []byte, final int32) (_r []byte, _err error) {
  var _args602 ApplyBlake2FArgs
  _args602.Rounds = rounds
  _args602.State = state
  _args602.Msg = msg
  _args602.T0Offset = t0_offset
  _args602.T1Offset = t1_offset
  _args602.Final = final
  var _result604 ApplyBlake2FResult
  var _meta603 thrift.ResponseMeta
  _meta603, _err = p.Client_().Call(ctx, "blake2_f", &_args602, &_result604)
  p.SetLastResponseMeta_(_meta603)
  if _err != nil {
    return
  }
  return _result604.GetSuccess(), nil
}

// Parameters:
//  - Sig
//  - Dig
func (p *ApplyClient) K1Recover(ctx context.Context, sig []byte, dig []byte) (_r []byte, _err error) {
  var _args605 ApplyK1RecoverArgs
  _args605.Sig = sig
  _args605.Dig = dig
  var _result607 ApplyK1RecoverResult
  var _meta606 thrift.ResponseMeta
  _meta606, _err = p.Client_().Call(ctx, "k1_recover", &_args605, &_result607)
  p.SetLastResponseMeta_(_meta606)
  if _err != nil {
    return
  }
  return _result607.GetSuccess(), nil
}

// Parameters:
//  - Op1
//  - Op2
func (p *ApplyClient) AltBn128Add(ctx context.Context, op1 []byte, op2 []byte) (_r []byte, _err error) {
  var _args608 ApplyAltBn128AddArgs
  _args608.Op1 = op1
  _args608.Op2 = op2
  var _result610 ApplyAltBn128AddResult
  var _meta609 thrift.ResponseMeta
  _meta609, _err = p.Client_().Call(ctx, "alt_bn128_add", &_args608, &_result610)
  p.SetLastResponseMeta_(_meta609)
  if _err != nil {
    return
  }
  return _result610.GetSuccess(), nil
}

// Parameters:
//  - G1
//  - Scalar
func (p *ApplyClient) AltBn128Mul(ctx context.Context, g1 []byte, scalar []byte) (_r []byte, _err error) {
  var _args611 ApplyAltBn128MulArgs
  _args611.G1 = g1
  _args611.Scalar = scalar
  var _result613 ApplyAltBn128MulResult
  var _meta612 thrift.ResponseMeta
  _meta612, _err = p.Client_().Call(ctx, "alt_bn128_mul", &_args611, &_result613)
  p.SetLastResponseMeta_(_meta612)
  if _err != nil {
    return
  }
  return _result613.GetSuccess(), nil
}

// Parameters:
//  - Pairs
func (p *ApplyClient) AltBn128Pair(ctx context.Context, pairs []byte) (_r int32, _err error) {
  var _args614 ApplyAltBn128PairArgs
  _args614.Pairs = pairs
  var _result616 ApplyAltBn128PairResult
  var _meta615 thrift.ResponseMeta
  _meta615, _err = p.Client_().Call(ctx, "alt_bn128_pair", &_args614, &_result616)
  p.SetLastResponseMeta_(_meta615)
  if _err != nil {
    return
  }
  return _result616.GetSuccess(), nil
}

// Parameters:
//  - Base
//  - Exp
//  - Mod
func (p *ApplyClient) ModExp(ctx context.Context, base []byte, exp []byte, mod []byte) (_r []byte, _err error) {
  var _args617 ApplyModExpArgs
  _args617.Base = base
  _args617.Exp = exp
  _args617.Mod = mod
  var _result619 ApplyModExpResult
  var _meta618 thrift.ResponseMeta
  _meta618, _err = p.Client_().Call(ctx, "mod_exp", &_args617, &_result619)
  p.SetLastResponseMeta_(_meta618)
  if _err != nil {
    return
  }
  return _result619.GetSuccess(), nil
}

type ApplyProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler Apply
}

func (p *ApplyProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyProcessor(handler Apply) *ApplyProcessor {

  self620 := &ApplyProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self620.processorMap["end_apply"] = &applyProcessorEndApply{handler:handler}
  self620.processorMap["get_active_producers"] = &applyProcessorGetActiveProducers{handler:handler}
  self620.processorMap["get_resource_limits"] = &applyProcessorGetResourceLimits{handler:handler}
  self620.processorMap["set_resource_limits"] = &applyProcessorSetResourceLimits{handler:handler}
  self620.processorMap["set_proposed_producers"] = &applyProcessorSetProposedProducers{handler:handler}
  self620.processorMap["set_proposed_producers_ex"] = &applyProcessorSetProposedProducersEx{handler:handler}
  self620.processorMap["is_privileged"] = &applyProcessorIsPrivileged{handler:handler}
  self620.processorMap["set_privileged"] = &applyProcessorSetPrivileged{handler:handler}
  self620.processorMap["set_blockchain_parameters_packed"] = &applyProcessorSetBlockchainParametersPacked{handler:handler}
  self620.processorMap["get_blockchain_parameters_packed"] = &applyProcessorGetBlockchainParametersPacked{handler:handler}
  self620.processorMap["preactivate_feature"] = &applyProcessorPreactivateFeature{handler:handler}
  self620.processorMap["check_transaction_authorization"] = &applyProcessorCheckTransactionAuthorization{handler:handler}
  self620.processorMap["check_permission_authorization"] = &applyProcessorCheckPermissionAuthorization{handler:handler}
  self620.processorMap["get_permission_last_used"] = &applyProcessorGetPermissionLastUsed{handler:handler}
  self620.processorMap["get_account_creation_time"] = &applyProcessorGetAccountCreationTime{handler:handler}
  self620.processorMap["prints"] = &applyProcessorPrints{handler:handler}
  self620.processorMap["prints_l"] = &applyProcessorPrintsL{handler:handler}
  self620.processorMap["printi"] = &applyProcessorPrinti{handler:handler}
  self620.processorMap["printui"] = &applyProcessorPrintui{handler:handler}
  self620.processorMap["printi128"] = &applyProcessorPrinti128{handler:handler}
  self620.processorMap["printui128"] = &applyProcessorPrintui128{handler:handler}
  self620.processorMap["printsf"] = &applyProcessorPrintsf{handler:handler}
  self620.processorMap["printdf"] = &applyProcessorPrintdf{handler:handler}
  self620.processorMap["printqf"] = &applyProcessorPrintqf{handler:handler}
  self620.processorMap["printn"] = &applyProcessorPrintn{handler:handler}
  self620.processorMap["printhex"] = &applyProcessorPrinthex{handler:handler}
  self620.processorMap["action_data_size"] = &applyProcessorActionDataSize{handler:handler}
  self620.processorMap["read_action_data"] = &applyProcessorReadActionData{handler:handler}
  self620.processorMap["require_recipient"] = &applyProcessorRequireRecipient{handler:handler}
  self620.processorMap["require_auth"] = &applyProcessorRequireAuth{handler:handler}
  self620.processorMap["has_auth"] = &applyProcessorHasAuth{handler:handler}
  self620.processorMap["require_auth2"] = &applyProcessorRequireAuth2{handler:handler}
  self620.processorMap["is_account"] = &applyProcessorIsAccount{handler:handler}
  self620.processorMap["send_inline"] = &applyProcessorSendInline{handler:handler}
  self620.processorMap["send_context_free_inline"] = &applyProcessorSendContextFreeInline{handler:handler}
  self620.processorMap["publication_time"] = &applyProcessorPublicationTime{handler:handler}
  self620.processorMap["current_receiver"] = &applyProcessorCurrentReceiver{handler:handler}
  self620.processorMap["eosio_assert"] = &applyProcessorEosioAssert{handler:handler}
  self620.processorMap["eosio_assert_message"] = &applyProcessorEosioAssertMessage{handler:handler}
  self620.processorMap["eosio_assert_code"] = &applyProcessorEosioAssertCode{handler:handler}
  self620.processorMap["eosio_exit"] = &applyProcessorEosioExit{handler:handler}
  self620.processorMap["current_time"] = &applyProcessorCurrentTime{handler:handler}
  self620.processorMap["is_feature_activated"] = &applyProcessorIsFeatureActivated{handler:handler}
  self620.processorMap["get_sender"] = &applyProcessorGetSender{handler:handler}
  self620.processorMap["assert_sha256"] = &applyProcessorAssertSha256{handler:handler}
  self620.processorMap["assert_sha1"] = &applyProcessorAssertSha1{handler:handler}
  self620.processorMap["assert_sha512"] = &applyProcessorAssertSha512{handler:handler}
  self620.processorMap["assert_ripemd160"] = &applyProcessorAssertRipemd160{handler:handler}
  self620.processorMap["sha256"] = &applyProcessorSha256{handler:handler}
  self620.processorMap["sha1"] = &applyProcessorSha1{handler:handler}
  self620.processorMap["sha512"] = &applyProcessorSha512{handler:handler}
  self620.processorMap["ripemd160"] = &applyProcessorRipemd160{handler:handler}
  self620.processorMap["recover_key"] = &applyProcessorRecoverKey{handler:handler}
  self620.processorMap["assert_recover_key"] = &applyProcessorAssertRecoverKey{handler:handler}
  self620.processorMap["send_deferred"] = &applyProcessorSendDeferred{handler:handler}
  self620.processorMap["cancel_deferred"] = &applyProcessorCancelDeferred{handler:handler}
  self620.processorMap["read_transaction"] = &applyProcessorReadTransaction{handler:handler}
  self620.processorMap["transaction_size"] = &applyProcessorTransactionSize{handler:handler}
  self620.processorMap["tapos_block_num"] = &applyProcessorTaposBlockNum{handler:handler}
  self620.processorMap["tapos_block_prefix"] = &applyProcessorTaposBlockPrefix{handler:handler}
  self620.processorMap["expiration"] = &applyProcessorExpiration{handler:handler}
  self620.processorMap["get_action"] = &applyProcessorGetAction{handler:handler}
  self620.processorMap["get_context_free_data"] = &applyProcessorGetContextFreeData{handler:handler}
  self620.processorMap["db_store_i64"] = &applyProcessorDbStoreI64{handler:handler}
  self620.processorMap["db_update_i64"] = &applyProcessorDbUpdateI64{handler:handler}
  self620.processorMap["db_remove_i64"] = &applyProcessorDbRemoveI64{handler:handler}
  self620.processorMap["db_get_i64"] = &applyProcessorDbGetI64{handler:handler}
  self620.processorMap["db_next_i64"] = &applyProcessorDbNextI64{handler:handler}
  self620.processorMap["db_previous_i64"] = &applyProcessorDbPreviousI64{handler:handler}
  self620.processorMap["db_find_i64"] = &applyProcessorDbFindI64{handler:handler}
  self620.processorMap["db_lowerbound_i64"] = &applyProcessorDbLowerboundI64{handler:handler}
  self620.processorMap["db_upperbound_i64"] = &applyProcessorDbUpperboundI64{handler:handler}
  self620.processorMap["db_end_i64"] = &applyProcessorDbEndI64{handler:handler}
  self620.processorMap["db_idx64_store"] = &applyProcessorDbIdx64Store{handler:handler}
  self620.processorMap["db_idx64_update"] = &applyProcessorDbIdx64Update{handler:handler}
  self620.processorMap["db_idx64_remove"] = &applyProcessorDbIdx64Remove{handler:handler}
  self620.processorMap["db_idx64_next"] = &applyProcessorDbIdx64Next{handler:handler}
  self620.processorMap["db_idx64_previous"] = &applyProcessorDbIdx64Previous{handler:handler}
  self620.processorMap["db_idx64_find_primary"] = &applyProcessorDbIdx64FindPrimary{handler:handler}
  self620.processorMap["db_idx64_find_secondary"] = &applyProcessorDbIdx64FindSecondary{handler:handler}
  self620.processorMap["db_idx64_lowerbound"] = &applyProcessorDbIdx64Lowerbound{handler:handler}
  self620.processorMap["db_idx64_upperbound"] = &applyProcessorDbIdx64Upperbound{handler:handler}
  self620.processorMap["db_idx64_end"] = &applyProcessorDbIdx64End{handler:handler}
  self620.processorMap["db_idx128_store"] = &applyProcessorDbIdx128Store{handler:handler}
  self620.processorMap["db_idx128_update"] = &applyProcessorDbIdx128Update{handler:handler}
  self620.processorMap["db_idx128_remove"] = &applyProcessorDbIdx128Remove{handler:handler}
  self620.processorMap["db_idx128_next"] = &applyProcessorDbIdx128Next{handler:handler}
  self620.processorMap["db_idx128_previous"] = &applyProcessorDbIdx128Previous{handler:handler}
  self620.processorMap["db_idx128_find_primary"] = &applyProcessorDbIdx128FindPrimary{handler:handler}
  self620.processorMap["db_idx128_find_secondary"] = &applyProcessorDbIdx128FindSecondary{handler:handler}
  self620.processorMap["db_idx128_lowerbound"] = &applyProcessorDbIdx128Lowerbound{handler:handler}
  self620.processorMap["db_idx128_upperbound"] = &applyProcessorDbIdx128Upperbound{handler:handler}
  self620.processorMap["db_idx128_end"] = &applyProcessorDbIdx128End{handler:handler}
  self620.processorMap["db_idx256_store"] = &applyProcessorDbIdx256Store{handler:handler}
  self620.processorMap["db_idx256_update"] = &applyProcessorDbIdx256Update{handler:handler}
  self620.processorMap["db_idx256_remove"] = &applyProcessorDbIdx256Remove{handler:handler}
  self620.processorMap["db_idx256_next"] = &applyProcessorDbIdx256Next{handler:handler}
  self620.processorMap["db_idx256_previous"] = &applyProcessorDbIdx256Previous{handler:handler}
  self620.processorMap["db_idx256_find_primary"] = &applyProcessorDbIdx256FindPrimary{handler:handler}
  self620.processorMap["db_idx256_find_secondary"] = &applyProcessorDbIdx256FindSecondary{handler:handler}
  self620.processorMap["db_idx256_lowerbound"] = &applyProcessorDbIdx256Lowerbound{handler:handler}
  self620.processorMap["db_idx256_upperbound"] = &applyProcessorDbIdx256Upperbound{handler:handler}
  self620.processorMap["db_idx256_end"] = &applyProcessorDbIdx256End{handler:handler}
  self620.processorMap["db_idx_double_store"] = &applyProcessorDbIdxDoubleStore{handler:handler}
  self620.processorMap["db_idx_double_update"] = &applyProcessorDbIdxDoubleUpdate{handler:handler}
  self620.processorMap["db_idx_double_remove"] = &applyProcessorDbIdxDoubleRemove{handler:handler}
  self620.processorMap["db_idx_double_next"] = &applyProcessorDbIdxDoubleNext{handler:handler}
  self620.processorMap["db_idx_double_previous"] = &applyProcessorDbIdxDoublePrevious{handler:handler}
  self620.processorMap["db_idx_double_find_primary"] = &applyProcessorDbIdxDoubleFindPrimary{handler:handler}
  self620.processorMap["db_idx_double_find_secondary"] = &applyProcessorDbIdxDoubleFindSecondary{handler:handler}
  self620.processorMap["db_idx_double_lowerbound"] = &applyProcessorDbIdxDoubleLowerbound{handler:handler}
  self620.processorMap["db_idx_double_upperbound"] = &applyProcessorDbIdxDoubleUpperbound{handler:handler}
  self620.processorMap["db_idx_double_end"] = &applyProcessorDbIdxDoubleEnd{handler:handler}
  self620.processorMap["db_idx_long_double_store"] = &applyProcessorDbIdxLongDoubleStore{handler:handler}
  self620.processorMap["db_idx_long_double_update"] = &applyProcessorDbIdxLongDoubleUpdate{handler:handler}
  self620.processorMap["db_idx_long_double_remove"] = &applyProcessorDbIdxLongDoubleRemove{handler:handler}
  self620.processorMap["db_idx_long_double_next"] = &applyProcessorDbIdxLongDoubleNext{handler:handler}
  self620.processorMap["db_idx_long_double_previous"] = &applyProcessorDbIdxLongDoublePrevious{handler:handler}
  self620.processorMap["db_idx_long_double_find_primary"] = &applyProcessorDbIdxLongDoubleFindPrimary{handler:handler}
  self620.processorMap["db_idx_long_double_find_secondary"] = &applyProcessorDbIdxLongDoubleFindSecondary{handler:handler}
  self620.processorMap["db_idx_long_double_lowerbound"] = &applyProcessorDbIdxLongDoubleLowerbound{handler:handler}
  self620.processorMap["db_idx_long_double_upperbound"] = &applyProcessorDbIdxLongDoubleUpperbound{handler:handler}
  self620.processorMap["db_idx_long_double_end"] = &applyProcessorDbIdxLongDoubleEnd{handler:handler}
  self620.processorMap["set_action_return_value"] = &applyProcessorSetActionReturnValue{handler:handler}
  self620.processorMap["get_code_hash"] = &applyProcessorGetCodeHash{handler:handler}
  self620.processorMap["get_block_num"] = &applyProcessorGetBlockNum{handler:handler}
  self620.processorMap["sha3"] = &applyProcessorSha3{handler:handler}
  self620.processorMap["blake2_f"] = &applyProcessorBlake2F{handler:handler}
  self620.processorMap["k1_recover"] = &applyProcessorK1Recover{handler:handler}
  self620.processorMap["alt_bn128_add"] = &applyProcessorAltBn128Add{handler:handler}
  self620.processorMap["alt_bn128_mul"] = &applyProcessorAltBn128Mul{handler:handler}
  self620.processorMap["alt_bn128_pair"] = &applyProcessorAltBn128Pair{handler:handler}
  self620.processorMap["mod_exp"] = &applyProcessorModExp{handler:handler}
return self620
}

func (p *ApplyProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x621 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x621.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x621

}

type applyProcessorEndApply struct {
  handler Apply
}

func (p *applyProcessorEndApply) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEndApplyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEndApplyResult{}
  var retval int32
  if retval, err2 = p.handler.EndApply(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing end_apply: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "end_apply", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetActiveProducers struct {
  handler Apply
}

func (p *applyProcessorGetActiveProducers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetActiveProducersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetActiveProducersResult{}
  var retval []byte
  if retval, err2 = p.handler.GetActiveProducers(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_active_producers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_active_producers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetResourceLimits struct {
  handler Apply
}

func (p *applyProcessorGetResourceLimits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetResourceLimitsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetResourceLimitsResult{}
  var retval *GetResourceLimitsReturn
  if retval, err2 = p.handler.GetResourceLimits(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_resource_limits: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_resource_limits", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetResourceLimits struct {
  handler Apply
}

func (p *applyProcessorSetResourceLimits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetResourceLimitsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetResourceLimitsResult{}
  if err2 = p.handler.SetResourceLimits(ctx, args.Account, args.RAMBytes, args.NetWeight, args.CPUWeight); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_resource_limits: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_resource_limits", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetProposedProducers struct {
  handler Apply
}

func (p *applyProcessorSetProposedProducers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetProposedProducersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetProposedProducersResult{}
  var retval int64
  if retval, err2 = p.handler.SetProposedProducers(ctx, args.ProducerData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_proposed_producers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_proposed_producers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetProposedProducersEx struct {
  handler Apply
}

func (p *applyProcessorSetProposedProducersEx) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetProposedProducersExArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetProposedProducersExResult{}
  var retval int64
  if retval, err2 = p.handler.SetProposedProducersEx(ctx, args.ProducerDataFormat, args.ProducerData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_proposed_producers_ex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_proposed_producers_ex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsPrivileged struct {
  handler Apply
}

func (p *applyProcessorIsPrivileged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsPrivilegedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsPrivilegedResult{}
  var retval bool
  if retval, err2 = p.handler.IsPrivileged(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_privileged: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_privileged", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetPrivileged struct {
  handler Apply
}

func (p *applyProcessorSetPrivileged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetPrivilegedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetPrivilegedResult{}
  if err2 = p.handler.SetPrivileged(ctx, args.Account, args.IsPriv); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_privileged: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_privileged", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_privileged", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetBlockchainParametersPacked struct {
  handler Apply
}

func (p *applyProcessorSetBlockchainParametersPacked) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetBlockchainParametersPackedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetBlockchainParametersPackedResult{}
  if err2 = p.handler.SetBlockchainParametersPacked(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_blockchain_parameters_packed: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_blockchain_parameters_packed", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetBlockchainParametersPacked struct {
  handler Apply
}

func (p *applyProcessorGetBlockchainParametersPacked) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetBlockchainParametersPackedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetBlockchainParametersPackedResult{}
  var retval []byte
  if retval, err2 = p.handler.GetBlockchainParametersPacked(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_blockchain_parameters_packed: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_blockchain_parameters_packed", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPreactivateFeature struct {
  handler Apply
}

func (p *applyProcessorPreactivateFeature) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPreactivateFeatureArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPreactivateFeatureResult{}
  if err2 = p.handler.PreactivateFeature(ctx, args.FeatureDigest); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing preactivate_feature: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "preactivate_feature", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCheckTransactionAuthorization struct {
  handler Apply
}

func (p *applyProcessorCheckTransactionAuthorization) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCheckTransactionAuthorizationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCheckTransactionAuthorizationResult{}
  var retval int32
  if retval, err2 = p.handler.CheckTransactionAuthorization(ctx, args.TrxData, args.PubkeysData, args.PermsData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing check_transaction_authorization: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "check_transaction_authorization", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCheckPermissionAuthorization struct {
  handler Apply
}

func (p *applyProcessorCheckPermissionAuthorization) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCheckPermissionAuthorizationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCheckPermissionAuthorizationResult{}
  var retval int32
  if retval, err2 = p.handler.CheckPermissionAuthorization(ctx, args.Account, args.Permission, args.PubkeysData, args.PermsData, args.DelayUs); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing check_permission_authorization: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "check_permission_authorization", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetPermissionLastUsed struct {
  handler Apply
}

func (p *applyProcessorGetPermissionLastUsed) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetPermissionLastUsedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetPermissionLastUsedResult{}
  var retval int64
  if retval, err2 = p.handler.GetPermissionLastUsed(ctx, args.Account, args.Permission); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_permission_last_used: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_permission_last_used", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetAccountCreationTime struct {
  handler Apply
}

func (p *applyProcessorGetAccountCreationTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetAccountCreationTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetAccountCreationTimeResult{}
  var retval int64
  if retval, err2 = p.handler.GetAccountCreationTime(ctx, args.Account); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_account_creation_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_account_creation_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrints struct {
  handler Apply
}

func (p *applyProcessorPrints) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsResult{}
  if err2 = p.handler.Prints(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsL struct {
  handler Apply
}

func (p *applyProcessorPrintsL) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsLArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsLResult{}
  if err2 = p.handler.PrintsL(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints_l: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints_l", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti struct {
  handler Apply
}

func (p *applyProcessorPrinti) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintiResult{}
  if err2 = p.handler.Printi(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui struct {
  handler Apply
}

func (p *applyProcessorPrintui) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintuiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintuiResult{}
  if err2 = p.handler.Printui(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti128 struct {
  handler Apply
}

func (p *applyProcessorPrinti128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinti128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinti128Result{}
  if err2 = p.handler.Printi128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui128 struct {
  handler Apply
}

func (p *applyProcessorPrintui128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintui128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintui128Result{}
  if err2 = p.handler.Printui128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsf struct {
  handler Apply
}

func (p *applyProcessorPrintsf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsfResult{}
  if err2 = p.handler.Printsf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printsf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printsf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintdf struct {
  handler Apply
}

func (p *applyProcessorPrintdf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintdfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintdfResult{}
  if err2 = p.handler.Printdf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printdf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printdf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintqf struct {
  handler Apply
}

func (p *applyProcessorPrintqf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintqfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintqfResult{}
  if err2 = p.handler.Printqf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printqf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printqf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintn struct {
  handler Apply
}

func (p *applyProcessorPrintn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintnArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintnResult{}
  if err2 = p.handler.Printn(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printn: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printn", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinthex struct {
  handler Apply
}

func (p *applyProcessorPrinthex) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinthexArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinthexResult{}
  if err2 = p.handler.Printhex(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printhex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printhex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorActionDataSize struct {
  handler Apply
}

func (p *applyProcessorActionDataSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyActionDataSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyActionDataSizeResult{}
  var retval int32
  if retval, err2 = p.handler.ActionDataSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing action_data_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "action_data_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadActionData struct {
  handler Apply
}

func (p *applyProcessorReadActionData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadActionDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadActionDataResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadActionData(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_action_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_action_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireRecipient struct {
  handler Apply
}

func (p *applyProcessorRequireRecipient) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireRecipientArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireRecipientResult{}
  if err2 = p.handler.RequireRecipient(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_recipient: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_recipient", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth struct {
  handler Apply
}

func (p *applyProcessorRequireAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuthResult{}
  if err2 = p.handler.RequireAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorHasAuth struct {
  handler Apply
}

func (p *applyProcessorHasAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyHasAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyHasAuthResult{}
  var retval bool
  if retval, err2 = p.handler.HasAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing has_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "has_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth2 struct {
  handler Apply
}

func (p *applyProcessorRequireAuth2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuth2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuth2Result{}
  if err2 = p.handler.RequireAuth2(ctx, args.Name, args.Permission); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsAccount struct {
  handler Apply
}

func (p *applyProcessorIsAccount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsAccountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsAccountResult{}
  var retval bool
  if retval, err2 = p.handler.IsAccount(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_account: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_account", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendInline struct {
  handler Apply
}

func (p *applyProcessorSendInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendInlineResult{}
  if err2 = p.handler.SendInline(ctx, args.SerializedAction); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendContextFreeInline struct {
  handler Apply
}

func (p *applyProcessorSendContextFreeInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendContextFreeInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendContextFreeInlineResult{}
  if err2 = p.handler.SendContextFreeInline(ctx, args.SerializedData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_context_free_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPublicationTime struct {
  handler Apply
}

func (p *applyProcessorPublicationTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPublicationTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPublicationTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.PublicationTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing publication_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "publication_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentReceiver struct {
  handler Apply
}

func (p *applyProcessorCurrentReceiver) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentReceiverArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentReceiverResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentReceiver(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_receiver: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_receiver", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssert struct {
  handler Apply
}

func (p *applyProcessorEosioAssert) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertResult{}
  if err2 = p.handler.EosioAssert(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertMessage struct {
  handler Apply
}

func (p *applyProcessorEosioAssertMessage) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertMessageArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertMessageResult{}
  if err2 = p.handler.EosioAssertMessage(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_message: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertCode struct {
  handler Apply
}

func (p *applyProcessorEosioAssertCode) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertCodeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertCodeResult{}
  if err2 = p.handler.EosioAssertCode(ctx, args.Test, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_code: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioExit struct {
  handler Apply
}

func (p *applyProcessorEosioExit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioExitArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioExitResult{}
  if err2 = p.handler.EosioExit(ctx, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_exit: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentTime struct {
  handler Apply
}

func (p *applyProcessorCurrentTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsFeatureActivated struct {
  handler Apply
}

func (p *applyProcessorIsFeatureActivated) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsFeatureActivatedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsFeatureActivatedResult{}
  var retval bool
  if retval, err2 = p.handler.IsFeatureActivated(ctx, args.FeatureDigest); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_feature_activated: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetSender struct {
  handler Apply
}

func (p *applyProcessorGetSender) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetSenderArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetSenderResult{}
  var retval *Uint64
  if retval, err2 = p.handler.GetSender(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_sender: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_sender", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha256 struct {
  handler Apply
}

func (p *applyProcessorAssertSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha256Result{}
  if err2 = p.handler.AssertSha256(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha1 struct {
  handler Apply
}

func (p *applyProcessorAssertSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha1Result{}
  if err2 = p.handler.AssertSha1(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha512 struct {
  handler Apply
}

func (p *applyProcessorAssertSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha512Result{}
  if err2 = p.handler.AssertSha512(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRipemd160 struct {
  handler Apply
}

func (p *applyProcessorAssertRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRipemd160Result{}
  if err2 = p.handler.AssertRipemd160(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha256 struct {
  handler Apply
}

func (p *applyProcessorSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha256Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha256(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha1 struct {
  handler Apply
}

func (p *applyProcessorSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha1Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha1(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha512 struct {
  handler Apply
}

func (p *applyProcessorSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha512Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha512(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRipemd160 struct {
  handler Apply
}

func (p *applyProcessorRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRipemd160Result{}
  var retval []byte
  if retval, err2 = p.handler.Ripemd160(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRecoverKey struct {
  handler Apply
}

func (p *applyProcessorRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRecoverKeyResult{}
  var retval []byte
  if retval, err2 = p.handler.RecoverKey(ctx, args.Digest, args.Sig); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRecoverKey struct {
  handler Apply
}

func (p *applyProcessorAssertRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRecoverKeyResult{}
  if err2 = p.handler.AssertRecoverKey(ctx, args.Digest, args.Sig, args.Pub); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendDeferred struct {
  handler Apply
}

func (p *applyProcessorSendDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendDeferredResult{}
  if err2 = p.handler.SendDeferred(ctx, args.SenderID, args.Payer, args.SerializedTransaction, args.ReplaceExisting); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCancelDeferred struct {
  handler Apply
}

func (p *applyProcessorCancelDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCancelDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCancelDeferredResult{}
  var retval int32
  if retval, err2 = p.handler.CancelDeferred(ctx, args.SenderID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadTransaction struct {
  handler Apply
}

func (p *applyProcessorReadTransaction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadTransactionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadTransactionResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadTransaction(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_transaction: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_transaction", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTransactionSize struct {
  handler Apply
}

func (p *applyProcessorTransactionSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTransactionSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTransactionSizeResult{}
  var retval int32
  if retval, err2 = p.handler.TransactionSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing transaction_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "transaction_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockNum struct {
  handler Apply
}

func (p *applyProcessorTaposBlockNum) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockNumArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockNumResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockNum(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_num: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockPrefix struct {
  handler Apply
}

func (p *applyProcessorTaposBlockPrefix) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockPrefixArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockPrefixResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockPrefix(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_prefix: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorExpiration struct {
  handler Apply
}

func (p *applyProcessorExpiration) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyExpirationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyExpirationResult{}
  var retval int64
  if retval, err2 = p.handler.Expiration(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expiration: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expiration", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetAction struct {
  handler Apply
}

func (p *applyProcessorGetAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetActionResult{}
  var retval []byte
  if retval, err2 = p.handler.GetAction(ctx, args._type, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetContextFreeData struct {
  handler Apply
}

func (p *applyProcessorGetContextFreeData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetContextFreeDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetContextFreeDataResult{}
  var retval []byte
  if retval, err2 = p.handler.GetContextFreeData(ctx, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_context_free_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbStoreI64 struct {
  handler Apply
}

func (p *applyProcessorDbStoreI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbStoreI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbStoreI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbStoreI64(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_store_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpdateI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpdateI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpdateI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpdateI64Result{}
  if err2 = p.handler.DbUpdateI64(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_update_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbRemoveI64 struct {
  handler Apply
}

func (p *applyProcessorDbRemoveI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbRemoveI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbRemoveI64Result{}
  if err2 = p.handler.DbRemoveI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_remove_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbGetI64 struct {
  handler Apply
}

func (p *applyProcessorDbGetI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbGetI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbGetI64Result{}
  var retval []byte
  if retval, err2 = p.handler.DbGetI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_get_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbNextI64 struct {
  handler Apply
}

func (p *applyProcessorDbNextI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbNextI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbNextI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbNextI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_next_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbPreviousI64 struct {
  handler Apply
}

func (p *applyProcessorDbPreviousI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbPreviousI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbPreviousI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbPreviousI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_previous_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbFindI64 struct {
  handler Apply
}

func (p *applyProcessorDbFindI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbFindI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbFindI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbFindI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_find_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbLowerboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbLowerboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbLowerboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbLowerboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbLowerboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_lowerbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpperboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpperboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpperboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpperboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbUpperboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_upperbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbEndI64 struct {
  handler Apply
}

func (p *applyProcessorDbEndI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbEndI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbEndI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbEndI64(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_end_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpdateResult{}
  if err2 = p.handler.DbIdx64Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64RemoveResult{}
  if err2 = p.handler.DbIdx64Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Previous(ctx, args.Iteratory); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx64FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx64FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64End struct {
  handler Apply
}

func (p *applyProcessorDbIdx64End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpdateResult{}
  if err2 = p.handler.DbIdx128Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128RemoveResult{}
  if err2 = p.handler.DbIdx128Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx128FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx128FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128End struct {
  handler Apply
}

func (p *applyProcessorDbIdx128End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpdateResult{}
  if err2 = p.handler.DbIdx256Update(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256RemoveResult{}
  if err2 = p.handler.DbIdx256Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx256FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx256FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Upperbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256End struct {
  handler Apply
}

func (p *applyProcessorDbIdx256End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpdateResult{}
  if err2 = p.handler.DbIdxDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleRemoveResult{}
  if err2 = p.handler.DbIdxDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpdateResult{}
  if err2 = p.handler.DbIdxLongDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleRemoveResult{}
  if err2 = p.handler.DbIdxLongDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSetActionReturnValue struct {
  handler Apply
}

func (p *applyProcessorSetActionReturnValue) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySetActionReturnValueArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "set_action_return_value", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySetActionReturnValueResult{}
  if err2 = p.handler.SetActionReturnValue(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_action_return_value: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "set_action_return_value", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "set_action_return_value", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetCodeHash struct {
  handler Apply
}

func (p *applyProcessorGetCodeHash) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetCodeHashArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_code_hash", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetCodeHashResult{}
  var retval []byte
  if retval, err2 = p.handler.GetCodeHash(ctx, args.Account, args.StructVersion); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_code_hash: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_code_hash", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_code_hash", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetBlockNum struct {
  handler Apply
}

func (p *applyProcessorGetBlockNum) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetBlockNumArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetBlockNumResult{}
  var retval int64
  if retval, err2 = p.handler.GetBlockNum(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_block_num: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_block_num", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha3 struct {
  handler Apply
}

func (p *applyProcessorSha3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha3Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha3(ctx, args.Data, args.Keccak); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorBlake2F struct {
  handler Apply
}

func (p *applyProcessorBlake2F) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyBlake2FArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "blake2_f", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyBlake2FResult{}
  var retval []byte
  if retval, err2 = p.handler.Blake2F(ctx, args.Rounds, args.State, args.Msg, args.T0Offset, args.T1Offset, args.Final); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing blake2_f: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "blake2_f", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "blake2_f", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorK1Recover struct {
  handler Apply
}

func (p *applyProcessorK1Recover) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyK1RecoverArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "k1_recover", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyK1RecoverResult{}
  var retval []byte
  if retval, err2 = p.handler.K1Recover(ctx, args.Sig, args.Dig); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing k1_recover: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "k1_recover", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "k1_recover", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAltBn128Add struct {
  handler Apply
}

func (p *applyProcessorAltBn128Add) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAltBn128AddArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_add", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAltBn128AddResult{}
  var retval []byte
  if retval, err2 = p.handler.AltBn128Add(ctx, args.Op1, args.Op2); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing alt_bn128_add: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_add", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "alt_bn128_add", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAltBn128Mul struct {
  handler Apply
}

func (p *applyProcessorAltBn128Mul) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAltBn128MulArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_mul", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAltBn128MulResult{}
  var retval []byte
  if retval, err2 = p.handler.AltBn128Mul(ctx, args.G1, args.Scalar); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing alt_bn128_mul: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_mul", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "alt_bn128_mul", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAltBn128Pair struct {
  handler Apply
}

func (p *applyProcessorAltBn128Pair) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAltBn128PairArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_pair", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAltBn128PairResult{}
  var retval int32
  if retval, err2 = p.handler.AltBn128Pair(ctx, args.Pairs); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing alt_bn128_pair: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "alt_bn128_pair", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "alt_bn128_pair", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorModExp struct {
  handler Apply
}

func (p *applyProcessorModExp) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyModExpArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mod_exp", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyModExpResult{}
  var retval []byte
  if retval, err2 = p.handler.ModExp(ctx, args.Base, args.Exp, args.Mod); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mod_exp: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mod_exp", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mod_exp", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ApplyEndApplyArgs struct {
}

func NewApplyEndApplyArgs() *ApplyEndApplyArgs {
  return &ApplyEndApplyArgs{}
}

func (p *ApplyEndApplyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyEndApplyResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyEndApplyResult() *ApplyEndApplyResult {
  return &ApplyEndApplyResult{}
}

var ApplyEndApplyResult_Success_DEFAULT int32
func (p *ApplyEndApplyResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyEndApplyResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyEndApplyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyEndApplyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyEndApplyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyEndApplyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyResult(%+v)", *p)
}

type ApplyGetActiveProducersArgs struct {
}

func NewApplyGetActiveProducersArgs() *ApplyGetActiveProducersArgs {
  return &ApplyGetActiveProducersArgs{}
}

func (p *ApplyGetActiveProducersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActiveProducersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_active_producers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActiveProducersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActiveProducersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetActiveProducersResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetActiveProducersResult() *ApplyGetActiveProducersResult {
  return &ApplyGetActiveProducersResult{}
}

var ApplyGetActiveProducersResult_Success_DEFAULT []byte

func (p *ApplyGetActiveProducersResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetActiveProducersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetActiveProducersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActiveProducersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetActiveProducersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_active_producers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActiveProducersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetActiveProducersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActiveProducersResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyGetResourceLimitsArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyGetResourceLimitsArgs() *ApplyGetResourceLimitsArgs {
  return &ApplyGetResourceLimitsArgs{}
}

var ApplyGetResourceLimitsArgs_Account_DEFAULT *Uint64
func (p *ApplyGetResourceLimitsArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetResourceLimitsArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyGetResourceLimitsArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetResourceLimitsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_resource_limits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetResourceLimitsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetResourceLimitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetResourceLimitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetResourceLimitsResult struct {
  Success *GetResourceLimitsReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetResourceLimitsResult() *ApplyGetResourceLimitsResult {
  return &ApplyGetResourceLimitsResult{}
}

var ApplyGetResourceLimitsResult_Success_DEFAULT *GetResourceLimitsReturn
func (p *ApplyGetResourceLimitsResult) GetSuccess() *GetResourceLimitsReturn {
  if !p.IsSetSuccess() {
    return ApplyGetResourceLimitsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyGetResourceLimitsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetResourceLimitsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &GetResourceLimitsReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyGetResourceLimitsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_resource_limits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetResourceLimitsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetResourceLimitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetResourceLimitsResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - RAMBytes
//  - NetWeight
//  - CPUWeight
type ApplySetResourceLimitsArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  RAMBytes int64 `thrift:"ram_bytes,2" db:"ram_bytes" json:"ram_bytes"`
  NetWeight int64 `thrift:"net_weight,3" db:"net_weight" json:"net_weight"`
  CPUWeight int64 `thrift:"cpu_weight,4" db:"cpu_weight" json:"cpu_weight"`
}

func NewApplySetResourceLimitsArgs() *ApplySetResourceLimitsArgs {
  return &ApplySetResourceLimitsArgs{}
}

var ApplySetResourceLimitsArgs_Account_DEFAULT *Uint64
func (p *ApplySetResourceLimitsArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplySetResourceLimitsArgs_Account_DEFAULT
  }
return p.Account
}

func (p *ApplySetResourceLimitsArgs) GetRAMBytes() int64 {
  return p.RAMBytes
}

func (p *ApplySetResourceLimitsArgs) GetNetWeight() int64 {
  return p.NetWeight
}

func (p *ApplySetResourceLimitsArgs) GetCPUWeight() int64 {
  return p.CPUWeight
}
func (p *ApplySetResourceLimitsArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplySetResourceLimitsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.RAMBytes = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NetWeight = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.CPUWeight = v
}
  return nil
}

func (p *ApplySetResourceLimitsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_resource_limits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetResourceLimitsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ram_bytes", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ram_bytes: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RAMBytes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ram_bytes (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ram_bytes: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "net_weight", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:net_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NetWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.net_weight (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:net_weight: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cpu_weight", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:cpu_weight: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CPUWeight)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cpu_weight (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:cpu_weight: ", p), err) }
  return err
}

func (p *ApplySetResourceLimitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetResourceLimitsArgs(%+v)", *p)
}

type ApplySetResourceLimitsResult struct {
}

func NewApplySetResourceLimitsResult() *ApplySetResourceLimitsResult {
  return &ApplySetResourceLimitsResult{}
}

func (p *ApplySetResourceLimitsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetResourceLimitsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_resource_limits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetResourceLimitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetResourceLimitsResult(%+v)", *p)
}

// Attributes:
//  - ProducerData
type ApplySetProposedProducersArgs struct {
  ProducerData []byte `thrift:"producer_data,1" db:"producer_data" json:"producer_data"`
}

func NewApplySetProposedProducersArgs() *ApplySetProposedProducersArgs {
  return &ApplySetProposedProducersArgs{}
}


func (p *ApplySetProposedProducersArgs) GetProducerData() []byte {
  return p.ProducerData
}
func (p *ApplySetProposedProducersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ProducerData = v
}
  return nil
}

func (p *ApplySetProposedProducersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:producer_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.ProducerData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.producer_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:producer_data: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySetProposedProducersResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySetProposedProducersResult() *ApplySetProposedProducersResult {
  return &ApplySetProposedProducersResult{}
}

var ApplySetProposedProducersResult_Success_DEFAULT int64
func (p *ApplySetProposedProducersResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplySetProposedProducersResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplySetProposedProducersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySetProposedProducersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplySetProposedProducersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySetProposedProducersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersResult(%+v)", *p)
}

// Attributes:
//  - ProducerDataFormat
//  - ProducerData
type ApplySetProposedProducersExArgs struct {
  ProducerDataFormat *Uint64 `thrift:"producer_data_format,1" db:"producer_data_format" json:"producer_data_format"`
  ProducerData []byte `thrift:"producer_data,2" db:"producer_data" json:"producer_data"`
}

func NewApplySetProposedProducersExArgs() *ApplySetProposedProducersExArgs {
  return &ApplySetProposedProducersExArgs{}
}

var ApplySetProposedProducersExArgs_ProducerDataFormat_DEFAULT *Uint64
func (p *ApplySetProposedProducersExArgs) GetProducerDataFormat() *Uint64 {
  if !p.IsSetProducerDataFormat() {
    return ApplySetProposedProducersExArgs_ProducerDataFormat_DEFAULT
  }
return p.ProducerDataFormat
}

func (p *ApplySetProposedProducersExArgs) GetProducerData() []byte {
  return p.ProducerData
}
func (p *ApplySetProposedProducersExArgs) IsSetProducerDataFormat() bool {
  return p.ProducerDataFormat != nil
}

func (p *ApplySetProposedProducersExArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ProducerDataFormat = &Uint64{}
  if err := p.ProducerDataFormat.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ProducerDataFormat), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ProducerData = v
}
  return nil
}

func (p *ApplySetProposedProducersExArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_ex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersExArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data_format", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:producer_data_format: ", p), err) }
  if err := p.ProducerDataFormat.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ProducerDataFormat), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:producer_data_format: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersExArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "producer_data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:producer_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.ProducerData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.producer_data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:producer_data: ", p), err) }
  return err
}

func (p *ApplySetProposedProducersExArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersExArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySetProposedProducersExResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySetProposedProducersExResult() *ApplySetProposedProducersExResult {
  return &ApplySetProposedProducersExResult{}
}

var ApplySetProposedProducersExResult_Success_DEFAULT int64
func (p *ApplySetProposedProducersExResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplySetProposedProducersExResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplySetProposedProducersExResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySetProposedProducersExResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetProposedProducersExResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplySetProposedProducersExResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_proposed_producers_ex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetProposedProducersExResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySetProposedProducersExResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetProposedProducersExResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyIsPrivilegedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyIsPrivilegedArgs() *ApplyIsPrivilegedArgs {
  return &ApplyIsPrivilegedArgs{}
}

var ApplyIsPrivilegedArgs_Account_DEFAULT *Uint64
func (p *ApplyIsPrivilegedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyIsPrivilegedArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyIsPrivilegedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyIsPrivilegedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_privileged_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsPrivilegedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyIsPrivilegedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsPrivilegedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsPrivilegedResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsPrivilegedResult() *ApplyIsPrivilegedResult {
  return &ApplyIsPrivilegedResult{}
}

var ApplyIsPrivilegedResult_Success_DEFAULT bool
func (p *ApplyIsPrivilegedResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsPrivilegedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsPrivilegedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsPrivilegedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsPrivilegedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsPrivilegedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_privileged_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsPrivilegedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsPrivilegedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsPrivilegedResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - IsPriv
type ApplySetPrivilegedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  IsPriv bool `thrift:"is_priv,2" db:"is_priv" json:"is_priv"`
}

func NewApplySetPrivilegedArgs() *ApplySetPrivilegedArgs {
  return &ApplySetPrivilegedArgs{}
}

var ApplySetPrivilegedArgs_Account_DEFAULT *Uint64
func (p *ApplySetPrivilegedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplySetPrivilegedArgs_Account_DEFAULT
  }
return p.Account
}

func (p *ApplySetPrivilegedArgs) GetIsPriv() bool {
  return p.IsPriv
}
func (p *ApplySetPrivilegedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplySetPrivilegedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetPrivilegedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplySetPrivilegedArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IsPriv = v
}
  return nil
}

func (p *ApplySetPrivilegedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_privileged_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetPrivilegedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplySetPrivilegedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "is_priv", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:is_priv: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IsPriv)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.is_priv (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:is_priv: ", p), err) }
  return err
}

func (p *ApplySetPrivilegedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetPrivilegedArgs(%+v)", *p)
}

type ApplySetPrivilegedResult struct {
}

func NewApplySetPrivilegedResult() *ApplySetPrivilegedResult {
  return &ApplySetPrivilegedResult{}
}

func (p *ApplySetPrivilegedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetPrivilegedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_privileged_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetPrivilegedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetPrivilegedResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySetBlockchainParametersPackedArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySetBlockchainParametersPackedArgs() *ApplySetBlockchainParametersPackedArgs {
  return &ApplySetBlockchainParametersPackedArgs{}
}


func (p *ApplySetBlockchainParametersPackedArgs) GetData() []byte {
  return p.Data
}
func (p *ApplySetBlockchainParametersPackedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_blockchain_parameters_packed_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetBlockchainParametersPackedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySetBlockchainParametersPackedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetBlockchainParametersPackedArgs(%+v)", *p)
}

type ApplySetBlockchainParametersPackedResult struct {
}

func NewApplySetBlockchainParametersPackedResult() *ApplySetBlockchainParametersPackedResult {
  return &ApplySetBlockchainParametersPackedResult{}
}

func (p *ApplySetBlockchainParametersPackedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetBlockchainParametersPackedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_blockchain_parameters_packed_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetBlockchainParametersPackedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetBlockchainParametersPackedResult(%+v)", *p)
}

type ApplyGetBlockchainParametersPackedArgs struct {
}

func NewApplyGetBlockchainParametersPackedArgs() *ApplyGetBlockchainParametersPackedArgs {
  return &ApplyGetBlockchainParametersPackedArgs{}
}

func (p *ApplyGetBlockchainParametersPackedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_blockchain_parameters_packed_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockchainParametersPackedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetBlockchainParametersPackedResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetBlockchainParametersPackedResult() *ApplyGetBlockchainParametersPackedResult {
  return &ApplyGetBlockchainParametersPackedResult{}
}

var ApplyGetBlockchainParametersPackedResult_Success_DEFAULT []byte

func (p *ApplyGetBlockchainParametersPackedResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetBlockchainParametersPackedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetBlockchainParametersPackedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_blockchain_parameters_packed_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockchainParametersPackedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetBlockchainParametersPackedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockchainParametersPackedResult(%+v)", *p)
}

// Attributes:
//  - FeatureDigest
type ApplyPreactivateFeatureArgs struct {
  FeatureDigest []byte `thrift:"feature_digest,1" db:"feature_digest" json:"feature_digest"`
}

func NewApplyPreactivateFeatureArgs() *ApplyPreactivateFeatureArgs {
  return &ApplyPreactivateFeatureArgs{}
}


func (p *ApplyPreactivateFeatureArgs) GetFeatureDigest() []byte {
  return p.FeatureDigest
}
func (p *ApplyPreactivateFeatureArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPreactivateFeatureArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FeatureDigest = v
}
  return nil
}

func (p *ApplyPreactivateFeatureArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "preactivate_feature_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPreactivateFeatureArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "feature_digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature_digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.FeatureDigest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.feature_digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature_digest: ", p), err) }
  return err
}

func (p *ApplyPreactivateFeatureArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPreactivateFeatureArgs(%+v)", *p)
}

type ApplyPreactivateFeatureResult struct {
}

func NewApplyPreactivateFeatureResult() *ApplyPreactivateFeatureResult {
  return &ApplyPreactivateFeatureResult{}
}

func (p *ApplyPreactivateFeatureResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPreactivateFeatureResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "preactivate_feature_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPreactivateFeatureResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPreactivateFeatureResult(%+v)", *p)
}

// Attributes:
//  - TrxData
//  - PubkeysData
//  - PermsData
type ApplyCheckTransactionAuthorizationArgs struct {
  TrxData []byte `thrift:"trx_data,1" db:"trx_data" json:"trx_data"`
  PubkeysData []byte `thrift:"pubkeys_data,2" db:"pubkeys_data" json:"pubkeys_data"`
  PermsData []byte `thrift:"perms_data,3" db:"perms_data" json:"perms_data"`
}

func NewApplyCheckTransactionAuthorizationArgs() *ApplyCheckTransactionAuthorizationArgs {
  return &ApplyCheckTransactionAuthorizationArgs{}
}


func (p *ApplyCheckTransactionAuthorizationArgs) GetTrxData() []byte {
  return p.TrxData
}

func (p *ApplyCheckTransactionAuthorizationArgs) GetPubkeysData() []byte {
  return p.PubkeysData
}

func (p *ApplyCheckTransactionAuthorizationArgs) GetPermsData() []byte {
  return p.PermsData
}
func (p *ApplyCheckTransactionAuthorizationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TrxData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PubkeysData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PermsData = v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_transaction_authorization_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "trx_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:trx_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.TrxData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.trx_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:trx_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pubkeys_data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pubkeys_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PubkeysData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pubkeys_data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pubkeys_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "perms_data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:perms_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PermsData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.perms_data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:perms_data: ", p), err) }
  return err
}

func (p *ApplyCheckTransactionAuthorizationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckTransactionAuthorizationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCheckTransactionAuthorizationResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCheckTransactionAuthorizationResult() *ApplyCheckTransactionAuthorizationResult {
  return &ApplyCheckTransactionAuthorizationResult{}
}

var ApplyCheckTransactionAuthorizationResult_Success_DEFAULT int32
func (p *ApplyCheckTransactionAuthorizationResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCheckTransactionAuthorizationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCheckTransactionAuthorizationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCheckTransactionAuthorizationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_transaction_authorization_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckTransactionAuthorizationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCheckTransactionAuthorizationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckTransactionAuthorizationResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - Permission
//  - PubkeysData
//  - PermsData
//  - DelayUs
type ApplyCheckPermissionAuthorizationArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
  PubkeysData []byte `thrift:"pubkeys_data,3" db:"pubkeys_data" json:"pubkeys_data"`
  PermsData []byte `thrift:"perms_data,4" db:"perms_data" json:"perms_data"`
  DelayUs *Uint64 `thrift:"delay_us,5" db:"delay_us" json:"delay_us"`
}

func NewApplyCheckPermissionAuthorizationArgs() *ApplyCheckPermissionAuthorizationArgs {
  return &ApplyCheckPermissionAuthorizationArgs{}
}

var ApplyCheckPermissionAuthorizationArgs_Account_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyCheckPermissionAuthorizationArgs_Account_DEFAULT
  }
return p.Account
}
var ApplyCheckPermissionAuthorizationArgs_Permission_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyCheckPermissionAuthorizationArgs_Permission_DEFAULT
  }
return p.Permission
}

func (p *ApplyCheckPermissionAuthorizationArgs) GetPubkeysData() []byte {
  return p.PubkeysData
}

func (p *ApplyCheckPermissionAuthorizationArgs) GetPermsData() []byte {
  return p.PermsData
}
var ApplyCheckPermissionAuthorizationArgs_DelayUs_DEFAULT *Uint64
func (p *ApplyCheckPermissionAuthorizationArgs) GetDelayUs() *Uint64 {
  if !p.IsSetDelayUs() {
    return ApplyCheckPermissionAuthorizationArgs_DelayUs_DEFAULT
  }
return p.DelayUs
}
func (p *ApplyCheckPermissionAuthorizationArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) IsSetDelayUs() bool {
  return p.DelayUs != nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PubkeysData = v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.PermsData = v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.DelayUs = &Uint64{}
  if err := p.DelayUs.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DelayUs), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_permission_authorization_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pubkeys_data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pubkeys_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PubkeysData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pubkeys_data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pubkeys_data: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "perms_data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:perms_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.PermsData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.perms_data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:perms_data: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "delay_us", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:delay_us: ", p), err) }
  if err := p.DelayUs.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DelayUs), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:delay_us: ", p), err) }
  return err
}

func (p *ApplyCheckPermissionAuthorizationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckPermissionAuthorizationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCheckPermissionAuthorizationResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCheckPermissionAuthorizationResult() *ApplyCheckPermissionAuthorizationResult {
  return &ApplyCheckPermissionAuthorizationResult{}
}

var ApplyCheckPermissionAuthorizationResult_Success_DEFAULT int32
func (p *ApplyCheckPermissionAuthorizationResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCheckPermissionAuthorizationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCheckPermissionAuthorizationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCheckPermissionAuthorizationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "check_permission_authorization_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCheckPermissionAuthorizationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCheckPermissionAuthorizationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCheckPermissionAuthorizationResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - Permission
type ApplyGetPermissionLastUsedArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
}

func NewApplyGetPermissionLastUsedArgs() *ApplyGetPermissionLastUsedArgs {
  return &ApplyGetPermissionLastUsedArgs{}
}

var ApplyGetPermissionLastUsedArgs_Account_DEFAULT *Uint64
func (p *ApplyGetPermissionLastUsedArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetPermissionLastUsedArgs_Account_DEFAULT
  }
return p.Account
}
var ApplyGetPermissionLastUsedArgs_Permission_DEFAULT *Uint64
func (p *ApplyGetPermissionLastUsedArgs) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyGetPermissionLastUsedArgs_Permission_DEFAULT
  }
return p.Permission
}
func (p *ApplyGetPermissionLastUsedArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetPermissionLastUsedArgs) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyGetPermissionLastUsedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_permission_last_used_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetPermissionLastUsedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetPermissionLastUsedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyGetPermissionLastUsedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetPermissionLastUsedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetPermissionLastUsedResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetPermissionLastUsedResult() *ApplyGetPermissionLastUsedResult {
  return &ApplyGetPermissionLastUsedResult{}
}

var ApplyGetPermissionLastUsedResult_Success_DEFAULT int64
func (p *ApplyGetPermissionLastUsedResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyGetPermissionLastUsedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetPermissionLastUsedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetPermissionLastUsedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetPermissionLastUsedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetPermissionLastUsedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_permission_last_used_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetPermissionLastUsedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetPermissionLastUsedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetPermissionLastUsedResult(%+v)", *p)
}

// Attributes:
//  - Account
type ApplyGetAccountCreationTimeArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
}

func NewApplyGetAccountCreationTimeArgs() *ApplyGetAccountCreationTimeArgs {
  return &ApplyGetAccountCreationTimeArgs{}
}

var ApplyGetAccountCreationTimeArgs_Account_DEFAULT *Uint64
func (p *ApplyGetAccountCreationTimeArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetAccountCreationTimeArgs_Account_DEFAULT
  }
return p.Account
}
func (p *ApplyGetAccountCreationTimeArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetAccountCreationTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_creation_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetAccountCreationTimeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetAccountCreationTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetAccountCreationTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetAccountCreationTimeResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetAccountCreationTimeResult() *ApplyGetAccountCreationTimeResult {
  return &ApplyGetAccountCreationTimeResult{}
}

var ApplyGetAccountCreationTimeResult_Success_DEFAULT int64
func (p *ApplyGetAccountCreationTimeResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyGetAccountCreationTimeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetAccountCreationTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetAccountCreationTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetAccountCreationTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetAccountCreationTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_account_creation_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetAccountCreationTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetAccountCreationTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetAccountCreationTimeResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsArgs struct {
  Cstr string `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsArgs() *ApplyPrintsArgs {
  return &ApplyPrintsArgs{}
}


func (p *ApplyPrintsArgs) GetCstr() string {
  return p.Cstr
}
func (p *ApplyPrintsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Cstr)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsArgs(%+v)", *p)
}

type ApplyPrintsResult struct {
}

func NewApplyPrintsResult() *ApplyPrintsResult {
  return &ApplyPrintsResult{}
}

func (p *ApplyPrintsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsLArgs struct {
  Cstr []byte `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsLArgs() *ApplyPrintsLArgs {
  return &ApplyPrintsLArgs{}
}


func (p *ApplyPrintsLArgs) GetCstr() []byte {
  return p.Cstr
}
func (p *ApplyPrintsLArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsLArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Cstr); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsLArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLArgs(%+v)", *p)
}

type ApplyPrintsLResult struct {
}

func NewApplyPrintsLResult() *ApplyPrintsLResult {
  return &ApplyPrintsLResult{}
}

func (p *ApplyPrintsLResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintiArgs struct {
  N int64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintiArgs() *ApplyPrintiArgs {
  return &ApplyPrintiArgs{}
}


func (p *ApplyPrintiArgs) GetN() int64 {
  return p.N
}
func (p *ApplyPrintiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.N = v
}
  return nil
}

func (p *ApplyPrintiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.N)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.n (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiArgs(%+v)", *p)
}

type ApplyPrintiResult struct {
}

func NewApplyPrintiResult() *ApplyPrintiResult {
  return &ApplyPrintiResult{}
}

func (p *ApplyPrintiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintuiArgs struct {
  N *Uint64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintuiArgs() *ApplyPrintuiArgs {
  return &ApplyPrintuiArgs{}
}

var ApplyPrintuiArgs_N_DEFAULT *Uint64
func (p *ApplyPrintuiArgs) GetN() *Uint64 {
  if !p.IsSetN() {
    return ApplyPrintuiArgs_N_DEFAULT
  }
return p.N
}
func (p *ApplyPrintuiArgs) IsSetN() bool {
  return p.N != nil
}

func (p *ApplyPrintuiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.N = &Uint64{}
  if err := p.N.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.N), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := p.N.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.N), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintuiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiArgs(%+v)", *p)
}

type ApplyPrintuiResult struct {
}

func NewApplyPrintuiResult() *ApplyPrintuiResult {
  return &ApplyPrintuiResult{}
}

func (p *ApplyPrintuiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrinti128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrinti128Args() *ApplyPrinti128Args {
  return &ApplyPrinti128Args{}
}


func (p *ApplyPrinti128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrinti128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrinti128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrinti128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Args(%+v)", *p)
}

type ApplyPrinti128Result struct {
}

func NewApplyPrinti128Result() *ApplyPrinti128Result {
  return &ApplyPrinti128Result{}
}

func (p *ApplyPrinti128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintui128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintui128Args() *ApplyPrintui128Args {
  return &ApplyPrintui128Args{}
}


func (p *ApplyPrintui128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintui128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintui128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintui128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Args(%+v)", *p)
}

type ApplyPrintui128Result struct {
}

func NewApplyPrintui128Result() *ApplyPrintui128Result {
  return &ApplyPrintui128Result{}
}

func (p *ApplyPrintui128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintsfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintsfArgs() *ApplyPrintsfArgs {
  return &ApplyPrintsfArgs{}
}


func (p *ApplyPrintsfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintsfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintsfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintsfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfArgs(%+v)", *p)
}

type ApplyPrintsfResult struct {
}

func NewApplyPrintsfResult() *ApplyPrintsfResult {
  return &ApplyPrintsfResult{}
}

func (p *ApplyPrintsfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintdfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintdfArgs() *ApplyPrintdfArgs {
  return &ApplyPrintdfArgs{}
}


func (p *ApplyPrintdfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintdfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintdfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintdfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfArgs(%+v)", *p)
}

type ApplyPrintdfResult struct {
}

func NewApplyPrintdfResult() *ApplyPrintdfResult {
  return &ApplyPrintdfResult{}
}

func (p *ApplyPrintdfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintqfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintqfArgs() *ApplyPrintqfArgs {
  return &ApplyPrintqfArgs{}
}


func (p *ApplyPrintqfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintqfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintqfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintqfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfArgs(%+v)", *p)
}

type ApplyPrintqfResult struct {
}

func NewApplyPrintqfResult() *ApplyPrintqfResult {
  return &ApplyPrintqfResult{}
}

func (p *ApplyPrintqfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyPrintnArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyPrintnArgs() *ApplyPrintnArgs {
  return &ApplyPrintnArgs{}
}

var ApplyPrintnArgs_Name_DEFAULT *Uint64
func (p *ApplyPrintnArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyPrintnArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyPrintnArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyPrintnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyPrintnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyPrintnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnArgs(%+v)", *p)
}

type ApplyPrintnResult struct {
}

func NewApplyPrintnResult() *ApplyPrintnResult {
  return &ApplyPrintnResult{}
}

func (p *ApplyPrintnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyPrinthexArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyPrinthexArgs() *ApplyPrinthexArgs {
  return &ApplyPrinthexArgs{}
}


func (p *ApplyPrinthexArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyPrinthexArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyPrinthexArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyPrinthexArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexArgs(%+v)", *p)
}

type ApplyPrinthexResult struct {
}

func NewApplyPrinthexResult() *ApplyPrinthexResult {
  return &ApplyPrinthexResult{}
}

func (p *ApplyPrinthexResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexResult(%+v)", *p)
}

type ApplyActionDataSizeArgs struct {
}

func NewApplyActionDataSizeArgs() *ApplyActionDataSizeArgs {
  return &ApplyActionDataSizeArgs{}
}

func (p *ApplyActionDataSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyActionDataSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyActionDataSizeResult() *ApplyActionDataSizeResult {
  return &ApplyActionDataSizeResult{}
}

var ApplyActionDataSizeResult_Success_DEFAULT int32
func (p *ApplyActionDataSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyActionDataSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyActionDataSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyActionDataSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyActionDataSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyActionDataSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeResult(%+v)", *p)
}

type ApplyReadActionDataArgs struct {
}

func NewApplyReadActionDataArgs() *ApplyReadActionDataArgs {
  return &ApplyReadActionDataArgs{}
}

func (p *ApplyReadActionDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadActionDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadActionDataResult() *ApplyReadActionDataResult {
  return &ApplyReadActionDataResult{}
}

var ApplyReadActionDataResult_Success_DEFAULT []byte

func (p *ApplyReadActionDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadActionDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadActionDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadActionDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadActionDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireRecipientArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireRecipientArgs() *ApplyRequireRecipientArgs {
  return &ApplyRequireRecipientArgs{}
}

var ApplyRequireRecipientArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireRecipientArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireRecipientArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireRecipientArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireRecipientArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireRecipientArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientArgs(%+v)", *p)
}

type ApplyRequireRecipientResult struct {
}

func NewApplyRequireRecipientResult() *ApplyRequireRecipientResult {
  return &ApplyRequireRecipientResult{}
}

func (p *ApplyRequireRecipientResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireAuthArgs() *ApplyRequireAuthArgs {
  return &ApplyRequireAuthArgs{}
}

var ApplyRequireAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthArgs(%+v)", *p)
}

type ApplyRequireAuthResult struct {
}

func NewApplyRequireAuthResult() *ApplyRequireAuthResult {
  return &ApplyRequireAuthResult{}
}

func (p *ApplyRequireAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyHasAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyHasAuthArgs() *ApplyHasAuthArgs {
  return &ApplyHasAuthArgs{}
}

var ApplyHasAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyHasAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyHasAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyHasAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyHasAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyHasAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyHasAuthResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyHasAuthResult() *ApplyHasAuthResult {
  return &ApplyHasAuthResult{}
}

var ApplyHasAuthResult_Success_DEFAULT bool
func (p *ApplyHasAuthResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyHasAuthResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyHasAuthResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyHasAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyHasAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyHasAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
//  - Permission
type ApplyRequireAuth2Args struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
}

func NewApplyRequireAuth2Args() *ApplyRequireAuth2Args {
  return &ApplyRequireAuth2Args{}
}

var ApplyRequireAuth2Args_Name_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuth2Args_Name_DEFAULT
  }
return p.Name
}
var ApplyRequireAuth2Args_Permission_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyRequireAuth2Args_Permission_DEFAULT
  }
return p.Permission
}
func (p *ApplyRequireAuth2Args) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuth2Args) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyRequireAuth2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Args(%+v)", *p)
}

type ApplyRequireAuth2Result struct {
}

func NewApplyRequireAuth2Result() *ApplyRequireAuth2Result {
  return &ApplyRequireAuth2Result{}
}

func (p *ApplyRequireAuth2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Result(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyIsAccountArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyIsAccountArgs() *ApplyIsAccountArgs {
  return &ApplyIsAccountArgs{}
}

var ApplyIsAccountArgs_Name_DEFAULT *Uint64
func (p *ApplyIsAccountArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyIsAccountArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyIsAccountArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyIsAccountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyIsAccountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsAccountResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsAccountResult() *ApplyIsAccountResult {
  return &ApplyIsAccountResult{}
}

var ApplyIsAccountResult_Success_DEFAULT bool
func (p *ApplyIsAccountResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsAccountResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsAccountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsAccountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsAccountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsAccountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountResult(%+v)", *p)
}

// Attributes:
//  - SerializedAction
type ApplySendInlineArgs struct {
  SerializedAction []byte `thrift:"serialized_action,1" db:"serialized_action" json:"serialized_action"`
}

func NewApplySendInlineArgs() *ApplySendInlineArgs {
  return &ApplySendInlineArgs{}
}


func (p *ApplySendInlineArgs) GetSerializedAction() []byte {
  return p.SerializedAction
}
func (p *ApplySendInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedAction = v
}
  return nil
}

func (p *ApplySendInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_action", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_action: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedAction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_action (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_action: ", p), err) }
  return err
}

func (p *ApplySendInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineArgs(%+v)", *p)
}

type ApplySendInlineResult struct {
}

func NewApplySendInlineResult() *ApplySendInlineResult {
  return &ApplySendInlineResult{}
}

func (p *ApplySendInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineResult(%+v)", *p)
}

// Attributes:
//  - SerializedData
type ApplySendContextFreeInlineArgs struct {
  SerializedData []byte `thrift:"serialized_data,1" db:"serialized_data" json:"serialized_data"`
}

func NewApplySendContextFreeInlineArgs() *ApplySendContextFreeInlineArgs {
  return &ApplySendContextFreeInlineArgs{}
}


func (p *ApplySendContextFreeInlineArgs) GetSerializedData() []byte {
  return p.SerializedData
}
func (p *ApplySendContextFreeInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedData = v
}
  return nil
}

func (p *ApplySendContextFreeInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_data: ", p), err) }
  return err
}

func (p *ApplySendContextFreeInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineArgs(%+v)", *p)
}

type ApplySendContextFreeInlineResult struct {
}

func NewApplySendContextFreeInlineResult() *ApplySendContextFreeInlineResult {
  return &ApplySendContextFreeInlineResult{}
}

func (p *ApplySendContextFreeInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineResult(%+v)", *p)
}

type ApplyPublicationTimeArgs struct {
}

func NewApplyPublicationTimeArgs() *ApplyPublicationTimeArgs {
  return &ApplyPublicationTimeArgs{}
}

func (p *ApplyPublicationTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyPublicationTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyPublicationTimeResult() *ApplyPublicationTimeResult {
  return &ApplyPublicationTimeResult{}
}

var ApplyPublicationTimeResult_Success_DEFAULT *Uint64
func (p *ApplyPublicationTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyPublicationTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyPublicationTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyPublicationTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyPublicationTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeResult(%+v)", *p)
}

type ApplyCurrentReceiverArgs struct {
}

func NewApplyCurrentReceiverArgs() *ApplyCurrentReceiverArgs {
  return &ApplyCurrentReceiverArgs{}
}

func (p *ApplyCurrentReceiverArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentReceiverResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentReceiverResult() *ApplyCurrentReceiverResult {
  return &ApplyCurrentReceiverResult{}
}

var ApplyCurrentReceiverResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentReceiverResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentReceiverResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentReceiverResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentReceiverResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentReceiverResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertArgs() *ApplyEosioAssertArgs {
  return &ApplyEosioAssertArgs{}
}


func (p *ApplyEosioAssertArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertArgs(%+v)", *p)
}

type ApplyEosioAssertResult struct {
}

func NewApplyEosioAssertResult() *ApplyEosioAssertResult {
  return &ApplyEosioAssertResult{}
}

func (p *ApplyEosioAssertResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertMessageArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertMessageArgs() *ApplyEosioAssertMessageArgs {
  return &ApplyEosioAssertMessageArgs{}
}


func (p *ApplyEosioAssertMessageArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertMessageArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertMessageArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageArgs(%+v)", *p)
}

type ApplyEosioAssertMessageResult struct {
}

func NewApplyEosioAssertMessageResult() *ApplyEosioAssertMessageResult {
  return &ApplyEosioAssertMessageResult{}
}

func (p *ApplyEosioAssertMessageResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Code
type ApplyEosioAssertCodeArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Code *Uint64 `thrift:"code,2" db:"code" json:"code"`
}

func NewApplyEosioAssertCodeArgs() *ApplyEosioAssertCodeArgs {
  return &ApplyEosioAssertCodeArgs{}
}


func (p *ApplyEosioAssertCodeArgs) GetTest() bool {
  return p.Test
}
var ApplyEosioAssertCodeArgs_Code_DEFAULT *Uint64
func (p *ApplyEosioAssertCodeArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyEosioAssertCodeArgs_Code_DEFAULT
  }
return p.Code
}
func (p *ApplyEosioAssertCodeArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyEosioAssertCodeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:code: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeArgs(%+v)", *p)
}

type ApplyEosioAssertCodeResult struct {
}

func NewApplyEosioAssertCodeResult() *ApplyEosioAssertCodeResult {
  return &ApplyEosioAssertCodeResult{}
}

func (p *ApplyEosioAssertCodeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeResult(%+v)", *p)
}

// Attributes:
//  - Code
type ApplyEosioExitArgs struct {
  Code int32 `thrift:"code,1" db:"code" json:"code"`
}

func NewApplyEosioExitArgs() *ApplyEosioExitArgs {
  return &ApplyEosioExitArgs{}
}


func (p *ApplyEosioExitArgs) GetCode() int32 {
  return p.Code
}
func (p *ApplyEosioExitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *ApplyEosioExitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyEosioExitArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitArgs(%+v)", *p)
}

type ApplyEosioExitResult struct {
}

func NewApplyEosioExitResult() *ApplyEosioExitResult {
  return &ApplyEosioExitResult{}
}

func (p *ApplyEosioExitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitResult(%+v)", *p)
}

type ApplyCurrentTimeArgs struct {
}

func NewApplyCurrentTimeArgs() *ApplyCurrentTimeArgs {
  return &ApplyCurrentTimeArgs{}
}

func (p *ApplyCurrentTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentTimeResult() *ApplyCurrentTimeResult {
  return &ApplyCurrentTimeResult{}
}

var ApplyCurrentTimeResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeResult(%+v)", *p)
}

// Attributes:
//  - FeatureDigest
type ApplyIsFeatureActivatedArgs struct {
  FeatureDigest []byte `thrift:"feature_digest,1" db:"feature_digest" json:"feature_digest"`
}

func NewApplyIsFeatureActivatedArgs() *ApplyIsFeatureActivatedArgs {
  return &ApplyIsFeatureActivatedArgs{}
}


func (p *ApplyIsFeatureActivatedArgs) GetFeatureDigest() []byte {
  return p.FeatureDigest
}
func (p *ApplyIsFeatureActivatedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FeatureDigest = v
}
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "feature_digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature_digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.FeatureDigest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.feature_digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature_digest: ", p), err) }
  return err
}

func (p *ApplyIsFeatureActivatedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsFeatureActivatedResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsFeatureActivatedResult() *ApplyIsFeatureActivatedResult {
  return &ApplyIsFeatureActivatedResult{}
}

var ApplyIsFeatureActivatedResult_Success_DEFAULT bool
func (p *ApplyIsFeatureActivatedResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsFeatureActivatedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsFeatureActivatedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsFeatureActivatedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsFeatureActivatedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsFeatureActivatedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedResult(%+v)", *p)
}

type ApplyGetSenderArgs struct {
}

func NewApplyGetSenderArgs() *ApplyGetSenderArgs {
  return &ApplyGetSenderArgs{}
}

func (p *ApplyGetSenderArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetSenderResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetSenderResult() *ApplyGetSenderResult {
  return &ApplyGetSenderResult{}
}

var ApplyGetSenderResult_Success_DEFAULT *Uint64
func (p *ApplyGetSenderResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyGetSenderResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyGetSenderResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetSenderResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyGetSenderResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetSenderResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderResult(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha256Args() *ApplyAssertSha256Args {
  return &ApplyAssertSha256Args{}
}


func (p *ApplyAssertSha256Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha256Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Args(%+v)", *p)
}

type ApplyAssertSha256Result struct {
}

func NewApplyAssertSha256Result() *ApplyAssertSha256Result {
  return &ApplyAssertSha256Result{}
}

func (p *ApplyAssertSha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha1Args() *ApplyAssertSha1Args {
  return &ApplyAssertSha1Args{}
}


func (p *ApplyAssertSha1Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha1Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Args(%+v)", *p)
}

type ApplyAssertSha1Result struct {
}

func NewApplyAssertSha1Result() *ApplyAssertSha1Result {
  return &ApplyAssertSha1Result{}
}

func (p *ApplyAssertSha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha512Args() *ApplyAssertSha512Args {
  return &ApplyAssertSha512Args{}
}


func (p *ApplyAssertSha512Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha512Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Args(%+v)", *p)
}

type ApplyAssertSha512Result struct {
}

func NewApplyAssertSha512Result() *ApplyAssertSha512Result {
  return &ApplyAssertSha512Result{}
}

func (p *ApplyAssertSha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertRipemd160Args() *ApplyAssertRipemd160Args {
  return &ApplyAssertRipemd160Args{}
}


func (p *ApplyAssertRipemd160Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertRipemd160Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Args(%+v)", *p)
}

type ApplyAssertRipemd160Result struct {
}

func NewApplyAssertRipemd160Result() *ApplyAssertRipemd160Result {
  return &ApplyAssertRipemd160Result{}
}

func (p *ApplyAssertRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha256Args() *ApplySha256Args {
  return &ApplySha256Args{}
}


func (p *ApplySha256Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha256Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha256Result() *ApplySha256Result {
  return &ApplySha256Result{}
}

var ApplySha256Result_Success_DEFAULT []byte

func (p *ApplySha256Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha256Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha1Args() *ApplySha1Args {
  return &ApplySha1Args{}
}


func (p *ApplySha1Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha1Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha1Result() *ApplySha1Result {
  return &ApplySha1Result{}
}

var ApplySha1Result_Success_DEFAULT []byte

func (p *ApplySha1Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha1Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha512Args() *ApplySha512Args {
  return &ApplySha512Args{}
}


func (p *ApplySha512Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha512Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha512Result() *ApplySha512Result {
  return &ApplySha512Result{}
}

var ApplySha512Result_Success_DEFAULT []byte

func (p *ApplySha512Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha512Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyRipemd160Args() *ApplyRipemd160Args {
  return &ApplyRipemd160Args{}
}


func (p *ApplyRipemd160Args) GetData() []byte {
  return p.Data
}
func (p *ApplyRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRipemd160Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRipemd160Result() *ApplyRipemd160Result {
  return &ApplyRipemd160Result{}
}

var ApplyRipemd160Result_Success_DEFAULT []byte

func (p *ApplyRipemd160Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRipemd160Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
type ApplyRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
}

func NewApplyRecoverKeyArgs() *ApplyRecoverKeyArgs {
  return &ApplyRecoverKeyArgs{}
}


func (p *ApplyRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}
func (p *ApplyRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRecoverKeyResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRecoverKeyResult() *ApplyRecoverKeyResult {
  return &ApplyRecoverKeyResult{}
}

var ApplyRecoverKeyResult_Success_DEFAULT []byte

func (p *ApplyRecoverKeyResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRecoverKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
//  - Pub
type ApplyAssertRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
  Pub []byte `thrift:"pub,3" db:"pub" json:"pub"`
}

func NewApplyAssertRecoverKeyArgs() *ApplyAssertRecoverKeyArgs {
  return &ApplyAssertRecoverKeyArgs{}
}


func (p *ApplyAssertRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyAssertRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}

func (p *ApplyAssertRecoverKeyArgs) GetPub() []byte {
  return p.Pub
}
func (p *ApplyAssertRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pub = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pub", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pub: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Pub); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pub (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pub: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyArgs(%+v)", *p)
}

type ApplyAssertRecoverKeyResult struct {
}

func NewApplyAssertRecoverKeyResult() *ApplyAssertRecoverKeyResult {
  return &ApplyAssertRecoverKeyResult{}
}

func (p *ApplyAssertRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
type ApplySendDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  SerializedTransaction []byte `thrift:"serialized_transaction,3" db:"serialized_transaction" json:"serialized_transaction"`
  ReplaceExisting int32 `thrift:"replace_existing,4" db:"replace_existing" json:"replace_existing"`
}

func NewApplySendDeferredArgs() *ApplySendDeferredArgs {
  return &ApplySendDeferredArgs{}
}


func (p *ApplySendDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
var ApplySendDeferredArgs_Payer_DEFAULT *Uint64
func (p *ApplySendDeferredArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplySendDeferredArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplySendDeferredArgs) GetSerializedTransaction() []byte {
  return p.SerializedTransaction
}

func (p *ApplySendDeferredArgs) GetReplaceExisting() int32 {
  return p.ReplaceExisting
}
func (p *ApplySendDeferredArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplySendDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.SerializedTransaction = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ReplaceExisting = v
}
  return nil
}

func (p *ApplySendDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_transaction", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serialized_transaction: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedTransaction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_transaction (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serialized_transaction: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "replace_existing", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:replace_existing: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ReplaceExisting)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.replace_existing (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:replace_existing: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredArgs(%+v)", *p)
}

type ApplySendDeferredResult struct {
}

func NewApplySendDeferredResult() *ApplySendDeferredResult {
  return &ApplySendDeferredResult{}
}

func (p *ApplySendDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredResult(%+v)", *p)
}

// Attributes:
//  - SenderID
type ApplyCancelDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
}

func NewApplyCancelDeferredArgs() *ApplyCancelDeferredArgs {
  return &ApplyCancelDeferredArgs{}
}


func (p *ApplyCancelDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
func (p *ApplyCancelDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplyCancelDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplyCancelDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCancelDeferredResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCancelDeferredResult() *ApplyCancelDeferredResult {
  return &ApplyCancelDeferredResult{}
}

var ApplyCancelDeferredResult_Success_DEFAULT int32
func (p *ApplyCancelDeferredResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCancelDeferredResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCancelDeferredResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCancelDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCancelDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCancelDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredResult(%+v)", *p)
}

type ApplyReadTransactionArgs struct {
}

func NewApplyReadTransactionArgs() *ApplyReadTransactionArgs {
  return &ApplyReadTransactionArgs{}
}

func (p *ApplyReadTransactionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadTransactionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadTransactionResult() *ApplyReadTransactionResult {
  return &ApplyReadTransactionResult{}
}

var ApplyReadTransactionResult_Success_DEFAULT []byte

func (p *ApplyReadTransactionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadTransactionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadTransactionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadTransactionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadTransactionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionResult(%+v)", *p)
}

type ApplyTransactionSizeArgs struct {
}

func NewApplyTransactionSizeArgs() *ApplyTransactionSizeArgs {
  return &ApplyTransactionSizeArgs{}
}

func (p *ApplyTransactionSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTransactionSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTransactionSizeResult() *ApplyTransactionSizeResult {
  return &ApplyTransactionSizeResult{}
}

var ApplyTransactionSizeResult_Success_DEFAULT int32
func (p *ApplyTransactionSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTransactionSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTransactionSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTransactionSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTransactionSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTransactionSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeResult(%+v)", *p)
}

type ApplyTaposBlockNumArgs struct {
}

func NewApplyTaposBlockNumArgs() *ApplyTaposBlockNumArgs {
  return &ApplyTaposBlockNumArgs{}
}

func (p *ApplyTaposBlockNumArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockNumResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockNumResult() *ApplyTaposBlockNumResult {
  return &ApplyTaposBlockNumResult{}
}

var ApplyTaposBlockNumResult_Success_DEFAULT int32
func (p *ApplyTaposBlockNumResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockNumResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockNumResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockNumResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockNumResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockNumResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumResult(%+v)", *p)
}

type ApplyTaposBlockPrefixArgs struct {
}

func NewApplyTaposBlockPrefixArgs() *ApplyTaposBlockPrefixArgs {
  return &ApplyTaposBlockPrefixArgs{}
}

func (p *ApplyTaposBlockPrefixArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockPrefixResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockPrefixResult() *ApplyTaposBlockPrefixResult {
  return &ApplyTaposBlockPrefixResult{}
}

var ApplyTaposBlockPrefixResult_Success_DEFAULT int32
func (p *ApplyTaposBlockPrefixResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockPrefixResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockPrefixResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockPrefixResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockPrefixResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockPrefixResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixResult(%+v)", *p)
}

type ApplyExpirationArgs struct {
}

func NewApplyExpirationArgs() *ApplyExpirationArgs {
  return &ApplyExpirationArgs{}
}

func (p *ApplyExpirationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyExpirationResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyExpirationResult() *ApplyExpirationResult {
  return &ApplyExpirationResult{}
}

var ApplyExpirationResult_Success_DEFAULT int64
func (p *ApplyExpirationResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyExpirationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyExpirationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyExpirationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyExpirationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyExpirationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationResult(%+v)", *p)
}

// Attributes:
//  - _type
//  - Index
type ApplyGetActionArgs struct {
  _type int32 `thrift:"_type,1" db:"_type" json:"_type"`
  Index int32 `thrift:"index,2" db:"index" json:"index"`
}

func NewApplyGetActionArgs() *ApplyGetActionArgs {
  return &ApplyGetActionArgs{}
}


func (p *ApplyGetActionArgs) Get_type() int32 {
  return p._type
}

func (p *ApplyGetActionArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p._type = v
}
  return nil
}

func (p *ApplyGetActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "_type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:_type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p._type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T._type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:_type: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:index: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetActionResult() *ApplyGetActionResult {
  return &ApplyGetActionResult{}
}

var ApplyGetActionResult_Success_DEFAULT []byte

func (p *ApplyGetActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionResult(%+v)", *p)
}

// Attributes:
//  - Index
type ApplyGetContextFreeDataArgs struct {
  Index int32 `thrift:"index,1" db:"index" json:"index"`
}

func NewApplyGetContextFreeDataArgs() *ApplyGetContextFreeDataArgs {
  return &ApplyGetContextFreeDataArgs{}
}


func (p *ApplyGetContextFreeDataArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetContextFreeDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetContextFreeDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:index: ", p), err) }
  return err
}

func (p *ApplyGetContextFreeDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetContextFreeDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetContextFreeDataResult() *ApplyGetContextFreeDataResult {
  return &ApplyGetContextFreeDataResult{}
}

var ApplyGetContextFreeDataResult_Success_DEFAULT []byte

func (p *ApplyGetContextFreeDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetContextFreeDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetContextFreeDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetContextFreeDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetContextFreeDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbStoreI64Args struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbStoreI64Args() *ApplyDbStoreI64Args {
  return &ApplyDbStoreI64Args{}
}

var ApplyDbStoreI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbStoreI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbStoreI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbStoreI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbStoreI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbStoreI64Args_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbStoreI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbStoreI64Args_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbStoreI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbStoreI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbStoreI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbStoreI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbStoreI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbStoreI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbStoreI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbStoreI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbStoreI64Result() *ApplyDbStoreI64Result {
  return &ApplyDbStoreI64Result{}
}

var ApplyDbStoreI64Result_Success_DEFAULT int32
func (p *ApplyDbStoreI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbStoreI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbStoreI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbStoreI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbStoreI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbStoreI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbUpdateI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbUpdateI64Args() *ApplyDbUpdateI64Args {
  return &ApplyDbUpdateI64Args{}
}


func (p *ApplyDbUpdateI64Args) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbUpdateI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbUpdateI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbUpdateI64Args_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbUpdateI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbUpdateI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbUpdateI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Args(%+v)", *p)
}

type ApplyDbUpdateI64Result struct {
}

func NewApplyDbUpdateI64Result() *ApplyDbUpdateI64Result {
  return &ApplyDbUpdateI64Result{}
}

func (p *ApplyDbUpdateI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbRemoveI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbRemoveI64Args() *ApplyDbRemoveI64Args {
  return &ApplyDbRemoveI64Args{}
}


func (p *ApplyDbRemoveI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbRemoveI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbRemoveI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbRemoveI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Args(%+v)", *p)
}

type ApplyDbRemoveI64Result struct {
}

func NewApplyDbRemoveI64Result() *ApplyDbRemoveI64Result {
  return &ApplyDbRemoveI64Result{}
}

func (p *ApplyDbRemoveI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbGetI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbGetI64Args() *ApplyDbGetI64Args {
  return &ApplyDbGetI64Args{}
}


func (p *ApplyDbGetI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbGetI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbGetI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbGetI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbGetI64Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbGetI64Result() *ApplyDbGetI64Result {
  return &ApplyDbGetI64Result{}
}

var ApplyDbGetI64Result_Success_DEFAULT []byte

func (p *ApplyDbGetI64Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyDbGetI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbGetI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyDbGetI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbGetI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbNextI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbNextI64Args() *ApplyDbNextI64Args {
  return &ApplyDbNextI64Args{}
}


func (p *ApplyDbNextI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbNextI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbNextI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbNextI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbNextI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbNextI64Result() *ApplyDbNextI64Result {
  return &ApplyDbNextI64Result{}
}

var ApplyDbNextI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbNextI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbNextI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbNextI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbNextI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbNextI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbPreviousI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbPreviousI64Args() *ApplyDbPreviousI64Args {
  return &ApplyDbPreviousI64Args{}
}


func (p *ApplyDbPreviousI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbPreviousI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbPreviousI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbPreviousI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbPreviousI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbPreviousI64Result() *ApplyDbPreviousI64Result {
  return &ApplyDbPreviousI64Result{}
}

var ApplyDbPreviousI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbPreviousI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbPreviousI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbPreviousI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbPreviousI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbPreviousI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbFindI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbFindI64Args() *ApplyDbFindI64Args {
  return &ApplyDbFindI64Args{}
}

var ApplyDbFindI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbFindI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbFindI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbFindI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbFindI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbFindI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbFindI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbFindI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbFindI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbFindI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbFindI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbFindI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbFindI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbFindI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbFindI64Result() *ApplyDbFindI64Result {
  return &ApplyDbFindI64Result{}
}

var ApplyDbFindI64Result_Success_DEFAULT int32
func (p *ApplyDbFindI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbFindI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbFindI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbFindI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbFindI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbFindI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbLowerboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbLowerboundI64Args() *ApplyDbLowerboundI64Args {
  return &ApplyDbLowerboundI64Args{}
}

var ApplyDbLowerboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbLowerboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbLowerboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbLowerboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbLowerboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbLowerboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbLowerboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbLowerboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbLowerboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbLowerboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbLowerboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbLowerboundI64Result() *ApplyDbLowerboundI64Result {
  return &ApplyDbLowerboundI64Result{}
}

var ApplyDbLowerboundI64Result_Success_DEFAULT int32
func (p *ApplyDbLowerboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbLowerboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbLowerboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbLowerboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbLowerboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbLowerboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbUpperboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbUpperboundI64Args() *ApplyDbUpperboundI64Args {
  return &ApplyDbUpperboundI64Args{}
}

var ApplyDbUpperboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbUpperboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbUpperboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbUpperboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbUpperboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbUpperboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbUpperboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbUpperboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbUpperboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbUpperboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbUpperboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbUpperboundI64Result() *ApplyDbUpperboundI64Result {
  return &ApplyDbUpperboundI64Result{}
}

var ApplyDbUpperboundI64Result_Success_DEFAULT int32
func (p *ApplyDbUpperboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbUpperboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbUpperboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbUpperboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbUpperboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbUpperboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbEndI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbEndI64Args() *ApplyDbEndI64Args {
  return &ApplyDbEndI64Args{}
}

var ApplyDbEndI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbEndI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbEndI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbEndI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbEndI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbEndI64Args_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbEndI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbEndI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbEndI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbEndI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbEndI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbEndI64Result() *ApplyDbEndI64Result {
  return &ApplyDbEndI64Result{}
}

var ApplyDbEndI64Result_Success_DEFAULT int32
func (p *ApplyDbEndI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbEndI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbEndI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbEndI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbEndI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbEndI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Result(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx64StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary *Uint64 `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64StoreArgs() *ApplyDbIdx64StoreArgs {
  return &ApplyDbIdx64StoreArgs{}
}

var ApplyDbIdx64StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx64StoreArgs_ID_DEFAULT
  }
return p.ID
}
var ApplyDbIdx64StoreArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64StoreArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64StoreResult() *ApplyDbIdx64StoreResult {
  return &ApplyDbIdx64StoreResult{}
}

var ApplyDbIdx64StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx64StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx64UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary *Uint64 `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64UpdateArgs() *ApplyDbIdx64UpdateArgs {
  return &ApplyDbIdx64UpdateArgs{}
}


func (p *ApplyDbIdx64UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx64UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64UpdateArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpdateArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64UpdateArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateArgs(%+v)", *p)
}

type ApplyDbIdx64UpdateResult struct {
}

func NewApplyDbIdx64UpdateResult() *ApplyDbIdx64UpdateResult {
  return &ApplyDbIdx64UpdateResult{}
}

func (p *ApplyDbIdx64UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64RemoveArgs() *ApplyDbIdx64RemoveArgs {
  return &ApplyDbIdx64RemoveArgs{}
}


func (p *ApplyDbIdx64RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveArgs(%+v)", *p)
}

type ApplyDbIdx64RemoveResult struct {
}

func NewApplyDbIdx64RemoveResult() *ApplyDbIdx64RemoveResult {
  return &ApplyDbIdx64RemoveResult{}
}

func (p *ApplyDbIdx64RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64NextArgs() *ApplyDbIdx64NextArgs {
  return &ApplyDbIdx64NextArgs{}
}


func (p *ApplyDbIdx64NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64NextResult() *ApplyDbIdx64NextResult {
  return &ApplyDbIdx64NextResult{}
}

var ApplyDbIdx64NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextResult(%+v)", *p)
}

// Attributes:
//  - Iteratory
type ApplyDbIdx64PreviousArgs struct {
  Iteratory int32 `thrift:"iteratory,1" db:"iteratory" json:"iteratory"`
}

func NewApplyDbIdx64PreviousArgs() *ApplyDbIdx64PreviousArgs {
  return &ApplyDbIdx64PreviousArgs{}
}


func (p *ApplyDbIdx64PreviousArgs) GetIteratory() int32 {
  return p.Iteratory
}
func (p *ApplyDbIdx64PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iteratory = v
}
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iteratory", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iteratory: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iteratory)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iteratory (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iteratory: ", p), err) }
  return err
}

func (p *ApplyDbIdx64PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64PreviousResult() *ApplyDbIdx64PreviousResult {
  return &ApplyDbIdx64PreviousResult{}
}

var ApplyDbIdx64PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx64FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx64FindPrimaryArgs() *ApplyDbIdx64FindPrimaryArgs {
  return &ApplyDbIdx64FindPrimaryArgs{}
}

var ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindPrimaryResult() *ApplyDbIdx64FindPrimaryResult {
  return &ApplyDbIdx64FindPrimaryResult{}
}

var ApplyDbIdx64FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx64FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx64FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64FindSecondaryArgs() *ApplyDbIdx64FindSecondaryArgs {
  return &ApplyDbIdx64FindSecondaryArgs{}
}

var ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindSecondaryResult() *ApplyDbIdx64FindSecondaryResult {
  return &ApplyDbIdx64FindSecondaryResult{}
}

var ApplyDbIdx64FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx64FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64LowerboundArgs() *ApplyDbIdx64LowerboundArgs {
  return &ApplyDbIdx64LowerboundArgs{}
}

var ApplyDbIdx64LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64LowerboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64LowerboundResult() *ApplyDbIdx64LowerboundResult {
  return &ApplyDbIdx64LowerboundResult{}
}

var ApplyDbIdx64LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64UpperboundArgs() *ApplyDbIdx64UpperboundArgs {
  return &ApplyDbIdx64UpperboundArgs{}
}

var ApplyDbIdx64UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64UpperboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64UpperboundResult() *ApplyDbIdx64UpperboundResult {
  return &ApplyDbIdx64UpperboundResult{}
}

var ApplyDbIdx64UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx64EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx64EndArgs() *ApplyDbIdx64EndArgs {
  return &ApplyDbIdx64EndArgs{}
}

var ApplyDbIdx64EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx64EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64EndResult() *ApplyDbIdx64EndResult {
  return &ApplyDbIdx64EndResult{}
}

var ApplyDbIdx64EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx64EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx128StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128StoreArgs() *ApplyDbIdx128StoreArgs {
  return &ApplyDbIdx128StoreArgs{}
}

var ApplyDbIdx128StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx128StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx128StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx128StoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx128StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128StoreResult() *ApplyDbIdx128StoreResult {
  return &ApplyDbIdx128StoreResult{}
}

var ApplyDbIdx128StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx128StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx128UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128UpdateArgs() *ApplyDbIdx128UpdateArgs {
  return &ApplyDbIdx128UpdateArgs{}
}


func (p *ApplyDbIdx128UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx128UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx128UpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateArgs(%+v)", *p)
}

type ApplyDbIdx128UpdateResult struct {
}

func NewApplyDbIdx128UpdateResult() *ApplyDbIdx128UpdateResult {
  return &ApplyDbIdx128UpdateResult{}
}

func (p *ApplyDbIdx128UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128RemoveArgs() *ApplyDbIdx128RemoveArgs {
  return &ApplyDbIdx128RemoveArgs{}
}


func (p *ApplyDbIdx128RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveArgs(%+v)", *p)
}

type ApplyDbIdx128RemoveResult struct {
}

func NewApplyDbIdx128RemoveResult() *ApplyDbIdx128RemoveResult {
  return &ApplyDbIdx128RemoveResult{}
}

func (p *ApplyDbIdx128RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128NextArgs() *ApplyDbIdx128NextArgs {
  return &ApplyDbIdx128NextArgs{}
}


func (p *ApplyDbIdx128NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128NextResult() *ApplyDbIdx128NextResult {
  return &ApplyDbIdx128NextResult{}
}

var ApplyDbIdx128NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128PreviousArgs() *ApplyDbIdx128PreviousArgs {
  return &ApplyDbIdx128PreviousArgs{}
}


func (p *ApplyDbIdx128PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128PreviousResult() *ApplyDbIdx128PreviousResult {
  return &ApplyDbIdx128PreviousResult{}
}

var ApplyDbIdx128PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx128FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx128FindPrimaryArgs() *ApplyDbIdx128FindPrimaryArgs {
  return &ApplyDbIdx128FindPrimaryArgs{}
}

var ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindPrimaryResult() *ApplyDbIdx128FindPrimaryResult {
  return &ApplyDbIdx128FindPrimaryResult{}
}

var ApplyDbIdx128FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx128FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx128FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128FindSecondaryArgs() *ApplyDbIdx128FindSecondaryArgs {
  return &ApplyDbIdx128FindSecondaryArgs{}
}

var ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128FindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindSecondaryResult() *ApplyDbIdx128FindSecondaryResult {
  return &ApplyDbIdx128FindSecondaryResult{}
}

var ApplyDbIdx128FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx128FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128LowerboundArgs() *ApplyDbIdx128LowerboundArgs {
  return &ApplyDbIdx128LowerboundArgs{}
}

var ApplyDbIdx128LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128LowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128LowerboundResult() *ApplyDbIdx128LowerboundResult {
  return &ApplyDbIdx128LowerboundResult{}
}

var ApplyDbIdx128LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128UpperboundArgs() *ApplyDbIdx128UpperboundArgs {
  return &ApplyDbIdx128UpperboundArgs{}
}

var ApplyDbIdx128UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128UpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128UpperboundResult() *ApplyDbIdx128UpperboundResult {
  return &ApplyDbIdx128UpperboundResult{}
}

var ApplyDbIdx128UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx128EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx128EndArgs() *ApplyDbIdx128EndArgs {
  return &ApplyDbIdx128EndArgs{}
}

var ApplyDbIdx128EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx128EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128EndResult() *ApplyDbIdx128EndResult {
  return &ApplyDbIdx128EndResult{}
}

var ApplyDbIdx128EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx128EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbIdx256StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbIdx256StoreArgs() *ApplyDbIdx256StoreArgs {
  return &ApplyDbIdx256StoreArgs{}
}

var ApplyDbIdx256StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx256StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx256StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx256StoreArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx256StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256StoreResult() *ApplyDbIdx256StoreResult {
  return &ApplyDbIdx256StoreResult{}
}

var ApplyDbIdx256StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx256StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbIdx256UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbIdx256UpdateArgs() *ApplyDbIdx256UpdateArgs {
  return &ApplyDbIdx256UpdateArgs{}
}


func (p *ApplyDbIdx256UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx256UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx256UpdateArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateArgs(%+v)", *p)
}

type ApplyDbIdx256UpdateResult struct {
}

func NewApplyDbIdx256UpdateResult() *ApplyDbIdx256UpdateResult {
  return &ApplyDbIdx256UpdateResult{}
}

func (p *ApplyDbIdx256UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256RemoveArgs() *ApplyDbIdx256RemoveArgs {
  return &ApplyDbIdx256RemoveArgs{}
}


func (p *ApplyDbIdx256RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveArgs(%+v)", *p)
}

type ApplyDbIdx256RemoveResult struct {
}

func NewApplyDbIdx256RemoveResult() *ApplyDbIdx256RemoveResult {
  return &ApplyDbIdx256RemoveResult{}
}

func (p *ApplyDbIdx256RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256NextArgs() *ApplyDbIdx256NextArgs {
  return &ApplyDbIdx256NextArgs{}
}


func (p *ApplyDbIdx256NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256NextResult() *ApplyDbIdx256NextResult {
  return &ApplyDbIdx256NextResult{}
}

var ApplyDbIdx256NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256PreviousArgs() *ApplyDbIdx256PreviousArgs {
  return &ApplyDbIdx256PreviousArgs{}
}


func (p *ApplyDbIdx256PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256PreviousResult() *ApplyDbIdx256PreviousResult {
  return &ApplyDbIdx256PreviousResult{}
}

var ApplyDbIdx256PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx256FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx256FindPrimaryArgs() *ApplyDbIdx256FindPrimaryArgs {
  return &ApplyDbIdx256FindPrimaryArgs{}
}

var ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindPrimaryResult() *ApplyDbIdx256FindPrimaryResult {
  return &ApplyDbIdx256FindPrimaryResult{}
}

var ApplyDbIdx256FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx256FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
type ApplyDbIdx256FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
}

func NewApplyDbIdx256FindSecondaryArgs() *ApplyDbIdx256FindSecondaryArgs {
  return &ApplyDbIdx256FindSecondaryArgs{}
}

var ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256FindSecondaryArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindSecondaryResult() *ApplyDbIdx256FindSecondaryResult {
  return &ApplyDbIdx256FindSecondaryResult{}
}

var ApplyDbIdx256FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx256FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256LowerboundArgs() *ApplyDbIdx256LowerboundArgs {
  return &ApplyDbIdx256LowerboundArgs{}
}

var ApplyDbIdx256LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256LowerboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256LowerboundResult() *ApplyDbIdx256LowerboundResult {
  return &ApplyDbIdx256LowerboundResult{}
}

var ApplyDbIdx256LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256UpperboundArgs() *ApplyDbIdx256UpperboundArgs {
  return &ApplyDbIdx256UpperboundArgs{}
}

var ApplyDbIdx256UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256UpperboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256UpperboundResult() *ApplyDbIdx256UpperboundResult {
  return &ApplyDbIdx256UpperboundResult{}
}

var ApplyDbIdx256UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx256EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx256EndArgs() *ApplyDbIdx256EndArgs {
  return &ApplyDbIdx256EndArgs{}
}

var ApplyDbIdx256EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx256EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256EndResult() *ApplyDbIdx256EndResult {
  return &ApplyDbIdx256EndResult{}
}

var ApplyDbIdx256EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx256EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleStoreArgs() *ApplyDbIdxDoubleStoreArgs {
  return &ApplyDbIdxDoubleStoreArgs{}
}

var ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleStoreResult() *ApplyDbIdxDoubleStoreResult {
  return &ApplyDbIdxDoubleStoreResult{}
}

var ApplyDbIdxDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleUpdateArgs() *ApplyDbIdxDoubleUpdateArgs {
  return &ApplyDbIdxDoubleUpdateArgs{}
}


func (p *ApplyDbIdxDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxDoubleUpdateResult struct {
}

func NewApplyDbIdxDoubleUpdateResult() *ApplyDbIdxDoubleUpdateResult {
  return &ApplyDbIdxDoubleUpdateResult{}
}

func (p *ApplyDbIdxDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleRemoveArgs() *ApplyDbIdxDoubleRemoveArgs {
  return &ApplyDbIdxDoubleRemoveArgs{}
}


func (p *ApplyDbIdxDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxDoubleRemoveResult struct {
}

func NewApplyDbIdxDoubleRemoveResult() *ApplyDbIdxDoubleRemoveResult {
  return &ApplyDbIdxDoubleRemoveResult{}
}

func (p *ApplyDbIdxDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleNextArgs() *ApplyDbIdxDoubleNextArgs {
  return &ApplyDbIdxDoubleNextArgs{}
}


func (p *ApplyDbIdxDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleNextResult() *ApplyDbIdxDoubleNextResult {
  return &ApplyDbIdxDoubleNextResult{}
}

var ApplyDbIdxDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoublePreviousArgs() *ApplyDbIdxDoublePreviousArgs {
  return &ApplyDbIdxDoublePreviousArgs{}
}


func (p *ApplyDbIdxDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoublePreviousResult() *ApplyDbIdxDoublePreviousResult {
  return &ApplyDbIdxDoublePreviousResult{}
}

var ApplyDbIdxDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleFindPrimaryArgs() *ApplyDbIdxDoubleFindPrimaryArgs {
  return &ApplyDbIdxDoubleFindPrimaryArgs{}
}

var ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindPrimaryResult() *ApplyDbIdxDoubleFindPrimaryResult {
  return &ApplyDbIdxDoubleFindPrimaryResult{}
}

var ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleFindSecondaryArgs() *ApplyDbIdxDoubleFindSecondaryArgs {
  return &ApplyDbIdxDoubleFindSecondaryArgs{}
}

var ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindSecondaryResult() *ApplyDbIdxDoubleFindSecondaryResult {
  return &ApplyDbIdxDoubleFindSecondaryResult{}
}

var ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleLowerboundArgs() *ApplyDbIdxDoubleLowerboundArgs {
  return &ApplyDbIdxDoubleLowerboundArgs{}
}

var ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleLowerboundResult() *ApplyDbIdxDoubleLowerboundResult {
  return &ApplyDbIdxDoubleLowerboundResult{}
}

var ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleUpperboundArgs() *ApplyDbIdxDoubleUpperboundArgs {
  return &ApplyDbIdxDoubleUpperboundArgs{}
}

var ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleUpperboundResult() *ApplyDbIdxDoubleUpperboundResult {
  return &ApplyDbIdxDoubleUpperboundResult{}
}

var ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxDoubleEndArgs() *ApplyDbIdxDoubleEndArgs {
  return &ApplyDbIdxDoubleEndArgs{}
}

var ApplyDbIdxDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleEndResult() *ApplyDbIdxDoubleEndResult {
  return &ApplyDbIdxDoubleEndResult{}
}

var ApplyDbIdxDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxLongDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleStoreArgs() *ApplyDbIdxLongDoubleStoreArgs {
  return &ApplyDbIdxLongDoubleStoreArgs{}
}

var ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxLongDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleStoreResult() *ApplyDbIdxLongDoubleStoreResult {
  return &ApplyDbIdxLongDoubleStoreResult{}
}

var ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxLongDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleUpdateArgs() *ApplyDbIdxLongDoubleUpdateArgs {
  return &ApplyDbIdxLongDoubleUpdateArgs{}
}


func (p *ApplyDbIdxLongDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleUpdateResult struct {
}

func NewApplyDbIdxLongDoubleUpdateResult() *ApplyDbIdxLongDoubleUpdateResult {
  return &ApplyDbIdxLongDoubleUpdateResult{}
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleRemoveArgs() *ApplyDbIdxLongDoubleRemoveArgs {
  return &ApplyDbIdxLongDoubleRemoveArgs{}
}


func (p *ApplyDbIdxLongDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleRemoveResult struct {
}

func NewApplyDbIdxLongDoubleRemoveResult() *ApplyDbIdxLongDoubleRemoveResult {
  return &ApplyDbIdxLongDoubleRemoveResult{}
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleNextArgs() *ApplyDbIdxLongDoubleNextArgs {
  return &ApplyDbIdxLongDoubleNextArgs{}
}


func (p *ApplyDbIdxLongDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleNextResult() *ApplyDbIdxLongDoubleNextResult {
  return &ApplyDbIdxLongDoubleNextResult{}
}

var ApplyDbIdxLongDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoublePreviousArgs() *ApplyDbIdxLongDoublePreviousArgs {
  return &ApplyDbIdxLongDoublePreviousArgs{}
}


func (p *ApplyDbIdxLongDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoublePreviousResult() *ApplyDbIdxLongDoublePreviousResult {
  return &ApplyDbIdxLongDoublePreviousResult{}
}

var ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxLongDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleFindPrimaryArgs() *ApplyDbIdxLongDoubleFindPrimaryArgs {
  return &ApplyDbIdxLongDoubleFindPrimaryArgs{}
}

var ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindPrimaryResult() *ApplyDbIdxLongDoubleFindPrimaryResult {
  return &ApplyDbIdxLongDoubleFindPrimaryResult{}
}

var ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxLongDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleFindSecondaryArgs() *ApplyDbIdxLongDoubleFindSecondaryArgs {
  return &ApplyDbIdxLongDoubleFindSecondaryArgs{}
}

var ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindSecondaryResult() *ApplyDbIdxLongDoubleFindSecondaryResult {
  return &ApplyDbIdxLongDoubleFindSecondaryResult{}
}

var ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleLowerboundArgs() *ApplyDbIdxLongDoubleLowerboundArgs {
  return &ApplyDbIdxLongDoubleLowerboundArgs{}
}

var ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleLowerboundResult() *ApplyDbIdxLongDoubleLowerboundResult {
  return &ApplyDbIdxLongDoubleLowerboundResult{}
}

var ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleUpperboundArgs() *ApplyDbIdxLongDoubleUpperboundArgs {
  return &ApplyDbIdxLongDoubleUpperboundArgs{}
}

var ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleUpperboundResult() *ApplyDbIdxLongDoubleUpperboundResult {
  return &ApplyDbIdxLongDoubleUpperboundResult{}
}

var ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxLongDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxLongDoubleEndArgs() *ApplyDbIdxLongDoubleEndArgs {
  return &ApplyDbIdxLongDoubleEndArgs{}
}

var ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxLongDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleEndResult() *ApplyDbIdxLongDoubleEndResult {
  return &ApplyDbIdxLongDoubleEndResult{}
}

var ApplyDbIdxLongDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySetActionReturnValueArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySetActionReturnValueArgs() *ApplySetActionReturnValueArgs {
  return &ApplySetActionReturnValueArgs{}
}


func (p *ApplySetActionReturnValueArgs) GetData() []byte {
  return p.Data
}
func (p *ApplySetActionReturnValueArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetActionReturnValueArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySetActionReturnValueArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_action_return_value_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetActionReturnValueArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySetActionReturnValueArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetActionReturnValueArgs(%+v)", *p)
}

type ApplySetActionReturnValueResult struct {
}

func NewApplySetActionReturnValueResult() *ApplySetActionReturnValueResult {
  return &ApplySetActionReturnValueResult{}
}

func (p *ApplySetActionReturnValueResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySetActionReturnValueResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "set_action_return_value_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySetActionReturnValueResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySetActionReturnValueResult(%+v)", *p)
}

// Attributes:
//  - Account
//  - StructVersion
type ApplyGetCodeHashArgs struct {
  Account *Uint64 `thrift:"account,1" db:"account" json:"account"`
  StructVersion int64 `thrift:"struct_version,2" db:"struct_version" json:"struct_version"`
}

func NewApplyGetCodeHashArgs() *ApplyGetCodeHashArgs {
  return &ApplyGetCodeHashArgs{}
}

var ApplyGetCodeHashArgs_Account_DEFAULT *Uint64
func (p *ApplyGetCodeHashArgs) GetAccount() *Uint64 {
  if !p.IsSetAccount() {
    return ApplyGetCodeHashArgs_Account_DEFAULT
  }
return p.Account
}

func (p *ApplyGetCodeHashArgs) GetStructVersion() int64 {
  return p.StructVersion
}
func (p *ApplyGetCodeHashArgs) IsSetAccount() bool {
  return p.Account != nil
}

func (p *ApplyGetCodeHashArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetCodeHashArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Account = &Uint64{}
  if err := p.Account.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Account), err)
  }
  return nil
}

func (p *ApplyGetCodeHashArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StructVersion = v
}
  return nil
}

func (p *ApplyGetCodeHashArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_code_hash_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetCodeHashArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := p.Account.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Account), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *ApplyGetCodeHashArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "struct_version", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:struct_version: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.StructVersion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.struct_version (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:struct_version: ", p), err) }
  return err
}

func (p *ApplyGetCodeHashArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetCodeHashArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetCodeHashResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetCodeHashResult() *ApplyGetCodeHashResult {
  return &ApplyGetCodeHashResult{}
}

var ApplyGetCodeHashResult_Success_DEFAULT []byte

func (p *ApplyGetCodeHashResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetCodeHashResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetCodeHashResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetCodeHashResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetCodeHashResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_code_hash_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetCodeHashResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetCodeHashResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetCodeHashResult(%+v)", *p)
}

type ApplyGetBlockNumArgs struct {
}

func NewApplyGetBlockNumArgs() *ApplyGetBlockNumArgs {
  return &ApplyGetBlockNumArgs{}
}

func (p *ApplyGetBlockNumArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockNumArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_block_num_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockNumArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockNumArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetBlockNumResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetBlockNumResult() *ApplyGetBlockNumResult {
  return &ApplyGetBlockNumResult{}
}

var ApplyGetBlockNumResult_Success_DEFAULT int64
func (p *ApplyGetBlockNumResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyGetBlockNumResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyGetBlockNumResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetBlockNumResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetBlockNumResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyGetBlockNumResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_block_num_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetBlockNumResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetBlockNumResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetBlockNumResult(%+v)", *p)
}

// Attributes:
//  - Data
//  - Keccak
type ApplySha3Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Keccak int32 `thrift:"keccak,2" db:"keccak" json:"keccak"`
}

func NewApplySha3Args() *ApplySha3Args {
  return &ApplySha3Args{}
}


func (p *ApplySha3Args) GetData() []byte {
  return p.Data
}

func (p *ApplySha3Args) GetKeccak() int32 {
  return p.Keccak
}
func (p *ApplySha3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Keccak = v
}
  return nil
}

func (p *ApplySha3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "keccak", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:keccak: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Keccak)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keccak (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:keccak: ", p), err) }
  return err
}

func (p *ApplySha3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha3Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha3Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha3Result() *ApplySha3Result {
  return &ApplySha3Result{}
}

var ApplySha3Result_Success_DEFAULT []byte

func (p *ApplySha3Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha3Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha3Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha3Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha3Result(%+v)", *p)
}

// Attributes:
//  - Rounds
//  - State
//  - Msg
//  - T0Offset
//  - T1Offset
//  - Final
type ApplyBlake2FArgs struct {
  Rounds int64 `thrift:"rounds,1" db:"rounds" json:"rounds"`
  State []byte `thrift:"state,2" db:"state" json:"state"`
  Msg []byte `thrift:"msg,3" db:"msg" json:"msg"`
  T0Offset []byte `thrift:"t0_offset,4" db:"t0_offset" json:"t0_offset"`
  T1Offset []byte `thrift:"t1_offset,5" db:"t1_offset" json:"t1_offset"`
  Final int32 `thrift:"final,6" db:"final" json:"final"`
}

func NewApplyBlake2FArgs() *ApplyBlake2FArgs {
  return &ApplyBlake2FArgs{}
}


func (p *ApplyBlake2FArgs) GetRounds() int64 {
  return p.Rounds
}

func (p *ApplyBlake2FArgs) GetState() []byte {
  return p.State
}

func (p *ApplyBlake2FArgs) GetMsg() []byte {
  return p.Msg
}

func (p *ApplyBlake2FArgs) GetT0Offset() []byte {
  return p.T0Offset
}

func (p *ApplyBlake2FArgs) GetT1Offset() []byte {
  return p.T1Offset
}

func (p *ApplyBlake2FArgs) GetFinal() int32 {
  return p.Final
}
func (p *ApplyBlake2FArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Rounds = v
}
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.State = v
}
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.T0Offset = v
}
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.T1Offset = v
}
  return nil
}

func (p *ApplyBlake2FArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Final = v
}
  return nil
}

func (p *ApplyBlake2FArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "blake2_f_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyBlake2FArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rounds", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rounds: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Rounds)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rounds (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rounds: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "state", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:state: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.State); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.state (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:state: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:msg: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "t0_offset", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:t0_offset: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.T0Offset); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.t0_offset (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:t0_offset: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "t1_offset", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:t1_offset: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.T1Offset); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.t1_offset (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:t1_offset: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "final", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:final: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Final)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.final (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:final: ", p), err) }
  return err
}

func (p *ApplyBlake2FArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyBlake2FArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyBlake2FResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyBlake2FResult() *ApplyBlake2FResult {
  return &ApplyBlake2FResult{}
}

var ApplyBlake2FResult_Success_DEFAULT []byte

func (p *ApplyBlake2FResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyBlake2FResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyBlake2FResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyBlake2FResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyBlake2FResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "blake2_f_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyBlake2FResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyBlake2FResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyBlake2FResult(%+v)", *p)
}

// Attributes:
//  - Sig
//  - Dig
type ApplyK1RecoverArgs struct {
  Sig []byte `thrift:"sig,1" db:"sig" json:"sig"`
  Dig []byte `thrift:"dig,2" db:"dig" json:"dig"`
}

func NewApplyK1RecoverArgs() *ApplyK1RecoverArgs {
  return &ApplyK1RecoverArgs{}
}


func (p *ApplyK1RecoverArgs) GetSig() []byte {
  return p.Sig
}

func (p *ApplyK1RecoverArgs) GetDig() []byte {
  return p.Dig
}
func (p *ApplyK1RecoverArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyK1RecoverArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyK1RecoverArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Dig = v
}
  return nil
}

func (p *ApplyK1RecoverArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "k1_recover_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyK1RecoverArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sig: ", p), err) }
  return err
}

func (p *ApplyK1RecoverArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:dig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Dig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:dig: ", p), err) }
  return err
}

func (p *ApplyK1RecoverArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyK1RecoverArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyK1RecoverResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyK1RecoverResult() *ApplyK1RecoverResult {
  return &ApplyK1RecoverResult{}
}

var ApplyK1RecoverResult_Success_DEFAULT []byte

func (p *ApplyK1RecoverResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyK1RecoverResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyK1RecoverResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyK1RecoverResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyK1RecoverResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "k1_recover_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyK1RecoverResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyK1RecoverResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyK1RecoverResult(%+v)", *p)
}

// Attributes:
//  - Op1
//  - Op2
type ApplyAltBn128AddArgs struct {
  Op1 []byte `thrift:"op1,1" db:"op1" json:"op1"`
  Op2 []byte `thrift:"op2,2" db:"op2" json:"op2"`
}

func NewApplyAltBn128AddArgs() *ApplyAltBn128AddArgs {
  return &ApplyAltBn128AddArgs{}
}


func (p *ApplyAltBn128AddArgs) GetOp1() []byte {
  return p.Op1
}

func (p *ApplyAltBn128AddArgs) GetOp2() []byte {
  return p.Op2
}
func (p *ApplyAltBn128AddArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128AddArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Op1 = v
}
  return nil
}

func (p *ApplyAltBn128AddArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Op2 = v
}
  return nil
}

func (p *ApplyAltBn128AddArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_add_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128AddArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op1", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:op1: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Op1); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op1 (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:op1: ", p), err) }
  return err
}

func (p *ApplyAltBn128AddArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op2", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op2: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Op2); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op2 (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op2: ", p), err) }
  return err
}

func (p *ApplyAltBn128AddArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128AddArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyAltBn128AddResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyAltBn128AddResult() *ApplyAltBn128AddResult {
  return &ApplyAltBn128AddResult{}
}

var ApplyAltBn128AddResult_Success_DEFAULT []byte

func (p *ApplyAltBn128AddResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyAltBn128AddResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyAltBn128AddResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128AddResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyAltBn128AddResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_add_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128AddResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyAltBn128AddResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128AddResult(%+v)", *p)
}

// Attributes:
//  - G1
//  - Scalar
type ApplyAltBn128MulArgs struct {
  G1 []byte `thrift:"g1,1" db:"g1" json:"g1"`
  Scalar []byte `thrift:"scalar,2" db:"scalar" json:"scalar"`
}

func NewApplyAltBn128MulArgs() *ApplyAltBn128MulArgs {
  return &ApplyAltBn128MulArgs{}
}


func (p *ApplyAltBn128MulArgs) GetG1() []byte {
  return p.G1
}

func (p *ApplyAltBn128MulArgs) GetScalar() []byte {
  return p.Scalar
}
func (p *ApplyAltBn128MulArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128MulArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.G1 = v
}
  return nil
}

func (p *ApplyAltBn128MulArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Scalar = v
}
  return nil
}

func (p *ApplyAltBn128MulArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_mul_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128MulArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "g1", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:g1: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.G1); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.g1 (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:g1: ", p), err) }
  return err
}

func (p *ApplyAltBn128MulArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scalar", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scalar: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Scalar); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.scalar (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scalar: ", p), err) }
  return err
}

func (p *ApplyAltBn128MulArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128MulArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyAltBn128MulResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyAltBn128MulResult() *ApplyAltBn128MulResult {
  return &ApplyAltBn128MulResult{}
}

var ApplyAltBn128MulResult_Success_DEFAULT []byte

func (p *ApplyAltBn128MulResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyAltBn128MulResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyAltBn128MulResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128MulResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyAltBn128MulResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_mul_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128MulResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyAltBn128MulResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128MulResult(%+v)", *p)
}

// Attributes:
//  - Pairs
type ApplyAltBn128PairArgs struct {
  Pairs []byte `thrift:"pairs,1" db:"pairs" json:"pairs"`
}

func NewApplyAltBn128PairArgs() *ApplyAltBn128PairArgs {
  return &ApplyAltBn128PairArgs{}
}


func (p *ApplyAltBn128PairArgs) GetPairs() []byte {
  return p.Pairs
}
func (p *ApplyAltBn128PairArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128PairArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Pairs = v
}
  return nil
}

func (p *ApplyAltBn128PairArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_pair_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128PairArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pairs", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:pairs: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Pairs); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pairs (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:pairs: ", p), err) }
  return err
}

func (p *ApplyAltBn128PairArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128PairArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyAltBn128PairResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyAltBn128PairResult() *ApplyAltBn128PairResult {
  return &ApplyAltBn128PairResult{}
}

var ApplyAltBn128PairResult_Success_DEFAULT int32
func (p *ApplyAltBn128PairResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyAltBn128PairResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyAltBn128PairResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyAltBn128PairResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAltBn128PairResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyAltBn128PairResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "alt_bn128_pair_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAltBn128PairResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyAltBn128PairResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAltBn128PairResult(%+v)", *p)
}

// Attributes:
//  - Base
//  - Exp
//  - Mod
type ApplyModExpArgs struct {
  Base []byte `thrift:"base,1" db:"base" json:"base"`
  Exp []byte `thrift:"exp,2" db:"exp" json:"exp"`
  Mod []byte `thrift:"mod,3" db:"mod" json:"mod"`
}

func NewApplyModExpArgs() *ApplyModExpArgs {
  return &ApplyModExpArgs{}
}


func (p *ApplyModExpArgs) GetBase() []byte {
  return p.Base
}

func (p *ApplyModExpArgs) GetExp() []byte {
  return p.Exp
}

func (p *ApplyModExpArgs) GetMod() []byte {
  return p.Mod
}
func (p *ApplyModExpArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyModExpArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Base = v
}
  return nil
}

func (p *ApplyModExpArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Exp = v
}
  return nil
}

func (p *ApplyModExpArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Mod = v
}
  return nil
}

func (p *ApplyModExpArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mod_exp_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyModExpArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "base", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:base: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Base); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.base (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:base: ", p), err) }
  return err
}

func (p *ApplyModExpArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "exp", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:exp: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Exp); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.exp (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:exp: ", p), err) }
  return err
}

func (p *ApplyModExpArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "mod", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:mod: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Mod); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.mod (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:mod: ", p), err) }
  return err
}

func (p *ApplyModExpArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyModExpArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyModExpResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyModExpResult() *ApplyModExpResult {
  return &ApplyModExpResult{}
}

var ApplyModExpResult_Success_DEFAULT []byte

func (p *ApplyModExpResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyModExpResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyModExpResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyModExpResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyModExpResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mod_exp_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyModExpResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyModExpResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyModExpResult(%+v)", *p)
}


