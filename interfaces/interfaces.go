// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package interfaces

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// Attributes:
//  - Exc
type TransactionException struct {
  Exc string `thrift:"exc,1" db:"exc" json:"exc"`
}

func NewTransactionException() *TransactionException {
  return &TransactionException{}
}


func (p *TransactionException) GetExc() string {
  return p.Exc
}
func (p *TransactionException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TransactionException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Exc = v
}
  return nil
}

func (p *TransactionException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TransactionException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TransactionException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "exc", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:exc: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Exc)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.exc (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:exc: ", p), err) }
  return err
}

func (p *TransactionException) Equals(other *TransactionException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Exc != other.Exc { return false }
  return true
}

func (p *TransactionException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TransactionException(%+v)", *p)
}

func (p *TransactionException) Error() string {
  return p.String()
}

func (TransactionException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TransactionException)(nil)

// Attributes:
//  - ErrorMessage
type AssertException struct {
  ErrorMessage string `thrift:"error_message,1" db:"error_message" json:"error_message"`
}

func NewAssertException() *AssertException {
  return &AssertException{}
}


func (p *AssertException) GetErrorMessage() string {
  return p.ErrorMessage
}
func (p *AssertException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AssertException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ErrorMessage = v
}
  return nil
}

func (p *AssertException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AssertException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AssertException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "error_message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:error_message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ErrorMessage)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.error_message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:error_message: ", p), err) }
  return err
}

func (p *AssertException) Equals(other *AssertException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ErrorMessage != other.ErrorMessage { return false }
  return true
}

func (p *AssertException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AssertException(%+v)", *p)
}

func (p *AssertException) Error() string {
  return p.String()
}

func (AssertException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*AssertException)(nil)

// Attributes:
//  - Account
//  - Action
//  - Permissions
//  - Arguments
type Action struct {
  Account string `thrift:"account,1" db:"account" json:"account"`
  Action string `thrift:"action,2" db:"action" json:"action"`
  Permissions string `thrift:"permissions,3" db:"permissions" json:"permissions"`
  Arguments string `thrift:"arguments,4" db:"arguments" json:"arguments"`
}

func NewAction() *Action {
  return &Action{}
}


func (p *Action) GetAccount() string {
  return p.Account
}

func (p *Action) GetAction() string {
  return p.Action
}

func (p *Action) GetPermissions() string {
  return p.Permissions
}

func (p *Action) GetArguments() string {
  return p.Arguments
}
func (p *Action) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Action)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *Action)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *Action)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *Action)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Arguments = v
}
  return nil
}

func (p *Action) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Action"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Action) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:account: ", p), err) }
  return err
}

func (p *Action) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:action: ", p), err) }
  return err
}

func (p *Action) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:permissions: ", p), err) }
  return err
}

func (p *Action) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Arguments)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.arguments (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *Action) Equals(other *Action) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Account != other.Account { return false }
  if p.Action != other.Action { return false }
  if p.Permissions != other.Permissions { return false }
  if p.Arguments != other.Arguments { return false }
  return true
}

func (p *Action) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Action(%+v)", *p)
}

// Attributes:
//  - RawValue
type Uint64 struct {
  RawValue []byte `thrift:"rawValue,1" db:"rawValue" json:"rawValue"`
}

func NewUint64() *Uint64 {
  return &Uint64{}
}


func (p *Uint64) GetRawValue() []byte {
  return p.RawValue
}
func (p *Uint64) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Uint64)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RawValue = v
}
  return nil
}

func (p *Uint64) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Uint64"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Uint64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rawValue", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rawValue: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawValue); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rawValue (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rawValue: ", p), err) }
  return err
}

func (p *Uint64) Equals(other *Uint64) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.RawValue, other.RawValue) != 0 { return false }
  return true
}

func (p *Uint64) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Uint64(%+v)", *p)
}

// Attributes:
//  - Size
//  - Buffer
type DataBuffer struct {
  Size int32 `thrift:"size,1" db:"size" json:"size"`
  Buffer []byte `thrift:"buffer,2" db:"buffer" json:"buffer"`
}

func NewDataBuffer() *DataBuffer {
  return &DataBuffer{}
}


func (p *DataBuffer) GetSize() int32 {
  return p.Size
}

func (p *DataBuffer) GetBuffer() []byte {
  return p.Buffer
}
func (p *DataBuffer) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DataBuffer)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Size = v
}
  return nil
}

func (p *DataBuffer)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Buffer = v
}
  return nil
}

func (p *DataBuffer) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DataBuffer"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DataBuffer) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "size", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:size: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Size)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.size (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:size: ", p), err) }
  return err
}

func (p *DataBuffer) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "buffer", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:buffer: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Buffer); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.buffer (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:buffer: ", p), err) }
  return err
}

func (p *DataBuffer) Equals(other *DataBuffer) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Size != other.Size { return false }
  if bytes.Compare(p.Buffer, other.Buffer) != 0 { return false }
  return true
}

func (p *DataBuffer) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DataBuffer(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type NextPreviousReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewNextPreviousReturn() *NextPreviousReturn {
  return &NextPreviousReturn{}
}


func (p *NextPreviousReturn) GetIterator() int32 {
  return p.Iterator
}
var NextPreviousReturn_Primary_DEFAULT *Uint64
func (p *NextPreviousReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return NextPreviousReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *NextPreviousReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *NextPreviousReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NextPreviousReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *NextPreviousReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *NextPreviousReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NextPreviousReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NextPreviousReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *NextPreviousReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *NextPreviousReturn) Equals(other *NextPreviousReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *NextPreviousReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NextPreviousReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type IteratorPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewIteratorPrimaryReturn() *IteratorPrimaryReturn {
  return &IteratorPrimaryReturn{}
}


func (p *IteratorPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}
var IteratorPrimaryReturn_Primary_DEFAULT *Uint64
func (p *IteratorPrimaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return IteratorPrimaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *IteratorPrimaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *IteratorPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *IteratorPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *IteratorPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "IteratorPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IteratorPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *IteratorPrimaryReturn) Equals(other *IteratorPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *IteratorPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IteratorPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
type FindPrimaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
}

func NewFindPrimaryReturn() *FindPrimaryReturn {
  return &FindPrimaryReturn{}
}


func (p *FindPrimaryReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *FindPrimaryReturn) GetSecondary() []byte {
  return p.Secondary
}
func (p *FindPrimaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindPrimaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindPrimaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *FindPrimaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindPrimaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindPrimaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *FindPrimaryReturn) Equals(other *FindPrimaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  return true
}

func (p *FindPrimaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindPrimaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Primary
type FindSecondaryReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Primary *Uint64 `thrift:"primary,2" db:"primary" json:"primary"`
}

func NewFindSecondaryReturn() *FindSecondaryReturn {
  return &FindSecondaryReturn{}
}


func (p *FindSecondaryReturn) GetIterator() int32 {
  return p.Iterator
}
var FindSecondaryReturn_Primary_DEFAULT *Uint64
func (p *FindSecondaryReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return FindSecondaryReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *FindSecondaryReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *FindSecondaryReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FindSecondaryReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *FindSecondaryReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *FindSecondaryReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FindSecondaryReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FindSecondaryReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:primary: ", p), err) }
  return err
}

func (p *FindSecondaryReturn) Equals(other *FindSecondaryReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *FindSecondaryReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FindSecondaryReturn(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Secondary
//  - Primary
type LowerBoundUpperBoundReturn struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Secondary []byte `thrift:"secondary,2" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,3" db:"primary" json:"primary"`
}

func NewLowerBoundUpperBoundReturn() *LowerBoundUpperBoundReturn {
  return &LowerBoundUpperBoundReturn{}
}


func (p *LowerBoundUpperBoundReturn) GetIterator() int32 {
  return p.Iterator
}

func (p *LowerBoundUpperBoundReturn) GetSecondary() []byte {
  return p.Secondary
}
var LowerBoundUpperBoundReturn_Primary_DEFAULT *Uint64
func (p *LowerBoundUpperBoundReturn) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return LowerBoundUpperBoundReturn_Primary_DEFAULT
  }
return p.Primary
}
func (p *LowerBoundUpperBoundReturn) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *LowerBoundUpperBoundReturn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *LowerBoundUpperBoundReturn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *LowerBoundUpperBoundReturn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LowerBoundUpperBoundReturn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LowerBoundUpperBoundReturn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:secondary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:primary: ", p), err) }
  return err
}

func (p *LowerBoundUpperBoundReturn) Equals(other *LowerBoundUpperBoundReturn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Iterator != other.Iterator { return false }
  if bytes.Compare(p.Secondary, other.Secondary) != 0 { return false }
  if !p.Primary.Equals(other.Primary) { return false }
  return true
}

func (p *LowerBoundUpperBoundReturn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LowerBoundUpperBoundReturn(%+v)", *p)
}

type IPCChainTester interface {
  InitVMAPI(ctx context.Context) (_err error)
  InitApplyRequest(ctx context.Context) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Enable
  EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error)
  // Parameters:
  //  - ID
  //  - Contract
  IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error)
  // Parameters:
  //  - Abi
  PackAbi(ctx context.Context, abi string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - ActionArgs_
  PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Contract
  //  - Action
  //  - RawArgs_
  UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error)
  NewChain_(ctx context.Context) (_r int32, _err error)
  // Parameters:
  //  - ID
  FreeChain(ctx context.Context, id int32) (_r int32, _err error)
  // Parameters:
  //  - ID
  ProduceBlock(ctx context.Context, id int32) (_err error)
  // Parameters:
  //  - ID
  //  - Account
  //  - Action
  //  - Arguments
  //  - Permissions
  PushAction(ctx context.Context, id int32, account string, action string, arguments string, permissions string) (_r []byte, _err error)
  // Parameters:
  //  - ID
  //  - Actions
  PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error)
}

type IPCChainTesterClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewIPCChainTesterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewIPCChainTesterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewIPCChainTesterClient(c thrift.TClient) *IPCChainTesterClient {
  return &IPCChainTesterClient{
    c: c,
  }
}

func (p *IPCChainTesterClient) Client_() thrift.TClient {
  return p.c
}

func (p *IPCChainTesterClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *IPCChainTesterClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *IPCChainTesterClient) InitVMAPI(ctx context.Context) (_err error) {
  var _args0 IPCChainTesterInitVMAPIArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_vm_api", &_args0, nil); err != nil {
    return err
  }
  return nil
}

func (p *IPCChainTesterClient) InitApplyRequest(ctx context.Context) (_err error) {
  var _args1 IPCChainTesterInitApplyRequestArgs
  p.SetLastResponseMeta_(thrift.ResponseMeta{})
  if _, err := p.Client_().Call(ctx, "init_apply_request", &_args1, nil); err != nil {
    return err
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
//  - Enable
func (p *IPCChainTesterClient) EnableDebugContract(ctx context.Context, id int32, contract string, enable bool) (_err error) {
  var _args2 IPCChainTesterEnableDebugContractArgs
  _args2.ID = id
  _args2.Contract = contract
  _args2.Enable = enable
  var _result4 IPCChainTesterEnableDebugContractResult
  var _meta3 thrift.ResponseMeta
  _meta3, _err = p.Client_().Call(ctx, "enable_debug_contract", &_args2, &_result4)
  p.SetLastResponseMeta_(_meta3)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Contract
func (p *IPCChainTesterClient) IsDebugContractEnabled(ctx context.Context, id int32, contract string) (_r bool, _err error) {
  var _args5 IPCChainTesterIsDebugContractEnabledArgs
  _args5.ID = id
  _args5.Contract = contract
  var _result7 IPCChainTesterIsDebugContractEnabledResult
  var _meta6 thrift.ResponseMeta
  _meta6, _err = p.Client_().Call(ctx, "is_debug_contract_enabled", &_args5, &_result7)
  p.SetLastResponseMeta_(_meta6)
  if _err != nil {
    return
  }
  return _result7.GetSuccess(), nil
}

// Parameters:
//  - Abi
func (p *IPCChainTesterClient) PackAbi(ctx context.Context, abi string) (_r []byte, _err error) {
  var _args8 IPCChainTesterPackAbiArgs
  _args8.Abi = abi
  var _result10 IPCChainTesterPackAbiResult
  var _meta9 thrift.ResponseMeta
  _meta9, _err = p.Client_().Call(ctx, "pack_abi", &_args8, &_result10)
  p.SetLastResponseMeta_(_meta9)
  if _err != nil {
    return
  }
  return _result10.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
func (p *IPCChainTesterClient) PackActionArgs_(ctx context.Context, id int32, contract string, action string, action_args string) (_r []byte, _err error) {
  var _args11 IPCChainTesterPackActionArgsArgs
  _args11.ID = id
  _args11.Contract = contract
  _args11.Action = action
  _args11.ActionArgs_ = action_args
  var _result13 IPCChainTesterPackActionArgsResult
  var _meta12 thrift.ResponseMeta
  _meta12, _err = p.Client_().Call(ctx, "pack_action_args", &_args11, &_result13)
  p.SetLastResponseMeta_(_meta12)
  if _err != nil {
    return
  }
  return _result13.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
func (p *IPCChainTesterClient) UnpackActionArgs_(ctx context.Context, id int32, contract string, action string, raw_args []byte) (_r []byte, _err error) {
  var _args14 IPCChainTesterUnpackActionArgsArgs
  _args14.ID = id
  _args14.Contract = contract
  _args14.Action = action
  _args14.RawArgs_ = raw_args
  var _result16 IPCChainTesterUnpackActionArgsResult
  var _meta15 thrift.ResponseMeta
  _meta15, _err = p.Client_().Call(ctx, "unpack_action_args", &_args14, &_result16)
  p.SetLastResponseMeta_(_meta15)
  if _err != nil {
    return
  }
  return _result16.GetSuccess(), nil
}

func (p *IPCChainTesterClient) NewChain_(ctx context.Context) (_r int32, _err error) {
  var _args17 IPCChainTesterNewChainArgs_
  var _result19 IPCChainTesterNewChainResult_
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "new_chain", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  return _result19.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) FreeChain(ctx context.Context, id int32) (_r int32, _err error) {
  var _args20 IPCChainTesterFreeChainArgs
  _args20.ID = id
  var _result22 IPCChainTesterFreeChainResult
  var _meta21 thrift.ResponseMeta
  _meta21, _err = p.Client_().Call(ctx, "free_chain", &_args20, &_result22)
  p.SetLastResponseMeta_(_meta21)
  if _err != nil {
    return
  }
  return _result22.GetSuccess(), nil
}

// Parameters:
//  - ID
func (p *IPCChainTesterClient) ProduceBlock(ctx context.Context, id int32) (_err error) {
  var _args23 IPCChainTesterProduceBlockArgs
  _args23.ID = id
  var _result25 IPCChainTesterProduceBlockResult
  var _meta24 thrift.ResponseMeta
  _meta24, _err = p.Client_().Call(ctx, "produce_block", &_args23, &_result25)
  p.SetLastResponseMeta_(_meta24)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
func (p *IPCChainTesterClient) PushAction(ctx context.Context, id int32, account string, action string, arguments string, permissions string) (_r []byte, _err error) {
  var _args26 IPCChainTesterPushActionArgs
  _args26.ID = id
  _args26.Account = account
  _args26.Action = action
  _args26.Arguments = arguments
  _args26.Permissions = permissions
  var _result28 IPCChainTesterPushActionResult
  var _meta27 thrift.ResponseMeta
  _meta27, _err = p.Client_().Call(ctx, "push_action", &_args26, &_result28)
  p.SetLastResponseMeta_(_meta27)
  if _err != nil {
    return
  }
  return _result28.GetSuccess(), nil
}

// Parameters:
//  - ID
//  - Actions
func (p *IPCChainTesterClient) PushActions(ctx context.Context, id int32, actions []*Action) (_r []byte, _err error) {
  var _args29 IPCChainTesterPushActionsArgs
  _args29.ID = id
  _args29.Actions = actions
  var _result31 IPCChainTesterPushActionsResult
  var _meta30 thrift.ResponseMeta
  _meta30, _err = p.Client_().Call(ctx, "push_actions", &_args29, &_result31)
  p.SetLastResponseMeta_(_meta30)
  if _err != nil {
    return
  }
  switch {
  case _result31.Exc!= nil:
    return _r, _result31.Exc
  }

  return _result31.GetSuccess(), nil
}

type IPCChainTesterProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler IPCChainTester
}

func (p *IPCChainTesterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *IPCChainTesterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *IPCChainTesterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewIPCChainTesterProcessor(handler IPCChainTester) *IPCChainTesterProcessor {

  self32 := &IPCChainTesterProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self32.processorMap["init_vm_api"] = &iPCChainTesterProcessorInitVMAPI{handler:handler}
  self32.processorMap["init_apply_request"] = &iPCChainTesterProcessorInitApplyRequest{handler:handler}
  self32.processorMap["enable_debug_contract"] = &iPCChainTesterProcessorEnableDebugContract{handler:handler}
  self32.processorMap["is_debug_contract_enabled"] = &iPCChainTesterProcessorIsDebugContractEnabled{handler:handler}
  self32.processorMap["pack_abi"] = &iPCChainTesterProcessorPackAbi{handler:handler}
  self32.processorMap["pack_action_args"] = &iPCChainTesterProcessorPackActionArgs_{handler:handler}
  self32.processorMap["unpack_action_args"] = &iPCChainTesterProcessorUnpackActionArgs_{handler:handler}
  self32.processorMap["new_chain"] = &iPCChainTesterProcessorNewChain_{handler:handler}
  self32.processorMap["free_chain"] = &iPCChainTesterProcessorFreeChain{handler:handler}
  self32.processorMap["produce_block"] = &iPCChainTesterProcessorProduceBlock{handler:handler}
  self32.processorMap["push_action"] = &iPCChainTesterProcessorPushAction{handler:handler}
  self32.processorMap["push_actions"] = &iPCChainTesterProcessorPushActions{handler:handler}
return self32
}

func (p *IPCChainTesterProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x33 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x33.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x33

}

type iPCChainTesterProcessorInitVMAPI struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitVMAPI) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitVMAPIArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitVMAPI(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorInitApplyRequest struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorInitApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterInitApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  _ = tickerCancel

  if err2 = p.handler.InitApplyRequest(ctx); err2 != nil {
    tickerCancel()
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  return true, nil
}

type iPCChainTesterProcessorEnableDebugContract struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorEnableDebugContract) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterEnableDebugContractArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterEnableDebugContractResult{}
  if err2 = p.handler.EnableDebugContract(ctx, args.ID, args.Contract, args.Enable); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enable_debug_contract: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "enable_debug_contract", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorIsDebugContractEnabled struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorIsDebugContractEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterIsDebugContractEnabledArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterIsDebugContractEnabledResult{}
  var retval bool
  if retval, err2 = p.handler.IsDebugContractEnabled(ctx, args.ID, args.Contract); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_debug_contract_enabled: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_debug_contract_enabled", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackAbi struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackAbi) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackAbiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackAbiResult{}
  var retval []byte
  if retval, err2 = p.handler.PackAbi(ctx, args.Abi); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_abi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_abi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_abi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.PackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.ActionArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorUnpackActionArgs_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorUnpackActionArgs_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterUnpackActionArgsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterUnpackActionArgsResult{}
  var retval []byte
  if retval, err2 = p.handler.UnpackActionArgs_(ctx, args.ID, args.Contract, args.Action, args.RawArgs_); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unpack_action_args: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unpack_action_args", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorNewChain_ struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorNewChain_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterNewChainArgs_{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterNewChainResult_{}
  var retval int32
  if retval, err2 = p.handler.NewChain_(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing new_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "new_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "new_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorFreeChain struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorFreeChain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterFreeChainArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterFreeChainResult{}
  var retval int32
  if retval, err2 = p.handler.FreeChain(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing free_chain: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "free_chain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "free_chain", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorProduceBlock struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorProduceBlock) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterProduceBlockArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterProduceBlockResult{}
  if err2 = p.handler.ProduceBlock(ctx, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing produce_block: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "produce_block", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "produce_block", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushAction struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionResult{}
  var retval []byte
  if retval, err2 = p.handler.PushAction(ctx, args.ID, args.Account, args.Action, args.Arguments, args.Permissions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iPCChainTesterProcessorPushActions struct {
  handler IPCChainTester
}

func (p *iPCChainTesterProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IPCChainTesterPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IPCChainTesterPushActionsResult{}
  var retval []byte
  if retval, err2 = p.handler.PushActions(ctx, args.ID, args.Actions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *TransactionException:
  result.Exc = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type IPCChainTesterInitVMAPIArgs struct {
}

func NewIPCChainTesterInitVMAPIArgs() *IPCChainTesterInitVMAPIArgs {
  return &IPCChainTesterInitVMAPIArgs{}
}

func (p *IPCChainTesterInitVMAPIArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_vm_api_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitVMAPIArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitVMAPIArgs(%+v)", *p)
}

type IPCChainTesterInitApplyRequestArgs struct {
}

func NewIPCChainTesterInitApplyRequestArgs() *IPCChainTesterInitApplyRequestArgs {
  return &IPCChainTesterInitApplyRequestArgs{}
}

func (p *IPCChainTesterInitApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "init_apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterInitApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterInitApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Enable
type IPCChainTesterEnableDebugContractArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Enable bool `thrift:"enable,3" db:"enable" json:"enable"`
}

func NewIPCChainTesterEnableDebugContractArgs() *IPCChainTesterEnableDebugContractArgs {
  return &IPCChainTesterEnableDebugContractArgs{}
}


func (p *IPCChainTesterEnableDebugContractArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterEnableDebugContractArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterEnableDebugContractArgs) GetEnable() bool {
  return p.Enable
}
func (p *IPCChainTesterEnableDebugContractArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Enable = v
}
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "enable", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:enable: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Enable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.enable (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:enable: ", p), err) }
  return err
}

func (p *IPCChainTesterEnableDebugContractArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractArgs(%+v)", *p)
}

type IPCChainTesterEnableDebugContractResult struct {
}

func NewIPCChainTesterEnableDebugContractResult() *IPCChainTesterEnableDebugContractResult {
  return &IPCChainTesterEnableDebugContractResult{}
}

func (p *IPCChainTesterEnableDebugContractResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enable_debug_contract_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterEnableDebugContractResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterEnableDebugContractResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
type IPCChainTesterIsDebugContractEnabledArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
}

func NewIPCChainTesterIsDebugContractEnabledArgs() *IPCChainTesterIsDebugContractEnabledArgs {
  return &IPCChainTesterIsDebugContractEnabledArgs{}
}


func (p *IPCChainTesterIsDebugContractEnabledArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) GetContract() string {
  return p.Contract
}
func (p *IPCChainTesterIsDebugContractEnabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterIsDebugContractEnabledResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterIsDebugContractEnabledResult() *IPCChainTesterIsDebugContractEnabledResult {
  return &IPCChainTesterIsDebugContractEnabledResult{}
}

var IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT bool
func (p *IPCChainTesterIsDebugContractEnabledResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return IPCChainTesterIsDebugContractEnabledResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterIsDebugContractEnabledResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_debug_contract_enabled_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterIsDebugContractEnabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterIsDebugContractEnabledResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterIsDebugContractEnabledResult(%+v)", *p)
}

// Attributes:
//  - Abi
type IPCChainTesterPackAbiArgs struct {
  Abi string `thrift:"abi,1" db:"abi" json:"abi"`
}

func NewIPCChainTesterPackAbiArgs() *IPCChainTesterPackAbiArgs {
  return &IPCChainTesterPackAbiArgs{}
}


func (p *IPCChainTesterPackAbiArgs) GetAbi() string {
  return p.Abi
}
func (p *IPCChainTesterPackAbiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Abi = v
}
  return nil
}

func (p *IPCChainTesterPackAbiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "abi", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:abi: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Abi)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.abi (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:abi: ", p), err) }
  return err
}

func (p *IPCChainTesterPackAbiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackAbiResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackAbiResult() *IPCChainTesterPackAbiResult {
  return &IPCChainTesterPackAbiResult{}
}

var IPCChainTesterPackAbiResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackAbiResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackAbiResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackAbiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackAbiResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackAbiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_abi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackAbiResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackAbiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackAbiResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - ActionArgs_
type IPCChainTesterPackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  ActionArgs_ string `thrift:"action_args,4" db:"action_args" json:"action_args"`
}

func NewIPCChainTesterPackActionArgsArgs() *IPCChainTesterPackActionArgsArgs {
  return &IPCChainTesterPackActionArgsArgs{}
}


func (p *IPCChainTesterPackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterPackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterPackActionArgsArgs) GetActionArgs_() string {
  return p.ActionArgs_
}
func (p *IPCChainTesterPackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ActionArgs_ = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:action_args: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ActionArgs_)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:action_args: ", p), err) }
  return err
}

func (p *IPCChainTesterPackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPackActionArgsResult() *IPCChainTesterPackActionArgsResult {
  return &IPCChainTesterPackActionArgsResult{}
}

var IPCChainTesterPackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPackActionArgsResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Contract
//  - Action
//  - RawArgs_
type IPCChainTesterUnpackActionArgsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Contract string `thrift:"contract,2" db:"contract" json:"contract"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  RawArgs_ []byte `thrift:"raw_args,4" db:"raw_args" json:"raw_args"`
}

func NewIPCChainTesterUnpackActionArgsArgs() *IPCChainTesterUnpackActionArgsArgs {
  return &IPCChainTesterUnpackActionArgsArgs{}
}


func (p *IPCChainTesterUnpackActionArgsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetContract() string {
  return p.Contract
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterUnpackActionArgsArgs) GetRawArgs_() []byte {
  return p.RawArgs_
}
func (p *IPCChainTesterUnpackActionArgsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Contract = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.RawArgs_ = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contract", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:contract: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Contract)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contract (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:contract: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "raw_args", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:raw_args: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RawArgs_); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.raw_args (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:raw_args: ", p), err) }
  return err
}

func (p *IPCChainTesterUnpackActionArgsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterUnpackActionArgsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterUnpackActionArgsResult() *IPCChainTesterUnpackActionArgsResult {
  return &IPCChainTesterUnpackActionArgsResult{}
}

var IPCChainTesterUnpackActionArgsResult_Success_DEFAULT []byte

func (p *IPCChainTesterUnpackActionArgsResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterUnpackActionArgsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unpack_action_args_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterUnpackActionArgsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterUnpackActionArgsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterUnpackActionArgsResult(%+v)", *p)
}

type IPCChainTesterNewChainArgs_ struct {
}

func NewIPCChainTesterNewChainArgs_() *IPCChainTesterNewChainArgs_ {
  return &IPCChainTesterNewChainArgs_{}
}

func (p *IPCChainTesterNewChainArgs_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainArgs_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainArgs_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainArgs_(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterNewChainResult_ struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterNewChainResult_() *IPCChainTesterNewChainResult_ {
  return &IPCChainTesterNewChainResult_{}
}

var IPCChainTesterNewChainResult__Success_DEFAULT int32
func (p *IPCChainTesterNewChainResult_) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterNewChainResult__Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterNewChainResult_) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterNewChainResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterNewChainResult_)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterNewChainResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "new_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterNewChainResult_) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterNewChainResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterNewChainResult_(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterFreeChainArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterFreeChainArgs() *IPCChainTesterFreeChainArgs {
  return &IPCChainTesterFreeChainArgs{}
}


func (p *IPCChainTesterFreeChainArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterFreeChainArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterFreeChainArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterFreeChainArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterFreeChainResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterFreeChainResult() *IPCChainTesterFreeChainResult {
  return &IPCChainTesterFreeChainResult{}
}

var IPCChainTesterFreeChainResult_Success_DEFAULT int32
func (p *IPCChainTesterFreeChainResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return IPCChainTesterFreeChainResult_Success_DEFAULT
  }
return *p.Success
}
func (p *IPCChainTesterFreeChainResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterFreeChainResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterFreeChainResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IPCChainTesterFreeChainResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "free_chain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterFreeChainResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterFreeChainResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterFreeChainResult(%+v)", *p)
}

// Attributes:
//  - ID
type IPCChainTesterProduceBlockArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
}

func NewIPCChainTesterProduceBlockArgs() *IPCChainTesterProduceBlockArgs {
  return &IPCChainTesterProduceBlockArgs{}
}


func (p *IPCChainTesterProduceBlockArgs) GetID() int32 {
  return p.ID
}
func (p *IPCChainTesterProduceBlockArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterProduceBlockArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockArgs(%+v)", *p)
}

type IPCChainTesterProduceBlockResult struct {
}

func NewIPCChainTesterProduceBlockResult() *IPCChainTesterProduceBlockResult {
  return &IPCChainTesterProduceBlockResult{}
}

func (p *IPCChainTesterProduceBlockResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "produce_block_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterProduceBlockResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterProduceBlockResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Account
//  - Action
//  - Arguments
//  - Permissions
type IPCChainTesterPushActionArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Account string `thrift:"account,2" db:"account" json:"account"`
  Action string `thrift:"action,3" db:"action" json:"action"`
  Arguments string `thrift:"arguments,4" db:"arguments" json:"arguments"`
  Permissions string `thrift:"permissions,5" db:"permissions" json:"permissions"`
}

func NewIPCChainTesterPushActionArgs() *IPCChainTesterPushActionArgs {
  return &IPCChainTesterPushActionArgs{}
}


func (p *IPCChainTesterPushActionArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionArgs) GetAccount() string {
  return p.Account
}

func (p *IPCChainTesterPushActionArgs) GetAction() string {
  return p.Action
}

func (p *IPCChainTesterPushActionArgs) GetArguments() string {
  return p.Arguments
}

func (p *IPCChainTesterPushActionArgs) GetPermissions() string {
  return p.Permissions
}
func (p *IPCChainTesterPushActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Account = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Action = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Arguments = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Permissions = v
}
  return nil
}

func (p *IPCChainTesterPushActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "account", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:account: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Account)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.account (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:account: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "arguments", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:arguments: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Arguments)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.arguments (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:arguments: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permissions", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:permissions: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Permissions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.permissions (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:permissions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type IPCChainTesterPushActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewIPCChainTesterPushActionResult() *IPCChainTesterPushActionResult {
  return &IPCChainTesterPushActionResult{}
}

var IPCChainTesterPushActionResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *IPCChainTesterPushActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Actions
type IPCChainTesterPushActionsArgs struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Actions []*Action `thrift:"actions,2" db:"actions" json:"actions"`
}

func NewIPCChainTesterPushActionsArgs() *IPCChainTesterPushActionsArgs {
  return &IPCChainTesterPushActionsArgs{}
}


func (p *IPCChainTesterPushActionsArgs) GetID() int32 {
  return p.ID
}

func (p *IPCChainTesterPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *IPCChainTesterPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *IPCChainTesterPushActionsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem34 := &Action{}
    if err := _elem34.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem34), err)
    }
    p.Actions = append(p.Actions, _elem34)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:actions: ", p), err) }
  return err
}

func (p *IPCChainTesterPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Exc
type IPCChainTesterPushActionsResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  Exc *TransactionException `thrift:"exc,1" db:"exc" json:"exc,omitempty"`
}

func NewIPCChainTesterPushActionsResult() *IPCChainTesterPushActionsResult {
  return &IPCChainTesterPushActionsResult{}
}

var IPCChainTesterPushActionsResult_Success_DEFAULT []byte

func (p *IPCChainTesterPushActionsResult) GetSuccess() []byte {
  return p.Success
}
var IPCChainTesterPushActionsResult_Exc_DEFAULT *TransactionException
func (p *IPCChainTesterPushActionsResult) GetExc() *TransactionException {
  if !p.IsSetExc() {
    return IPCChainTesterPushActionsResult_Exc_DEFAULT
  }
return p.Exc
}
func (p *IPCChainTesterPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IPCChainTesterPushActionsResult) IsSetExc() bool {
  return p.Exc != nil
}

func (p *IPCChainTesterPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *IPCChainTesterPushActionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Exc = &TransactionException{}
  if err := p.Exc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Exc), err)
  }
  return nil
}

func (p *IPCChainTesterPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IPCChainTesterPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExc() {
    if err := oprot.WriteFieldBegin(ctx, "exc", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:exc: ", p), err) }
    if err := p.Exc.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Exc), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:exc: ", p), err) }
  }
  return err
}

func (p *IPCChainTesterPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IPCChainTesterPushActionsResult(%+v)", *p)
}


type PushActions interface {
  // Parameters:
  //  - Actions
  PushActions(ctx context.Context, actions []*Action) (_r int32, _err error)
}

type PushActionsClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewPushActionsClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewPushActionsClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *PushActionsClient {
  return &PushActionsClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewPushActionsClient(c thrift.TClient) *PushActionsClient {
  return &PushActionsClient{
    c: c,
  }
}

func (p *PushActionsClient) Client_() thrift.TClient {
  return p.c
}

func (p *PushActionsClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *PushActionsClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Actions
func (p *PushActionsClient) PushActions(ctx context.Context, actions []*Action) (_r int32, _err error) {
  var _args63 PushActionsPushActionsArgs
  _args63.Actions = actions
  var _result65 PushActionsPushActionsResult
  var _meta64 thrift.ResponseMeta
  _meta64, _err = p.Client_().Call(ctx, "push_actions", &_args63, &_result65)
  p.SetLastResponseMeta_(_meta64)
  if _err != nil {
    return
  }
  return _result65.GetSuccess(), nil
}

type PushActionsProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler PushActions
}

func (p *PushActionsProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *PushActionsProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *PushActionsProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewPushActionsProcessor(handler PushActions) *PushActionsProcessor {

  self66 := &PushActionsProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self66.processorMap["push_actions"] = &pushActionsProcessorPushActions{handler:handler}
return self66
}

func (p *PushActionsProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x67 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x67.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x67

}

type pushActionsProcessorPushActions struct {
  handler PushActions
}

func (p *pushActionsProcessorPushActions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PushActionsPushActionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := PushActionsPushActionsResult{}
  var retval int32
  if retval, err2 = p.handler.PushActions(ctx, args.Actions); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing push_actions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "push_actions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "push_actions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Actions
type PushActionsPushActionsArgs struct {
  Actions []*Action `thrift:"actions,1" db:"actions" json:"actions"`
}

func NewPushActionsPushActionsArgs() *PushActionsPushActionsArgs {
  return &PushActionsPushActionsArgs{}
}


func (p *PushActionsPushActionsArgs) GetActions() []*Action {
  return p.Actions
}
func (p *PushActionsPushActionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Action, 0, size)
  p.Actions =  tSlice
  for i := 0; i < size; i ++ {
    _elem68 := &Action{}
    if err := _elem68.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem68), err)
    }
    p.Actions = append(p.Actions, _elem68)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PushActionsPushActionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "actions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:actions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Actions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Actions {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:actions: ", p), err) }
  return err
}

func (p *PushActionsPushActionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type PushActionsPushActionsResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewPushActionsPushActionsResult() *PushActionsPushActionsResult {
  return &PushActionsPushActionsResult{}
}

var PushActionsPushActionsResult_Success_DEFAULT int32
func (p *PushActionsPushActionsResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return PushActionsPushActionsResult_Success_DEFAULT
  }
return *p.Success
}
func (p *PushActionsPushActionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *PushActionsPushActionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PushActionsPushActionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *PushActionsPushActionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "push_actions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PushActionsPushActionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *PushActionsPushActionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PushActionsPushActionsResult(%+v)", *p)
}


type ApplyRequest interface {
  // Parameters:
  //  - Receiver
  //  - FirstReceiver
  //  - Action
  ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64) (_r int32, _err error)
  ApplyEnd(ctx context.Context) (_r int32, _err error)
}

type ApplyRequestClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyRequestClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyRequestClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyRequestClient(c thrift.TClient) *ApplyRequestClient {
  return &ApplyRequestClient{
    c: c,
  }
}

func (p *ApplyRequestClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyRequestClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyRequestClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Receiver
//  - FirstReceiver
//  - Action
func (p *ApplyRequestClient) ApplyRequest(ctx context.Context, receiver *Uint64, firstReceiver *Uint64, action *Uint64) (_r int32, _err error) {
  var _args75 ApplyRequestApplyRequestArgs
  _args75.Receiver = receiver
  _args75.FirstReceiver = firstReceiver
  _args75.Action = action
  var _result77 ApplyRequestApplyRequestResult
  var _meta76 thrift.ResponseMeta
  _meta76, _err = p.Client_().Call(ctx, "apply_request", &_args75, &_result77)
  p.SetLastResponseMeta_(_meta76)
  if _err != nil {
    return
  }
  return _result77.GetSuccess(), nil
}

func (p *ApplyRequestClient) ApplyEnd(ctx context.Context) (_r int32, _err error) {
  var _args78 ApplyRequestApplyEndArgs
  var _result80 ApplyRequestApplyEndResult
  var _meta79 thrift.ResponseMeta
  _meta79, _err = p.Client_().Call(ctx, "apply_end", &_args78, &_result80)
  p.SetLastResponseMeta_(_meta79)
  if _err != nil {
    return
  }
  return _result80.GetSuccess(), nil
}

type ApplyRequestProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ApplyRequest
}

func (p *ApplyRequestProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyRequestProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyRequestProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyRequestProcessor(handler ApplyRequest) *ApplyRequestProcessor {

  self81 := &ApplyRequestProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self81.processorMap["apply_request"] = &applyRequestProcessorApplyRequest{handler:handler}
  self81.processorMap["apply_end"] = &applyRequestProcessorApplyEnd{handler:handler}
return self81
}

func (p *ApplyRequestProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x82 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x82.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x82

}

type applyRequestProcessorApplyRequest struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyRequest) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyRequestArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyRequestResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyRequest(ctx, args.Receiver, args.FirstReceiver, args.Action); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_request: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_request", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_request", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyRequestProcessorApplyEnd struct {
  handler ApplyRequest
}

func (p *applyRequestProcessorApplyEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequestApplyEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequestApplyEndResult{}
  var retval int32
  if retval, err2 = p.handler.ApplyEnd(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing apply_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "apply_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "apply_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Receiver
//  - FirstReceiver
//  - Action
type ApplyRequestApplyRequestArgs struct {
  Receiver *Uint64 `thrift:"receiver,1" db:"receiver" json:"receiver"`
  FirstReceiver *Uint64 `thrift:"firstReceiver,2" db:"firstReceiver" json:"firstReceiver"`
  Action *Uint64 `thrift:"action,3" db:"action" json:"action"`
}

func NewApplyRequestApplyRequestArgs() *ApplyRequestApplyRequestArgs {
  return &ApplyRequestApplyRequestArgs{}
}

var ApplyRequestApplyRequestArgs_Receiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetReceiver() *Uint64 {
  if !p.IsSetReceiver() {
    return ApplyRequestApplyRequestArgs_Receiver_DEFAULT
  }
return p.Receiver
}
var ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetFirstReceiver() *Uint64 {
  if !p.IsSetFirstReceiver() {
    return ApplyRequestApplyRequestArgs_FirstReceiver_DEFAULT
  }
return p.FirstReceiver
}
var ApplyRequestApplyRequestArgs_Action_DEFAULT *Uint64
func (p *ApplyRequestApplyRequestArgs) GetAction() *Uint64 {
  if !p.IsSetAction() {
    return ApplyRequestApplyRequestArgs_Action_DEFAULT
  }
return p.Action
}
func (p *ApplyRequestApplyRequestArgs) IsSetReceiver() bool {
  return p.Receiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetFirstReceiver() bool {
  return p.FirstReceiver != nil
}

func (p *ApplyRequestApplyRequestArgs) IsSetAction() bool {
  return p.Action != nil
}

func (p *ApplyRequestApplyRequestArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Receiver = &Uint64{}
  if err := p.Receiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Receiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.FirstReceiver = &Uint64{}
  if err := p.FirstReceiver.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.FirstReceiver), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Action = &Uint64{}
  if err := p.Action.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Action), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "receiver", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:receiver: ", p), err) }
  if err := p.Receiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Receiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:receiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "firstReceiver", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:firstReceiver: ", p), err) }
  if err := p.FirstReceiver.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.FirstReceiver), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:firstReceiver: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := p.Action.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Action), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *ApplyRequestApplyRequestArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyRequestResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyRequestResult() *ApplyRequestApplyRequestResult {
  return &ApplyRequestApplyRequestResult{}
}

var ApplyRequestApplyRequestResult_Success_DEFAULT int32
func (p *ApplyRequestApplyRequestResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyRequestResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyRequestResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyRequestResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyRequestResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyRequestResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_request_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyRequestResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyRequestResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyRequestResult(%+v)", *p)
}

type ApplyRequestApplyEndArgs struct {
}

func NewApplyRequestApplyEndArgs() *ApplyRequestApplyEndArgs {
  return &ApplyRequestApplyEndArgs{}
}

func (p *ApplyRequestApplyEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRequestApplyEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRequestApplyEndResult() *ApplyRequestApplyEndResult {
  return &ApplyRequestApplyEndResult{}
}

var ApplyRequestApplyEndResult_Success_DEFAULT int32
func (p *ApplyRequestApplyEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyRequestApplyEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyRequestApplyEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRequestApplyEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequestApplyEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyRequestApplyEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "apply_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequestApplyEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRequestApplyEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequestApplyEndResult(%+v)", *p)
}


type Apply interface {
  EndApply(ctx context.Context) (_r int32, _err error)
  // Parameters:
  //  - Cstr
  Prints(ctx context.Context, cstr string) (_err error)
  // Parameters:
  //  - Cstr
  PrintsL(ctx context.Context, cstr []byte) (_err error)
  // Parameters:
  //  - N
  Printi(ctx context.Context, n int64) (_err error)
  // Parameters:
  //  - N
  Printui(ctx context.Context, n *Uint64) (_err error)
  // Parameters:
  //  - Value
  Printi128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printui128(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printsf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printdf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Value
  Printqf(ctx context.Context, value []byte) (_err error)
  // Parameters:
  //  - Name
  Printn(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Data
  Printhex(ctx context.Context, data []byte) (_err error)
  ActionDataSize(ctx context.Context) (_r int32, _err error)
  ReadActionData(ctx context.Context) (_r []byte, _err error)
  // Parameters:
  //  - Name
  RequireRecipient(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  RequireAuth(ctx context.Context, name *Uint64) (_err error)
  // Parameters:
  //  - Name
  HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - Name
  //  - Permission
  RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error)
  // Parameters:
  //  - Name
  IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error)
  // Parameters:
  //  - SerializedAction
  SendInline(ctx context.Context, serialized_action []byte) (_err error)
  // Parameters:
  //  - SerializedData
  SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error)
  PublicationTime(ctx context.Context) (_r *Uint64, _err error)
  CurrentReceiver(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssert(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Msg
  EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error)
  // Parameters:
  //  - Test
  //  - Code
  EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error)
  // Parameters:
  //  - Code
  EosioExit(ctx context.Context, code int32) (_err error)
  CurrentTime(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - FeatureDigest
  IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error)
  GetSender(ctx context.Context) (_r *Uint64, _err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  //  - Hash
  AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error)
  // Parameters:
  //  - Data
  Sha256(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha1(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Sha512(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Data
  Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error)
  // Parameters:
  //  - Digest
  //  - Sig
  //  - Pub
  AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error)
  // Parameters:
  //  - SenderID
  //  - Payer
  //  - SerializedTransaction
  //  - ReplaceExisting
  SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error)
  // Parameters:
  //  - SenderID
  CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error)
  ReadTransaction(ctx context.Context) (_r []byte, _err error)
  TransactionSize(ctx context.Context) (_r int32, _err error)
  TaposBlockNum(ctx context.Context) (_r int32, _err error)
  TaposBlockPrefix(ctx context.Context) (_r int32, _err error)
  Expiration(ctx context.Context) (_r int64, _err error)
  // Parameters:
  //  - _type
  //  - Index
  GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Index
  GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbRemoveI64(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error)
  // Parameters:
  //  - Iterator
  DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - ID
  DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iteratory
  DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Data
  DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Data
  DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Remove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Data
  //  - Primary
  DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
  // Parameters:
  //  - Scope
  //  - Table
  //  - Payer
  //  - ID
  //  - Secondary
  DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error)
  // Parameters:
  //  - Iterator
  //  - Payer
  //  - Secondary
  DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Iterator
  DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Primary
  DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  //  - Secondary
  //  - Primary
  DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error)
  // Parameters:
  //  - Code
  //  - Scope
  //  - Table
  DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error)
}

type ApplyClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewApplyClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewApplyClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ApplyClient {
  return &ApplyClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewApplyClient(c thrift.TClient) *ApplyClient {
  return &ApplyClient{
    c: c,
  }
}

func (p *ApplyClient) Client_() thrift.TClient {
  return p.c
}

func (p *ApplyClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ApplyClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *ApplyClient) EndApply(ctx context.Context) (_r int32, _err error) {
  var _args101 ApplyEndApplyArgs
  var _result103 ApplyEndApplyResult
  var _meta102 thrift.ResponseMeta
  _meta102, _err = p.Client_().Call(ctx, "end_apply", &_args101, &_result103)
  p.SetLastResponseMeta_(_meta102)
  if _err != nil {
    return
  }
  return _result103.GetSuccess(), nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) Prints(ctx context.Context, cstr string) (_err error) {
  var _args104 ApplyPrintsArgs
  _args104.Cstr = cstr
  var _result106 ApplyPrintsResult
  var _meta105 thrift.ResponseMeta
  _meta105, _err = p.Client_().Call(ctx, "prints", &_args104, &_result106)
  p.SetLastResponseMeta_(_meta105)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Cstr
func (p *ApplyClient) PrintsL(ctx context.Context, cstr []byte) (_err error) {
  var _args107 ApplyPrintsLArgs
  _args107.Cstr = cstr
  var _result109 ApplyPrintsLResult
  var _meta108 thrift.ResponseMeta
  _meta108, _err = p.Client_().Call(ctx, "prints_l", &_args107, &_result109)
  p.SetLastResponseMeta_(_meta108)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printi(ctx context.Context, n int64) (_err error) {
  var _args110 ApplyPrintiArgs
  _args110.N = n
  var _result112 ApplyPrintiResult
  var _meta111 thrift.ResponseMeta
  _meta111, _err = p.Client_().Call(ctx, "printi", &_args110, &_result112)
  p.SetLastResponseMeta_(_meta111)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - N
func (p *ApplyClient) Printui(ctx context.Context, n *Uint64) (_err error) {
  var _args113 ApplyPrintuiArgs
  _args113.N = n
  var _result115 ApplyPrintuiResult
  var _meta114 thrift.ResponseMeta
  _meta114, _err = p.Client_().Call(ctx, "printui", &_args113, &_result115)
  p.SetLastResponseMeta_(_meta114)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printi128(ctx context.Context, value []byte) (_err error) {
  var _args116 ApplyPrinti128Args
  _args116.Value = value
  var _result118 ApplyPrinti128Result
  var _meta117 thrift.ResponseMeta
  _meta117, _err = p.Client_().Call(ctx, "printi128", &_args116, &_result118)
  p.SetLastResponseMeta_(_meta117)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printui128(ctx context.Context, value []byte) (_err error) {
  var _args119 ApplyPrintui128Args
  _args119.Value = value
  var _result121 ApplyPrintui128Result
  var _meta120 thrift.ResponseMeta
  _meta120, _err = p.Client_().Call(ctx, "printui128", &_args119, &_result121)
  p.SetLastResponseMeta_(_meta120)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printsf(ctx context.Context, value []byte) (_err error) {
  var _args122 ApplyPrintsfArgs
  _args122.Value = value
  var _result124 ApplyPrintsfResult
  var _meta123 thrift.ResponseMeta
  _meta123, _err = p.Client_().Call(ctx, "printsf", &_args122, &_result124)
  p.SetLastResponseMeta_(_meta123)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printdf(ctx context.Context, value []byte) (_err error) {
  var _args125 ApplyPrintdfArgs
  _args125.Value = value
  var _result127 ApplyPrintdfResult
  var _meta126 thrift.ResponseMeta
  _meta126, _err = p.Client_().Call(ctx, "printdf", &_args125, &_result127)
  p.SetLastResponseMeta_(_meta126)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Value
func (p *ApplyClient) Printqf(ctx context.Context, value []byte) (_err error) {
  var _args128 ApplyPrintqfArgs
  _args128.Value = value
  var _result130 ApplyPrintqfResult
  var _meta129 thrift.ResponseMeta
  _meta129, _err = p.Client_().Call(ctx, "printqf", &_args128, &_result130)
  p.SetLastResponseMeta_(_meta129)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) Printn(ctx context.Context, name *Uint64) (_err error) {
  var _args131 ApplyPrintnArgs
  _args131.Name = name
  var _result133 ApplyPrintnResult
  var _meta132 thrift.ResponseMeta
  _meta132, _err = p.Client_().Call(ctx, "printn", &_args131, &_result133)
  p.SetLastResponseMeta_(_meta132)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Printhex(ctx context.Context, data []byte) (_err error) {
  var _args134 ApplyPrinthexArgs
  _args134.Data = data
  var _result136 ApplyPrinthexResult
  var _meta135 thrift.ResponseMeta
  _meta135, _err = p.Client_().Call(ctx, "printhex", &_args134, &_result136)
  p.SetLastResponseMeta_(_meta135)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) ActionDataSize(ctx context.Context) (_r int32, _err error) {
  var _args137 ApplyActionDataSizeArgs
  var _result139 ApplyActionDataSizeResult
  var _meta138 thrift.ResponseMeta
  _meta138, _err = p.Client_().Call(ctx, "action_data_size", &_args137, &_result139)
  p.SetLastResponseMeta_(_meta138)
  if _err != nil {
    return
  }
  return _result139.GetSuccess(), nil
}

func (p *ApplyClient) ReadActionData(ctx context.Context) (_r []byte, _err error) {
  var _args140 ApplyReadActionDataArgs
  var _result142 ApplyReadActionDataResult
  var _meta141 thrift.ResponseMeta
  _meta141, _err = p.Client_().Call(ctx, "read_action_data", &_args140, &_result142)
  p.SetLastResponseMeta_(_meta141)
  if _err != nil {
    return
  }
  return _result142.GetSuccess(), nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireRecipient(ctx context.Context, name *Uint64) (_err error) {
  var _args143 ApplyRequireRecipientArgs
  _args143.Name = name
  var _result145 ApplyRequireRecipientResult
  var _meta144 thrift.ResponseMeta
  _meta144, _err = p.Client_().Call(ctx, "require_recipient", &_args143, &_result145)
  p.SetLastResponseMeta_(_meta144)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) RequireAuth(ctx context.Context, name *Uint64) (_err error) {
  var _args146 ApplyRequireAuthArgs
  _args146.Name = name
  var _result148 ApplyRequireAuthResult
  var _meta147 thrift.ResponseMeta
  _meta147, _err = p.Client_().Call(ctx, "require_auth", &_args146, &_result148)
  p.SetLastResponseMeta_(_meta147)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) HasAuth(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args149 ApplyHasAuthArgs
  _args149.Name = name
  var _result151 ApplyHasAuthResult
  var _meta150 thrift.ResponseMeta
  _meta150, _err = p.Client_().Call(ctx, "has_auth", &_args149, &_result151)
  p.SetLastResponseMeta_(_meta150)
  if _err != nil {
    return
  }
  return _result151.GetSuccess(), nil
}

// Parameters:
//  - Name
//  - Permission
func (p *ApplyClient) RequireAuth2(ctx context.Context, name *Uint64, permission *Uint64) (_err error) {
  var _args152 ApplyRequireAuth2Args
  _args152.Name = name
  _args152.Permission = permission
  var _result154 ApplyRequireAuth2Result
  var _meta153 thrift.ResponseMeta
  _meta153, _err = p.Client_().Call(ctx, "require_auth2", &_args152, &_result154)
  p.SetLastResponseMeta_(_meta153)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Name
func (p *ApplyClient) IsAccount(ctx context.Context, name *Uint64) (_r bool, _err error) {
  var _args155 ApplyIsAccountArgs
  _args155.Name = name
  var _result157 ApplyIsAccountResult
  var _meta156 thrift.ResponseMeta
  _meta156, _err = p.Client_().Call(ctx, "is_account", &_args155, &_result157)
  p.SetLastResponseMeta_(_meta156)
  if _err != nil {
    return
  }
  return _result157.GetSuccess(), nil
}

// Parameters:
//  - SerializedAction
func (p *ApplyClient) SendInline(ctx context.Context, serialized_action []byte) (_err error) {
  var _args158 ApplySendInlineArgs
  _args158.SerializedAction = serialized_action
  var _result160 ApplySendInlineResult
  var _meta159 thrift.ResponseMeta
  _meta159, _err = p.Client_().Call(ctx, "send_inline", &_args158, &_result160)
  p.SetLastResponseMeta_(_meta159)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SerializedData
func (p *ApplyClient) SendContextFreeInline(ctx context.Context, serialized_data []byte) (_err error) {
  var _args161 ApplySendContextFreeInlineArgs
  _args161.SerializedData = serialized_data
  var _result163 ApplySendContextFreeInlineResult
  var _meta162 thrift.ResponseMeta
  _meta162, _err = p.Client_().Call(ctx, "send_context_free_inline", &_args161, &_result163)
  p.SetLastResponseMeta_(_meta162)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) PublicationTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args164 ApplyPublicationTimeArgs
  var _result166 ApplyPublicationTimeResult
  var _meta165 thrift.ResponseMeta
  _meta165, _err = p.Client_().Call(ctx, "publication_time", &_args164, &_result166)
  p.SetLastResponseMeta_(_meta165)
  if _err != nil {
    return
  }
  if _ret167 := _result166.GetSuccess(); _ret167 != nil {
    return _ret167, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "publication_time failed: unknown result")
}

func (p *ApplyClient) CurrentReceiver(ctx context.Context) (_r *Uint64, _err error) {
  var _args168 ApplyCurrentReceiverArgs
  var _result170 ApplyCurrentReceiverResult
  var _meta169 thrift.ResponseMeta
  _meta169, _err = p.Client_().Call(ctx, "current_receiver", &_args168, &_result170)
  p.SetLastResponseMeta_(_meta169)
  if _err != nil {
    return
  }
  if _ret171 := _result170.GetSuccess(); _ret171 != nil {
    return _ret171, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_receiver failed: unknown result")
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssert(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args172 ApplyEosioAssertArgs
  _args172.Test = test
  _args172.Msg = msg
  var _result174 ApplyEosioAssertResult
  var _meta173 thrift.ResponseMeta
  _meta173, _err = p.Client_().Call(ctx, "eosio_assert", &_args172, &_result174)
  p.SetLastResponseMeta_(_meta173)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Msg
func (p *ApplyClient) EosioAssertMessage(ctx context.Context, test bool, msg []byte) (_err error) {
  var _args175 ApplyEosioAssertMessageArgs
  _args175.Test = test
  _args175.Msg = msg
  var _result177 ApplyEosioAssertMessageResult
  var _meta176 thrift.ResponseMeta
  _meta176, _err = p.Client_().Call(ctx, "eosio_assert_message", &_args175, &_result177)
  p.SetLastResponseMeta_(_meta176)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Test
//  - Code
func (p *ApplyClient) EosioAssertCode(ctx context.Context, test bool, code *Uint64) (_err error) {
  var _args178 ApplyEosioAssertCodeArgs
  _args178.Test = test
  _args178.Code = code
  var _result180 ApplyEosioAssertCodeResult
  var _meta179 thrift.ResponseMeta
  _meta179, _err = p.Client_().Call(ctx, "eosio_assert_code", &_args178, &_result180)
  p.SetLastResponseMeta_(_meta179)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Code
func (p *ApplyClient) EosioExit(ctx context.Context, code int32) (_err error) {
  var _args181 ApplyEosioExitArgs
  _args181.Code = code
  var _result183 ApplyEosioExitResult
  var _meta182 thrift.ResponseMeta
  _meta182, _err = p.Client_().Call(ctx, "eosio_exit", &_args181, &_result183)
  p.SetLastResponseMeta_(_meta182)
  if _err != nil {
    return
  }
  return nil
}

func (p *ApplyClient) CurrentTime(ctx context.Context) (_r *Uint64, _err error) {
  var _args184 ApplyCurrentTimeArgs
  var _result186 ApplyCurrentTimeResult
  var _meta185 thrift.ResponseMeta
  _meta185, _err = p.Client_().Call(ctx, "current_time", &_args184, &_result186)
  p.SetLastResponseMeta_(_meta185)
  if _err != nil {
    return
  }
  if _ret187 := _result186.GetSuccess(); _ret187 != nil {
    return _ret187, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "current_time failed: unknown result")
}

// Parameters:
//  - FeatureDigest
func (p *ApplyClient) IsFeatureActivated(ctx context.Context, feature_digest []byte) (_r bool, _err error) {
  var _args188 ApplyIsFeatureActivatedArgs
  _args188.FeatureDigest = feature_digest
  var _result190 ApplyIsFeatureActivatedResult
  var _meta189 thrift.ResponseMeta
  _meta189, _err = p.Client_().Call(ctx, "is_feature_activated", &_args188, &_result190)
  p.SetLastResponseMeta_(_meta189)
  if _err != nil {
    return
  }
  return _result190.GetSuccess(), nil
}

func (p *ApplyClient) GetSender(ctx context.Context) (_r *Uint64, _err error) {
  var _args191 ApplyGetSenderArgs
  var _result193 ApplyGetSenderResult
  var _meta192 thrift.ResponseMeta
  _meta192, _err = p.Client_().Call(ctx, "get_sender", &_args191, &_result193)
  p.SetLastResponseMeta_(_meta192)
  if _err != nil {
    return
  }
  if _ret194 := _result193.GetSuccess(); _ret194 != nil {
    return _ret194, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get_sender failed: unknown result")
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha256(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args195 ApplyAssertSha256Args
  _args195.Data = data
  _args195.Hash = hash
  var _result197 ApplyAssertSha256Result
  var _meta196 thrift.ResponseMeta
  _meta196, _err = p.Client_().Call(ctx, "assert_sha256", &_args195, &_result197)
  p.SetLastResponseMeta_(_meta196)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha1(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args198 ApplyAssertSha1Args
  _args198.Data = data
  _args198.Hash = hash
  var _result200 ApplyAssertSha1Result
  var _meta199 thrift.ResponseMeta
  _meta199, _err = p.Client_().Call(ctx, "assert_sha1", &_args198, &_result200)
  p.SetLastResponseMeta_(_meta199)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertSha512(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args201 ApplyAssertSha512Args
  _args201.Data = data
  _args201.Hash = hash
  var _result203 ApplyAssertSha512Result
  var _meta202 thrift.ResponseMeta
  _meta202, _err = p.Client_().Call(ctx, "assert_sha512", &_args201, &_result203)
  p.SetLastResponseMeta_(_meta202)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
//  - Hash
func (p *ApplyClient) AssertRipemd160(ctx context.Context, data []byte, hash []byte) (_err error) {
  var _args204 ApplyAssertRipemd160Args
  _args204.Data = data
  _args204.Hash = hash
  var _result206 ApplyAssertRipemd160Result
  var _meta205 thrift.ResponseMeta
  _meta205, _err = p.Client_().Call(ctx, "assert_ripemd160", &_args204, &_result206)
  p.SetLastResponseMeta_(_meta205)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha256(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args207 ApplySha256Args
  _args207.Data = data
  var _result209 ApplySha256Result
  var _meta208 thrift.ResponseMeta
  _meta208, _err = p.Client_().Call(ctx, "sha256", &_args207, &_result209)
  p.SetLastResponseMeta_(_meta208)
  if _err != nil {
    return
  }
  return _result209.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha1(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args210 ApplySha1Args
  _args210.Data = data
  var _result212 ApplySha1Result
  var _meta211 thrift.ResponseMeta
  _meta211, _err = p.Client_().Call(ctx, "sha1", &_args210, &_result212)
  p.SetLastResponseMeta_(_meta211)
  if _err != nil {
    return
  }
  return _result212.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Sha512(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args213 ApplySha512Args
  _args213.Data = data
  var _result215 ApplySha512Result
  var _meta214 thrift.ResponseMeta
  _meta214, _err = p.Client_().Call(ctx, "sha512", &_args213, &_result215)
  p.SetLastResponseMeta_(_meta214)
  if _err != nil {
    return
  }
  return _result215.GetSuccess(), nil
}

// Parameters:
//  - Data
func (p *ApplyClient) Ripemd160(ctx context.Context, data []byte) (_r []byte, _err error) {
  var _args216 ApplyRipemd160Args
  _args216.Data = data
  var _result218 ApplyRipemd160Result
  var _meta217 thrift.ResponseMeta
  _meta217, _err = p.Client_().Call(ctx, "ripemd160", &_args216, &_result218)
  p.SetLastResponseMeta_(_meta217)
  if _err != nil {
    return
  }
  return _result218.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
func (p *ApplyClient) RecoverKey(ctx context.Context, digest []byte, sig []byte) (_r []byte, _err error) {
  var _args219 ApplyRecoverKeyArgs
  _args219.Digest = digest
  _args219.Sig = sig
  var _result221 ApplyRecoverKeyResult
  var _meta220 thrift.ResponseMeta
  _meta220, _err = p.Client_().Call(ctx, "recover_key", &_args219, &_result221)
  p.SetLastResponseMeta_(_meta220)
  if _err != nil {
    return
  }
  return _result221.GetSuccess(), nil
}

// Parameters:
//  - Digest
//  - Sig
//  - Pub
func (p *ApplyClient) AssertRecoverKey(ctx context.Context, digest []byte, sig []byte, pub []byte) (_err error) {
  var _args222 ApplyAssertRecoverKeyArgs
  _args222.Digest = digest
  _args222.Sig = sig
  _args222.Pub = pub
  var _result224 ApplyAssertRecoverKeyResult
  var _meta223 thrift.ResponseMeta
  _meta223, _err = p.Client_().Call(ctx, "assert_recover_key", &_args222, &_result224)
  p.SetLastResponseMeta_(_meta223)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
func (p *ApplyClient) SendDeferred(ctx context.Context, sender_id []byte, payer *Uint64, serialized_transaction []byte, replace_existing int32) (_err error) {
  var _args225 ApplySendDeferredArgs
  _args225.SenderID = sender_id
  _args225.Payer = payer
  _args225.SerializedTransaction = serialized_transaction
  _args225.ReplaceExisting = replace_existing
  var _result227 ApplySendDeferredResult
  var _meta226 thrift.ResponseMeta
  _meta226, _err = p.Client_().Call(ctx, "send_deferred", &_args225, &_result227)
  p.SetLastResponseMeta_(_meta226)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - SenderID
func (p *ApplyClient) CancelDeferred(ctx context.Context, sender_id []byte) (_r int32, _err error) {
  var _args228 ApplyCancelDeferredArgs
  _args228.SenderID = sender_id
  var _result230 ApplyCancelDeferredResult
  var _meta229 thrift.ResponseMeta
  _meta229, _err = p.Client_().Call(ctx, "cancel_deferred", &_args228, &_result230)
  p.SetLastResponseMeta_(_meta229)
  if _err != nil {
    return
  }
  return _result230.GetSuccess(), nil
}

func (p *ApplyClient) ReadTransaction(ctx context.Context) (_r []byte, _err error) {
  var _args231 ApplyReadTransactionArgs
  var _result233 ApplyReadTransactionResult
  var _meta232 thrift.ResponseMeta
  _meta232, _err = p.Client_().Call(ctx, "read_transaction", &_args231, &_result233)
  p.SetLastResponseMeta_(_meta232)
  if _err != nil {
    return
  }
  return _result233.GetSuccess(), nil
}

func (p *ApplyClient) TransactionSize(ctx context.Context) (_r int32, _err error) {
  var _args234 ApplyTransactionSizeArgs
  var _result236 ApplyTransactionSizeResult
  var _meta235 thrift.ResponseMeta
  _meta235, _err = p.Client_().Call(ctx, "transaction_size", &_args234, &_result236)
  p.SetLastResponseMeta_(_meta235)
  if _err != nil {
    return
  }
  return _result236.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockNum(ctx context.Context) (_r int32, _err error) {
  var _args237 ApplyTaposBlockNumArgs
  var _result239 ApplyTaposBlockNumResult
  var _meta238 thrift.ResponseMeta
  _meta238, _err = p.Client_().Call(ctx, "tapos_block_num", &_args237, &_result239)
  p.SetLastResponseMeta_(_meta238)
  if _err != nil {
    return
  }
  return _result239.GetSuccess(), nil
}

func (p *ApplyClient) TaposBlockPrefix(ctx context.Context) (_r int32, _err error) {
  var _args240 ApplyTaposBlockPrefixArgs
  var _result242 ApplyTaposBlockPrefixResult
  var _meta241 thrift.ResponseMeta
  _meta241, _err = p.Client_().Call(ctx, "tapos_block_prefix", &_args240, &_result242)
  p.SetLastResponseMeta_(_meta241)
  if _err != nil {
    return
  }
  return _result242.GetSuccess(), nil
}

func (p *ApplyClient) Expiration(ctx context.Context) (_r int64, _err error) {
  var _args243 ApplyExpirationArgs
  var _result245 ApplyExpirationResult
  var _meta244 thrift.ResponseMeta
  _meta244, _err = p.Client_().Call(ctx, "expiration", &_args243, &_result245)
  p.SetLastResponseMeta_(_meta244)
  if _err != nil {
    return
  }
  return _result245.GetSuccess(), nil
}

// Parameters:
//  - _type
//  - Index
func (p *ApplyClient) GetAction(ctx context.Context, _type int32, index int32) (_r []byte, _err error) {
  var _args246 ApplyGetActionArgs
  _args246._type = _type
  _args246.Index = index
  var _result248 ApplyGetActionResult
  var _meta247 thrift.ResponseMeta
  _meta247, _err = p.Client_().Call(ctx, "get_action", &_args246, &_result248)
  p.SetLastResponseMeta_(_meta247)
  if _err != nil {
    return
  }
  return _result248.GetSuccess(), nil
}

// Parameters:
//  - Index
func (p *ApplyClient) GetContextFreeData(ctx context.Context, index int32) (_r []byte, _err error) {
  var _args249 ApplyGetContextFreeDataArgs
  _args249.Index = index
  var _result251 ApplyGetContextFreeDataResult
  var _meta250 thrift.ResponseMeta
  _meta250, _err = p.Client_().Call(ctx, "get_context_free_data", &_args249, &_result251)
  p.SetLastResponseMeta_(_meta250)
  if _err != nil {
    return
  }
  return _result251.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbStoreI64(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args252 ApplyDbStoreI64Args
  _args252.Scope = scope
  _args252.Table = table
  _args252.Payer = payer
  _args252.ID = id
  _args252.Data = data
  var _result254 ApplyDbStoreI64Result
  var _meta253 thrift.ResponseMeta
  _meta253, _err = p.Client_().Call(ctx, "db_store_i64", &_args252, &_result254)
  p.SetLastResponseMeta_(_meta253)
  if _err != nil {
    return
  }
  return _result254.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbUpdateI64(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args255 ApplyDbUpdateI64Args
  _args255.Iterator = iterator
  _args255.Payer = payer
  _args255.Data = data
  var _result257 ApplyDbUpdateI64Result
  var _meta256 thrift.ResponseMeta
  _meta256, _err = p.Client_().Call(ctx, "db_update_i64", &_args255, &_result257)
  p.SetLastResponseMeta_(_meta256)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbRemoveI64(ctx context.Context, iterator int32) (_err error) {
  var _args258 ApplyDbRemoveI64Args
  _args258.Iterator = iterator
  var _result260 ApplyDbRemoveI64Result
  var _meta259 thrift.ResponseMeta
  _meta259, _err = p.Client_().Call(ctx, "db_remove_i64", &_args258, &_result260)
  p.SetLastResponseMeta_(_meta259)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbGetI64(ctx context.Context, iterator int32) (_r []byte, _err error) {
  var _args261 ApplyDbGetI64Args
  _args261.Iterator = iterator
  var _result263 ApplyDbGetI64Result
  var _meta262 thrift.ResponseMeta
  _meta262, _err = p.Client_().Call(ctx, "db_get_i64", &_args261, &_result263)
  p.SetLastResponseMeta_(_meta262)
  if _err != nil {
    return
  }
  return _result263.GetSuccess(), nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbNextI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args264 ApplyDbNextI64Args
  _args264.Iterator = iterator
  var _result266 ApplyDbNextI64Result
  var _meta265 thrift.ResponseMeta
  _meta265, _err = p.Client_().Call(ctx, "db_next_i64", &_args264, &_result266)
  p.SetLastResponseMeta_(_meta265)
  if _err != nil {
    return
  }
  if _ret267 := _result266.GetSuccess(); _ret267 != nil {
    return _ret267, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_next_i64 failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbPreviousI64(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args268 ApplyDbPreviousI64Args
  _args268.Iterator = iterator
  var _result270 ApplyDbPreviousI64Result
  var _meta269 thrift.ResponseMeta
  _meta269, _err = p.Client_().Call(ctx, "db_previous_i64", &_args268, &_result270)
  p.SetLastResponseMeta_(_meta269)
  if _err != nil {
    return
  }
  if _ret271 := _result270.GetSuccess(); _ret271 != nil {
    return _ret271, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_previous_i64 failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbFindI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args272 ApplyDbFindI64Args
  _args272.Code = code
  _args272.Scope = scope
  _args272.Table = table
  _args272.ID = id
  var _result274 ApplyDbFindI64Result
  var _meta273 thrift.ResponseMeta
  _meta273, _err = p.Client_().Call(ctx, "db_find_i64", &_args272, &_result274)
  p.SetLastResponseMeta_(_meta273)
  if _err != nil {
    return
  }
  return _result274.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbLowerboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args275 ApplyDbLowerboundI64Args
  _args275.Code = code
  _args275.Scope = scope
  _args275.Table = table
  _args275.ID = id
  var _result277 ApplyDbLowerboundI64Result
  var _meta276 thrift.ResponseMeta
  _meta276, _err = p.Client_().Call(ctx, "db_lowerbound_i64", &_args275, &_result277)
  p.SetLastResponseMeta_(_meta276)
  if _err != nil {
    return
  }
  return _result277.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - ID
func (p *ApplyClient) DbUpperboundI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, id *Uint64) (_r int32, _err error) {
  var _args278 ApplyDbUpperboundI64Args
  _args278.Code = code
  _args278.Scope = scope
  _args278.Table = table
  _args278.ID = id
  var _result280 ApplyDbUpperboundI64Result
  var _meta279 thrift.ResponseMeta
  _meta279, _err = p.Client_().Call(ctx, "db_upperbound_i64", &_args278, &_result280)
  p.SetLastResponseMeta_(_meta279)
  if _err != nil {
    return
  }
  return _result280.GetSuccess(), nil
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbEndI64(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args281 ApplyDbEndI64Args
  _args281.Code = code
  _args281.Scope = scope
  _args281.Table = table
  var _result283 ApplyDbEndI64Result
  var _meta282 thrift.ResponseMeta
  _meta282, _err = p.Client_().Call(ctx, "db_end_i64", &_args281, &_result283)
  p.SetLastResponseMeta_(_meta282)
  if _err != nil {
    return
  }
  return _result283.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx64Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary *Uint64) (_r int32, _err error) {
  var _args284 ApplyDbIdx64StoreArgs
  _args284.Scope = scope
  _args284.Table = table
  _args284.Payer = payer
  _args284.ID = id
  _args284.Secondary = secondary
  var _result286 ApplyDbIdx64StoreResult
  var _meta285 thrift.ResponseMeta
  _meta285, _err = p.Client_().Call(ctx, "db_idx64_store", &_args284, &_result286)
  p.SetLastResponseMeta_(_meta285)
  if _err != nil {
    return
  }
  return _result286.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx64Update(ctx context.Context, iterator int32, payer *Uint64, secondary *Uint64) (_err error) {
  var _args287 ApplyDbIdx64UpdateArgs
  _args287.Iterator = iterator
  _args287.Payer = payer
  _args287.Secondary = secondary
  var _result289 ApplyDbIdx64UpdateResult
  var _meta288 thrift.ResponseMeta
  _meta288, _err = p.Client_().Call(ctx, "db_idx64_update", &_args287, &_result289)
  p.SetLastResponseMeta_(_meta288)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Remove(ctx context.Context, iterator int32) (_err error) {
  var _args290 ApplyDbIdx64RemoveArgs
  _args290.Iterator = iterator
  var _result292 ApplyDbIdx64RemoveResult
  var _meta291 thrift.ResponseMeta
  _meta291, _err = p.Client_().Call(ctx, "db_idx64_remove", &_args290, &_result292)
  p.SetLastResponseMeta_(_meta291)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx64Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args293 ApplyDbIdx64NextArgs
  _args293.Iterator = iterator
  var _result295 ApplyDbIdx64NextResult
  var _meta294 thrift.ResponseMeta
  _meta294, _err = p.Client_().Call(ctx, "db_idx64_next", &_args293, &_result295)
  p.SetLastResponseMeta_(_meta294)
  if _err != nil {
    return
  }
  if _ret296 := _result295.GetSuccess(); _ret296 != nil {
    return _ret296, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_next failed: unknown result")
}

// Parameters:
//  - Iteratory
func (p *ApplyClient) DbIdx64Previous(ctx context.Context, iteratory int32) (_r *NextPreviousReturn, _err error) {
  var _args297 ApplyDbIdx64PreviousArgs
  _args297.Iteratory = iteratory
  var _result299 ApplyDbIdx64PreviousResult
  var _meta298 thrift.ResponseMeta
  _meta298, _err = p.Client_().Call(ctx, "db_idx64_previous", &_args297, &_result299)
  p.SetLastResponseMeta_(_meta298)
  if _err != nil {
    return
  }
  if _ret300 := _result299.GetSuccess(); _ret300 != nil {
    return _ret300, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx64FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args301 ApplyDbIdx64FindPrimaryArgs
  _args301.Code = code
  _args301.Scope = scope
  _args301.Table = table
  _args301.Primary = primary
  var _result303 ApplyDbIdx64FindPrimaryResult
  var _meta302 thrift.ResponseMeta
  _meta302, _err = p.Client_().Call(ctx, "db_idx64_find_primary", &_args301, &_result303)
  p.SetLastResponseMeta_(_meta302)
  if _err != nil {
    return
  }
  if _ret304 := _result303.GetSuccess(); _ret304 != nil {
    return _ret304, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx64FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64) (_r *FindSecondaryReturn, _err error) {
  var _args305 ApplyDbIdx64FindSecondaryArgs
  _args305.Code = code
  _args305.Scope = scope
  _args305.Table = table
  _args305.Secondary = secondary
  var _result307 ApplyDbIdx64FindSecondaryResult
  var _meta306 thrift.ResponseMeta
  _meta306, _err = p.Client_().Call(ctx, "db_idx64_find_secondary", &_args305, &_result307)
  p.SetLastResponseMeta_(_meta306)
  if _err != nil {
    return
  }
  if _ret308 := _result307.GetSuccess(); _ret308 != nil {
    return _ret308, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args309 ApplyDbIdx64LowerboundArgs
  _args309.Code = code
  _args309.Scope = scope
  _args309.Table = table
  _args309.Secondary = secondary
  _args309.Primary = primary
  var _result311 ApplyDbIdx64LowerboundResult
  var _meta310 thrift.ResponseMeta
  _meta310, _err = p.Client_().Call(ctx, "db_idx64_lowerbound", &_args309, &_result311)
  p.SetLastResponseMeta_(_meta310)
  if _err != nil {
    return
  }
  if _ret312 := _result311.GetSuccess(); _ret312 != nil {
    return _ret312, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx64Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary *Uint64, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args313 ApplyDbIdx64UpperboundArgs
  _args313.Code = code
  _args313.Scope = scope
  _args313.Table = table
  _args313.Secondary = secondary
  _args313.Primary = primary
  var _result315 ApplyDbIdx64UpperboundResult
  var _meta314 thrift.ResponseMeta
  _meta314, _err = p.Client_().Call(ctx, "db_idx64_upperbound", &_args313, &_result315)
  p.SetLastResponseMeta_(_meta314)
  if _err != nil {
    return
  }
  if _ret316 := _result315.GetSuccess(); _ret316 != nil {
    return _ret316, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx64_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx64End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args317 ApplyDbIdx64EndArgs
  _args317.Code = code
  _args317.Scope = scope
  _args317.Table = table
  var _result319 ApplyDbIdx64EndResult
  var _meta318 thrift.ResponseMeta
  _meta318, _err = p.Client_().Call(ctx, "db_idx64_end", &_args317, &_result319)
  p.SetLastResponseMeta_(_meta318)
  if _err != nil {
    return
  }
  return _result319.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdx128Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args320 ApplyDbIdx128StoreArgs
  _args320.Scope = scope
  _args320.Table = table
  _args320.Payer = payer
  _args320.ID = id
  _args320.Secondary = secondary
  var _result322 ApplyDbIdx128StoreResult
  var _meta321 thrift.ResponseMeta
  _meta321, _err = p.Client_().Call(ctx, "db_idx128_store", &_args320, &_result322)
  p.SetLastResponseMeta_(_meta321)
  if _err != nil {
    return
  }
  return _result322.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdx128Update(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args323 ApplyDbIdx128UpdateArgs
  _args323.Iterator = iterator
  _args323.Payer = payer
  _args323.Secondary = secondary
  var _result325 ApplyDbIdx128UpdateResult
  var _meta324 thrift.ResponseMeta
  _meta324, _err = p.Client_().Call(ctx, "db_idx128_update", &_args323, &_result325)
  p.SetLastResponseMeta_(_meta324)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Remove(ctx context.Context, iterator int32) (_err error) {
  var _args326 ApplyDbIdx128RemoveArgs
  _args326.Iterator = iterator
  var _result328 ApplyDbIdx128RemoveResult
  var _meta327 thrift.ResponseMeta
  _meta327, _err = p.Client_().Call(ctx, "db_idx128_remove", &_args326, &_result328)
  p.SetLastResponseMeta_(_meta327)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args329 ApplyDbIdx128NextArgs
  _args329.Iterator = iterator
  var _result331 ApplyDbIdx128NextResult
  var _meta330 thrift.ResponseMeta
  _meta330, _err = p.Client_().Call(ctx, "db_idx128_next", &_args329, &_result331)
  p.SetLastResponseMeta_(_meta330)
  if _err != nil {
    return
  }
  if _ret332 := _result331.GetSuccess(); _ret332 != nil {
    return _ret332, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx128Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args333 ApplyDbIdx128PreviousArgs
  _args333.Iterator = iterator
  var _result335 ApplyDbIdx128PreviousResult
  var _meta334 thrift.ResponseMeta
  _meta334, _err = p.Client_().Call(ctx, "db_idx128_previous", &_args333, &_result335)
  p.SetLastResponseMeta_(_meta334)
  if _err != nil {
    return
  }
  if _ret336 := _result335.GetSuccess(); _ret336 != nil {
    return _ret336, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx128FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args337 ApplyDbIdx128FindPrimaryArgs
  _args337.Code = code
  _args337.Scope = scope
  _args337.Table = table
  _args337.Primary = primary
  var _result339 ApplyDbIdx128FindPrimaryResult
  var _meta338 thrift.ResponseMeta
  _meta338, _err = p.Client_().Call(ctx, "db_idx128_find_primary", &_args337, &_result339)
  p.SetLastResponseMeta_(_meta338)
  if _err != nil {
    return
  }
  if _ret340 := _result339.GetSuccess(); _ret340 != nil {
    return _ret340, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdx128FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args341 ApplyDbIdx128FindSecondaryArgs
  _args341.Code = code
  _args341.Scope = scope
  _args341.Table = table
  _args341.Secondary = secondary
  var _result343 ApplyDbIdx128FindSecondaryResult
  var _meta342 thrift.ResponseMeta
  _meta342, _err = p.Client_().Call(ctx, "db_idx128_find_secondary", &_args341, &_result343)
  p.SetLastResponseMeta_(_meta342)
  if _err != nil {
    return
  }
  if _ret344 := _result343.GetSuccess(); _ret344 != nil {
    return _ret344, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args345 ApplyDbIdx128LowerboundArgs
  _args345.Code = code
  _args345.Scope = scope
  _args345.Table = table
  _args345.Secondary = secondary
  _args345.Primary = primary
  var _result347 ApplyDbIdx128LowerboundResult
  var _meta346 thrift.ResponseMeta
  _meta346, _err = p.Client_().Call(ctx, "db_idx128_lowerbound", &_args345, &_result347)
  p.SetLastResponseMeta_(_meta346)
  if _err != nil {
    return
  }
  if _ret348 := _result347.GetSuccess(); _ret348 != nil {
    return _ret348, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdx128Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args349 ApplyDbIdx128UpperboundArgs
  _args349.Code = code
  _args349.Scope = scope
  _args349.Table = table
  _args349.Secondary = secondary
  _args349.Primary = primary
  var _result351 ApplyDbIdx128UpperboundResult
  var _meta350 thrift.ResponseMeta
  _meta350, _err = p.Client_().Call(ctx, "db_idx128_upperbound", &_args349, &_result351)
  p.SetLastResponseMeta_(_meta350)
  if _err != nil {
    return
  }
  if _ret352 := _result351.GetSuccess(); _ret352 != nil {
    return _ret352, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx128_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx128End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args353 ApplyDbIdx128EndArgs
  _args353.Code = code
  _args353.Scope = scope
  _args353.Table = table
  var _result355 ApplyDbIdx128EndResult
  var _meta354 thrift.ResponseMeta
  _meta354, _err = p.Client_().Call(ctx, "db_idx128_end", &_args353, &_result355)
  p.SetLastResponseMeta_(_meta354)
  if _err != nil {
    return
  }
  return _result355.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
func (p *ApplyClient) DbIdx256Store(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, data []byte) (_r int32, _err error) {
  var _args356 ApplyDbIdx256StoreArgs
  _args356.Scope = scope
  _args356.Table = table
  _args356.Payer = payer
  _args356.ID = id
  _args356.Data = data
  var _result358 ApplyDbIdx256StoreResult
  var _meta357 thrift.ResponseMeta
  _meta357, _err = p.Client_().Call(ctx, "db_idx256_store", &_args356, &_result358)
  p.SetLastResponseMeta_(_meta357)
  if _err != nil {
    return
  }
  return _result358.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Data
func (p *ApplyClient) DbIdx256Update(ctx context.Context, iterator int32, payer *Uint64, data []byte) (_err error) {
  var _args359 ApplyDbIdx256UpdateArgs
  _args359.Iterator = iterator
  _args359.Payer = payer
  _args359.Data = data
  var _result361 ApplyDbIdx256UpdateResult
  var _meta360 thrift.ResponseMeta
  _meta360, _err = p.Client_().Call(ctx, "db_idx256_update", &_args359, &_result361)
  p.SetLastResponseMeta_(_meta360)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Remove(ctx context.Context, iterator int32) (_err error) {
  var _args362 ApplyDbIdx256RemoveArgs
  _args362.Iterator = iterator
  var _result364 ApplyDbIdx256RemoveResult
  var _meta363 thrift.ResponseMeta
  _meta363, _err = p.Client_().Call(ctx, "db_idx256_remove", &_args362, &_result364)
  p.SetLastResponseMeta_(_meta363)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Next(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args365 ApplyDbIdx256NextArgs
  _args365.Iterator = iterator
  var _result367 ApplyDbIdx256NextResult
  var _meta366 thrift.ResponseMeta
  _meta366, _err = p.Client_().Call(ctx, "db_idx256_next", &_args365, &_result367)
  p.SetLastResponseMeta_(_meta366)
  if _err != nil {
    return
  }
  if _ret368 := _result367.GetSuccess(); _ret368 != nil {
    return _ret368, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdx256Previous(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args369 ApplyDbIdx256PreviousArgs
  _args369.Iterator = iterator
  var _result371 ApplyDbIdx256PreviousResult
  var _meta370 thrift.ResponseMeta
  _meta370, _err = p.Client_().Call(ctx, "db_idx256_previous", &_args369, &_result371)
  p.SetLastResponseMeta_(_meta370)
  if _err != nil {
    return
  }
  if _ret372 := _result371.GetSuccess(); _ret372 != nil {
    return _ret372, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdx256FindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args373 ApplyDbIdx256FindPrimaryArgs
  _args373.Code = code
  _args373.Scope = scope
  _args373.Table = table
  _args373.Primary = primary
  var _result375 ApplyDbIdx256FindPrimaryResult
  var _meta374 thrift.ResponseMeta
  _meta374, _err = p.Client_().Call(ctx, "db_idx256_find_primary", &_args373, &_result375)
  p.SetLastResponseMeta_(_meta374)
  if _err != nil {
    return
  }
  if _ret376 := _result375.GetSuccess(); _ret376 != nil {
    return _ret376, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
func (p *ApplyClient) DbIdx256FindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte) (_r *FindSecondaryReturn, _err error) {
  var _args377 ApplyDbIdx256FindSecondaryArgs
  _args377.Code = code
  _args377.Scope = scope
  _args377.Table = table
  _args377.Data = data
  var _result379 ApplyDbIdx256FindSecondaryResult
  var _meta378 thrift.ResponseMeta
  _meta378, _err = p.Client_().Call(ctx, "db_idx256_find_secondary", &_args377, &_result379)
  p.SetLastResponseMeta_(_meta378)
  if _err != nil {
    return
  }
  if _ret380 := _result379.GetSuccess(); _ret380 != nil {
    return _ret380, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Lowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args381 ApplyDbIdx256LowerboundArgs
  _args381.Code = code
  _args381.Scope = scope
  _args381.Table = table
  _args381.Data = data
  _args381.Primary = primary
  var _result383 ApplyDbIdx256LowerboundResult
  var _meta382 thrift.ResponseMeta
  _meta382, _err = p.Client_().Call(ctx, "db_idx256_lowerbound", &_args381, &_result383)
  p.SetLastResponseMeta_(_meta382)
  if _err != nil {
    return
  }
  if _ret384 := _result383.GetSuccess(); _ret384 != nil {
    return _ret384, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
func (p *ApplyClient) DbIdx256Upperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, data []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args385 ApplyDbIdx256UpperboundArgs
  _args385.Code = code
  _args385.Scope = scope
  _args385.Table = table
  _args385.Data = data
  _args385.Primary = primary
  var _result387 ApplyDbIdx256UpperboundResult
  var _meta386 thrift.ResponseMeta
  _meta386, _err = p.Client_().Call(ctx, "db_idx256_upperbound", &_args385, &_result387)
  p.SetLastResponseMeta_(_meta386)
  if _err != nil {
    return
  }
  if _ret388 := _result387.GetSuccess(); _ret388 != nil {
    return _ret388, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx256_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdx256End(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args389 ApplyDbIdx256EndArgs
  _args389.Code = code
  _args389.Scope = scope
  _args389.Table = table
  var _result391 ApplyDbIdx256EndResult
  var _meta390 thrift.ResponseMeta
  _meta390, _err = p.Client_().Call(ctx, "db_idx256_end", &_args389, &_result391)
  p.SetLastResponseMeta_(_meta390)
  if _err != nil {
    return
  }
  return _result391.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args392 ApplyDbIdxDoubleStoreArgs
  _args392.Scope = scope
  _args392.Table = table
  _args392.Payer = payer
  _args392.ID = id
  _args392.Secondary = secondary
  var _result394 ApplyDbIdxDoubleStoreResult
  var _meta393 thrift.ResponseMeta
  _meta393, _err = p.Client_().Call(ctx, "db_idx_double_store", &_args392, &_result394)
  p.SetLastResponseMeta_(_meta393)
  if _err != nil {
    return
  }
  return _result394.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args395 ApplyDbIdxDoubleUpdateArgs
  _args395.Iterator = iterator
  _args395.Payer = payer
  _args395.Secondary = secondary
  var _result397 ApplyDbIdxDoubleUpdateResult
  var _meta396 thrift.ResponseMeta
  _meta396, _err = p.Client_().Call(ctx, "db_idx_double_update", &_args395, &_result397)
  p.SetLastResponseMeta_(_meta396)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args398 ApplyDbIdxDoubleRemoveArgs
  _args398.Iterator = iterator
  var _result400 ApplyDbIdxDoubleRemoveResult
  var _meta399 thrift.ResponseMeta
  _meta399, _err = p.Client_().Call(ctx, "db_idx_double_remove", &_args398, &_result400)
  p.SetLastResponseMeta_(_meta399)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args401 ApplyDbIdxDoubleNextArgs
  _args401.Iterator = iterator
  var _result403 ApplyDbIdxDoubleNextResult
  var _meta402 thrift.ResponseMeta
  _meta402, _err = p.Client_().Call(ctx, "db_idx_double_next", &_args401, &_result403)
  p.SetLastResponseMeta_(_meta402)
  if _err != nil {
    return
  }
  if _ret404 := _result403.GetSuccess(); _ret404 != nil {
    return _ret404, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args405 ApplyDbIdxDoublePreviousArgs
  _args405.Iterator = iterator
  var _result407 ApplyDbIdxDoublePreviousResult
  var _meta406 thrift.ResponseMeta
  _meta406, _err = p.Client_().Call(ctx, "db_idx_double_previous", &_args405, &_result407)
  p.SetLastResponseMeta_(_meta406)
  if _err != nil {
    return
  }
  if _ret408 := _result407.GetSuccess(); _ret408 != nil {
    return _ret408, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args409 ApplyDbIdxDoubleFindPrimaryArgs
  _args409.Code = code
  _args409.Scope = scope
  _args409.Table = table
  _args409.Primary = primary
  var _result411 ApplyDbIdxDoubleFindPrimaryResult
  var _meta410 thrift.ResponseMeta
  _meta410, _err = p.Client_().Call(ctx, "db_idx_double_find_primary", &_args409, &_result411)
  p.SetLastResponseMeta_(_meta410)
  if _err != nil {
    return
  }
  if _ret412 := _result411.GetSuccess(); _ret412 != nil {
    return _ret412, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args413 ApplyDbIdxDoubleFindSecondaryArgs
  _args413.Code = code
  _args413.Scope = scope
  _args413.Table = table
  _args413.Secondary = secondary
  var _result415 ApplyDbIdxDoubleFindSecondaryResult
  var _meta414 thrift.ResponseMeta
  _meta414, _err = p.Client_().Call(ctx, "db_idx_double_find_secondary", &_args413, &_result415)
  p.SetLastResponseMeta_(_meta414)
  if _err != nil {
    return
  }
  if _ret416 := _result415.GetSuccess(); _ret416 != nil {
    return _ret416, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args417 ApplyDbIdxDoubleLowerboundArgs
  _args417.Code = code
  _args417.Scope = scope
  _args417.Table = table
  _args417.Secondary = secondary
  _args417.Primary = primary
  var _result419 ApplyDbIdxDoubleLowerboundResult
  var _meta418 thrift.ResponseMeta
  _meta418, _err = p.Client_().Call(ctx, "db_idx_double_lowerbound", &_args417, &_result419)
  p.SetLastResponseMeta_(_meta418)
  if _err != nil {
    return
  }
  if _ret420 := _result419.GetSuccess(); _ret420 != nil {
    return _ret420, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args421 ApplyDbIdxDoubleUpperboundArgs
  _args421.Code = code
  _args421.Scope = scope
  _args421.Table = table
  _args421.Secondary = secondary
  _args421.Primary = primary
  var _result423 ApplyDbIdxDoubleUpperboundResult
  var _meta422 thrift.ResponseMeta
  _meta422, _err = p.Client_().Call(ctx, "db_idx_double_upperbound", &_args421, &_result423)
  p.SetLastResponseMeta_(_meta422)
  if _err != nil {
    return
  }
  if _ret424 := _result423.GetSuccess(); _ret424 != nil {
    return _ret424, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args425 ApplyDbIdxDoubleEndArgs
  _args425.Code = code
  _args425.Scope = scope
  _args425.Table = table
  var _result427 ApplyDbIdxDoubleEndResult
  var _meta426 thrift.ResponseMeta
  _meta426, _err = p.Client_().Call(ctx, "db_idx_double_end", &_args425, &_result427)
  p.SetLastResponseMeta_(_meta426)
  if _err != nil {
    return
  }
  return _result427.GetSuccess(), nil
}

// Parameters:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleStore(ctx context.Context, scope *Uint64, table *Uint64, payer *Uint64, id *Uint64, secondary []byte) (_r int32, _err error) {
  var _args428 ApplyDbIdxLongDoubleStoreArgs
  _args428.Scope = scope
  _args428.Table = table
  _args428.Payer = payer
  _args428.ID = id
  _args428.Secondary = secondary
  var _result430 ApplyDbIdxLongDoubleStoreResult
  var _meta429 thrift.ResponseMeta
  _meta429, _err = p.Client_().Call(ctx, "db_idx_long_double_store", &_args428, &_result430)
  p.SetLastResponseMeta_(_meta429)
  if _err != nil {
    return
  }
  return _result430.GetSuccess(), nil
}

// Parameters:
//  - Iterator
//  - Payer
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleUpdate(ctx context.Context, iterator int32, payer *Uint64, secondary []byte) (_err error) {
  var _args431 ApplyDbIdxLongDoubleUpdateArgs
  _args431.Iterator = iterator
  _args431.Payer = payer
  _args431.Secondary = secondary
  var _result433 ApplyDbIdxLongDoubleUpdateResult
  var _meta432 thrift.ResponseMeta
  _meta432, _err = p.Client_().Call(ctx, "db_idx_long_double_update", &_args431, &_result433)
  p.SetLastResponseMeta_(_meta432)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleRemove(ctx context.Context, iterator int32) (_err error) {
  var _args434 ApplyDbIdxLongDoubleRemoveArgs
  _args434.Iterator = iterator
  var _result436 ApplyDbIdxLongDoubleRemoveResult
  var _meta435 thrift.ResponseMeta
  _meta435, _err = p.Client_().Call(ctx, "db_idx_long_double_remove", &_args434, &_result436)
  p.SetLastResponseMeta_(_meta435)
  if _err != nil {
    return
  }
  return nil
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoubleNext(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args437 ApplyDbIdxLongDoubleNextArgs
  _args437.Iterator = iterator
  var _result439 ApplyDbIdxLongDoubleNextResult
  var _meta438 thrift.ResponseMeta
  _meta438, _err = p.Client_().Call(ctx, "db_idx_long_double_next", &_args437, &_result439)
  p.SetLastResponseMeta_(_meta438)
  if _err != nil {
    return
  }
  if _ret440 := _result439.GetSuccess(); _ret440 != nil {
    return _ret440, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_next failed: unknown result")
}

// Parameters:
//  - Iterator
func (p *ApplyClient) DbIdxLongDoublePrevious(ctx context.Context, iterator int32) (_r *NextPreviousReturn, _err error) {
  var _args441 ApplyDbIdxLongDoublePreviousArgs
  _args441.Iterator = iterator
  var _result443 ApplyDbIdxLongDoublePreviousResult
  var _meta442 thrift.ResponseMeta
  _meta442, _err = p.Client_().Call(ctx, "db_idx_long_double_previous", &_args441, &_result443)
  p.SetLastResponseMeta_(_meta442)
  if _err != nil {
    return
  }
  if _ret444 := _result443.GetSuccess(); _ret444 != nil {
    return _ret444, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_previous failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleFindPrimary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, primary *Uint64) (_r *FindPrimaryReturn, _err error) {
  var _args445 ApplyDbIdxLongDoubleFindPrimaryArgs
  _args445.Code = code
  _args445.Scope = scope
  _args445.Table = table
  _args445.Primary = primary
  var _result447 ApplyDbIdxLongDoubleFindPrimaryResult
  var _meta446 thrift.ResponseMeta
  _meta446, _err = p.Client_().Call(ctx, "db_idx_long_double_find_primary", &_args445, &_result447)
  p.SetLastResponseMeta_(_meta446)
  if _err != nil {
    return
  }
  if _ret448 := _result447.GetSuccess(); _ret448 != nil {
    return _ret448, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_primary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
func (p *ApplyClient) DbIdxLongDoubleFindSecondary(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte) (_r *FindSecondaryReturn, _err error) {
  var _args449 ApplyDbIdxLongDoubleFindSecondaryArgs
  _args449.Code = code
  _args449.Scope = scope
  _args449.Table = table
  _args449.Secondary = secondary
  var _result451 ApplyDbIdxLongDoubleFindSecondaryResult
  var _meta450 thrift.ResponseMeta
  _meta450, _err = p.Client_().Call(ctx, "db_idx_long_double_find_secondary", &_args449, &_result451)
  p.SetLastResponseMeta_(_meta450)
  if _err != nil {
    return
  }
  if _ret452 := _result451.GetSuccess(); _ret452 != nil {
    return _ret452, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_find_secondary failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleLowerbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args453 ApplyDbIdxLongDoubleLowerboundArgs
  _args453.Code = code
  _args453.Scope = scope
  _args453.Table = table
  _args453.Secondary = secondary
  _args453.Primary = primary
  var _result455 ApplyDbIdxLongDoubleLowerboundResult
  var _meta454 thrift.ResponseMeta
  _meta454, _err = p.Client_().Call(ctx, "db_idx_long_double_lowerbound", &_args453, &_result455)
  p.SetLastResponseMeta_(_meta454)
  if _err != nil {
    return
  }
  if _ret456 := _result455.GetSuccess(); _ret456 != nil {
    return _ret456, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_lowerbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
func (p *ApplyClient) DbIdxLongDoubleUpperbound(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64, secondary []byte, primary *Uint64) (_r *LowerBoundUpperBoundReturn, _err error) {
  var _args457 ApplyDbIdxLongDoubleUpperboundArgs
  _args457.Code = code
  _args457.Scope = scope
  _args457.Table = table
  _args457.Secondary = secondary
  _args457.Primary = primary
  var _result459 ApplyDbIdxLongDoubleUpperboundResult
  var _meta458 thrift.ResponseMeta
  _meta458, _err = p.Client_().Call(ctx, "db_idx_long_double_upperbound", &_args457, &_result459)
  p.SetLastResponseMeta_(_meta458)
  if _err != nil {
    return
  }
  if _ret460 := _result459.GetSuccess(); _ret460 != nil {
    return _ret460, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "db_idx_long_double_upperbound failed: unknown result")
}

// Parameters:
//  - Code
//  - Scope
//  - Table
func (p *ApplyClient) DbIdxLongDoubleEnd(ctx context.Context, code *Uint64, scope *Uint64, table *Uint64) (_r int32, _err error) {
  var _args461 ApplyDbIdxLongDoubleEndArgs
  _args461.Code = code
  _args461.Scope = scope
  _args461.Table = table
  var _result463 ApplyDbIdxLongDoubleEndResult
  var _meta462 thrift.ResponseMeta
  _meta462, _err = p.Client_().Call(ctx, "db_idx_long_double_end", &_args461, &_result463)
  p.SetLastResponseMeta_(_meta462)
  if _err != nil {
    return
  }
  return _result463.GetSuccess(), nil
}

type ApplyProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler Apply
}

func (p *ApplyProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ApplyProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ApplyProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewApplyProcessor(handler Apply) *ApplyProcessor {

  self464 := &ApplyProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self464.processorMap["end_apply"] = &applyProcessorEndApply{handler:handler}
  self464.processorMap["prints"] = &applyProcessorPrints{handler:handler}
  self464.processorMap["prints_l"] = &applyProcessorPrintsL{handler:handler}
  self464.processorMap["printi"] = &applyProcessorPrinti{handler:handler}
  self464.processorMap["printui"] = &applyProcessorPrintui{handler:handler}
  self464.processorMap["printi128"] = &applyProcessorPrinti128{handler:handler}
  self464.processorMap["printui128"] = &applyProcessorPrintui128{handler:handler}
  self464.processorMap["printsf"] = &applyProcessorPrintsf{handler:handler}
  self464.processorMap["printdf"] = &applyProcessorPrintdf{handler:handler}
  self464.processorMap["printqf"] = &applyProcessorPrintqf{handler:handler}
  self464.processorMap["printn"] = &applyProcessorPrintn{handler:handler}
  self464.processorMap["printhex"] = &applyProcessorPrinthex{handler:handler}
  self464.processorMap["action_data_size"] = &applyProcessorActionDataSize{handler:handler}
  self464.processorMap["read_action_data"] = &applyProcessorReadActionData{handler:handler}
  self464.processorMap["require_recipient"] = &applyProcessorRequireRecipient{handler:handler}
  self464.processorMap["require_auth"] = &applyProcessorRequireAuth{handler:handler}
  self464.processorMap["has_auth"] = &applyProcessorHasAuth{handler:handler}
  self464.processorMap["require_auth2"] = &applyProcessorRequireAuth2{handler:handler}
  self464.processorMap["is_account"] = &applyProcessorIsAccount{handler:handler}
  self464.processorMap["send_inline"] = &applyProcessorSendInline{handler:handler}
  self464.processorMap["send_context_free_inline"] = &applyProcessorSendContextFreeInline{handler:handler}
  self464.processorMap["publication_time"] = &applyProcessorPublicationTime{handler:handler}
  self464.processorMap["current_receiver"] = &applyProcessorCurrentReceiver{handler:handler}
  self464.processorMap["eosio_assert"] = &applyProcessorEosioAssert{handler:handler}
  self464.processorMap["eosio_assert_message"] = &applyProcessorEosioAssertMessage{handler:handler}
  self464.processorMap["eosio_assert_code"] = &applyProcessorEosioAssertCode{handler:handler}
  self464.processorMap["eosio_exit"] = &applyProcessorEosioExit{handler:handler}
  self464.processorMap["current_time"] = &applyProcessorCurrentTime{handler:handler}
  self464.processorMap["is_feature_activated"] = &applyProcessorIsFeatureActivated{handler:handler}
  self464.processorMap["get_sender"] = &applyProcessorGetSender{handler:handler}
  self464.processorMap["assert_sha256"] = &applyProcessorAssertSha256{handler:handler}
  self464.processorMap["assert_sha1"] = &applyProcessorAssertSha1{handler:handler}
  self464.processorMap["assert_sha512"] = &applyProcessorAssertSha512{handler:handler}
  self464.processorMap["assert_ripemd160"] = &applyProcessorAssertRipemd160{handler:handler}
  self464.processorMap["sha256"] = &applyProcessorSha256{handler:handler}
  self464.processorMap["sha1"] = &applyProcessorSha1{handler:handler}
  self464.processorMap["sha512"] = &applyProcessorSha512{handler:handler}
  self464.processorMap["ripemd160"] = &applyProcessorRipemd160{handler:handler}
  self464.processorMap["recover_key"] = &applyProcessorRecoverKey{handler:handler}
  self464.processorMap["assert_recover_key"] = &applyProcessorAssertRecoverKey{handler:handler}
  self464.processorMap["send_deferred"] = &applyProcessorSendDeferred{handler:handler}
  self464.processorMap["cancel_deferred"] = &applyProcessorCancelDeferred{handler:handler}
  self464.processorMap["read_transaction"] = &applyProcessorReadTransaction{handler:handler}
  self464.processorMap["transaction_size"] = &applyProcessorTransactionSize{handler:handler}
  self464.processorMap["tapos_block_num"] = &applyProcessorTaposBlockNum{handler:handler}
  self464.processorMap["tapos_block_prefix"] = &applyProcessorTaposBlockPrefix{handler:handler}
  self464.processorMap["expiration"] = &applyProcessorExpiration{handler:handler}
  self464.processorMap["get_action"] = &applyProcessorGetAction{handler:handler}
  self464.processorMap["get_context_free_data"] = &applyProcessorGetContextFreeData{handler:handler}
  self464.processorMap["db_store_i64"] = &applyProcessorDbStoreI64{handler:handler}
  self464.processorMap["db_update_i64"] = &applyProcessorDbUpdateI64{handler:handler}
  self464.processorMap["db_remove_i64"] = &applyProcessorDbRemoveI64{handler:handler}
  self464.processorMap["db_get_i64"] = &applyProcessorDbGetI64{handler:handler}
  self464.processorMap["db_next_i64"] = &applyProcessorDbNextI64{handler:handler}
  self464.processorMap["db_previous_i64"] = &applyProcessorDbPreviousI64{handler:handler}
  self464.processorMap["db_find_i64"] = &applyProcessorDbFindI64{handler:handler}
  self464.processorMap["db_lowerbound_i64"] = &applyProcessorDbLowerboundI64{handler:handler}
  self464.processorMap["db_upperbound_i64"] = &applyProcessorDbUpperboundI64{handler:handler}
  self464.processorMap["db_end_i64"] = &applyProcessorDbEndI64{handler:handler}
  self464.processorMap["db_idx64_store"] = &applyProcessorDbIdx64Store{handler:handler}
  self464.processorMap["db_idx64_update"] = &applyProcessorDbIdx64Update{handler:handler}
  self464.processorMap["db_idx64_remove"] = &applyProcessorDbIdx64Remove{handler:handler}
  self464.processorMap["db_idx64_next"] = &applyProcessorDbIdx64Next{handler:handler}
  self464.processorMap["db_idx64_previous"] = &applyProcessorDbIdx64Previous{handler:handler}
  self464.processorMap["db_idx64_find_primary"] = &applyProcessorDbIdx64FindPrimary{handler:handler}
  self464.processorMap["db_idx64_find_secondary"] = &applyProcessorDbIdx64FindSecondary{handler:handler}
  self464.processorMap["db_idx64_lowerbound"] = &applyProcessorDbIdx64Lowerbound{handler:handler}
  self464.processorMap["db_idx64_upperbound"] = &applyProcessorDbIdx64Upperbound{handler:handler}
  self464.processorMap["db_idx64_end"] = &applyProcessorDbIdx64End{handler:handler}
  self464.processorMap["db_idx128_store"] = &applyProcessorDbIdx128Store{handler:handler}
  self464.processorMap["db_idx128_update"] = &applyProcessorDbIdx128Update{handler:handler}
  self464.processorMap["db_idx128_remove"] = &applyProcessorDbIdx128Remove{handler:handler}
  self464.processorMap["db_idx128_next"] = &applyProcessorDbIdx128Next{handler:handler}
  self464.processorMap["db_idx128_previous"] = &applyProcessorDbIdx128Previous{handler:handler}
  self464.processorMap["db_idx128_find_primary"] = &applyProcessorDbIdx128FindPrimary{handler:handler}
  self464.processorMap["db_idx128_find_secondary"] = &applyProcessorDbIdx128FindSecondary{handler:handler}
  self464.processorMap["db_idx128_lowerbound"] = &applyProcessorDbIdx128Lowerbound{handler:handler}
  self464.processorMap["db_idx128_upperbound"] = &applyProcessorDbIdx128Upperbound{handler:handler}
  self464.processorMap["db_idx128_end"] = &applyProcessorDbIdx128End{handler:handler}
  self464.processorMap["db_idx256_store"] = &applyProcessorDbIdx256Store{handler:handler}
  self464.processorMap["db_idx256_update"] = &applyProcessorDbIdx256Update{handler:handler}
  self464.processorMap["db_idx256_remove"] = &applyProcessorDbIdx256Remove{handler:handler}
  self464.processorMap["db_idx256_next"] = &applyProcessorDbIdx256Next{handler:handler}
  self464.processorMap["db_idx256_previous"] = &applyProcessorDbIdx256Previous{handler:handler}
  self464.processorMap["db_idx256_find_primary"] = &applyProcessorDbIdx256FindPrimary{handler:handler}
  self464.processorMap["db_idx256_find_secondary"] = &applyProcessorDbIdx256FindSecondary{handler:handler}
  self464.processorMap["db_idx256_lowerbound"] = &applyProcessorDbIdx256Lowerbound{handler:handler}
  self464.processorMap["db_idx256_upperbound"] = &applyProcessorDbIdx256Upperbound{handler:handler}
  self464.processorMap["db_idx256_end"] = &applyProcessorDbIdx256End{handler:handler}
  self464.processorMap["db_idx_double_store"] = &applyProcessorDbIdxDoubleStore{handler:handler}
  self464.processorMap["db_idx_double_update"] = &applyProcessorDbIdxDoubleUpdate{handler:handler}
  self464.processorMap["db_idx_double_remove"] = &applyProcessorDbIdxDoubleRemove{handler:handler}
  self464.processorMap["db_idx_double_next"] = &applyProcessorDbIdxDoubleNext{handler:handler}
  self464.processorMap["db_idx_double_previous"] = &applyProcessorDbIdxDoublePrevious{handler:handler}
  self464.processorMap["db_idx_double_find_primary"] = &applyProcessorDbIdxDoubleFindPrimary{handler:handler}
  self464.processorMap["db_idx_double_find_secondary"] = &applyProcessorDbIdxDoubleFindSecondary{handler:handler}
  self464.processorMap["db_idx_double_lowerbound"] = &applyProcessorDbIdxDoubleLowerbound{handler:handler}
  self464.processorMap["db_idx_double_upperbound"] = &applyProcessorDbIdxDoubleUpperbound{handler:handler}
  self464.processorMap["db_idx_double_end"] = &applyProcessorDbIdxDoubleEnd{handler:handler}
  self464.processorMap["db_idx_long_double_store"] = &applyProcessorDbIdxLongDoubleStore{handler:handler}
  self464.processorMap["db_idx_long_double_update"] = &applyProcessorDbIdxLongDoubleUpdate{handler:handler}
  self464.processorMap["db_idx_long_double_remove"] = &applyProcessorDbIdxLongDoubleRemove{handler:handler}
  self464.processorMap["db_idx_long_double_next"] = &applyProcessorDbIdxLongDoubleNext{handler:handler}
  self464.processorMap["db_idx_long_double_previous"] = &applyProcessorDbIdxLongDoublePrevious{handler:handler}
  self464.processorMap["db_idx_long_double_find_primary"] = &applyProcessorDbIdxLongDoubleFindPrimary{handler:handler}
  self464.processorMap["db_idx_long_double_find_secondary"] = &applyProcessorDbIdxLongDoubleFindSecondary{handler:handler}
  self464.processorMap["db_idx_long_double_lowerbound"] = &applyProcessorDbIdxLongDoubleLowerbound{handler:handler}
  self464.processorMap["db_idx_long_double_upperbound"] = &applyProcessorDbIdxLongDoubleUpperbound{handler:handler}
  self464.processorMap["db_idx_long_double_end"] = &applyProcessorDbIdxLongDoubleEnd{handler:handler}
return self464
}

func (p *ApplyProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x465 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x465.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x465

}

type applyProcessorEndApply struct {
  handler Apply
}

func (p *applyProcessorEndApply) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEndApplyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEndApplyResult{}
  var retval int32
  if retval, err2 = p.handler.EndApply(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing end_apply: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "end_apply", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "end_apply", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrints struct {
  handler Apply
}

func (p *applyProcessorPrints) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsResult{}
  if err2 = p.handler.Prints(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsL struct {
  handler Apply
}

func (p *applyProcessorPrintsL) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsLArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsLResult{}
  if err2 = p.handler.PrintsL(ctx, args.Cstr); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prints_l: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "prints_l", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "prints_l", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti struct {
  handler Apply
}

func (p *applyProcessorPrinti) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintiResult{}
  if err2 = p.handler.Printi(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui struct {
  handler Apply
}

func (p *applyProcessorPrintui) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintuiArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintuiResult{}
  if err2 = p.handler.Printui(ctx, args.N); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinti128 struct {
  handler Apply
}

func (p *applyProcessorPrinti128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinti128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinti128Result{}
  if err2 = p.handler.Printi128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printi128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printi128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printi128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintui128 struct {
  handler Apply
}

func (p *applyProcessorPrintui128) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintui128Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintui128Result{}
  if err2 = p.handler.Printui128(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printui128: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printui128", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printui128", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintsf struct {
  handler Apply
}

func (p *applyProcessorPrintsf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintsfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintsfResult{}
  if err2 = p.handler.Printsf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printsf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printsf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printsf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintdf struct {
  handler Apply
}

func (p *applyProcessorPrintdf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintdfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintdfResult{}
  if err2 = p.handler.Printdf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printdf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printdf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printdf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintqf struct {
  handler Apply
}

func (p *applyProcessorPrintqf) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintqfArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintqfResult{}
  if err2 = p.handler.Printqf(ctx, args.Value); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printqf: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printqf", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printqf", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrintn struct {
  handler Apply
}

func (p *applyProcessorPrintn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrintnArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrintnResult{}
  if err2 = p.handler.Printn(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printn: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printn", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printn", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPrinthex struct {
  handler Apply
}

func (p *applyProcessorPrinthex) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPrinthexArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPrinthexResult{}
  if err2 = p.handler.Printhex(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing printhex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "printhex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "printhex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorActionDataSize struct {
  handler Apply
}

func (p *applyProcessorActionDataSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyActionDataSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyActionDataSizeResult{}
  var retval int32
  if retval, err2 = p.handler.ActionDataSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing action_data_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "action_data_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "action_data_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadActionData struct {
  handler Apply
}

func (p *applyProcessorReadActionData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadActionDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadActionDataResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadActionData(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_action_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_action_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_action_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireRecipient struct {
  handler Apply
}

func (p *applyProcessorRequireRecipient) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireRecipientArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireRecipientResult{}
  if err2 = p.handler.RequireRecipient(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_recipient: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_recipient", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_recipient", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth struct {
  handler Apply
}

func (p *applyProcessorRequireAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuthResult{}
  if err2 = p.handler.RequireAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorHasAuth struct {
  handler Apply
}

func (p *applyProcessorHasAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyHasAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyHasAuthResult{}
  var retval bool
  if retval, err2 = p.handler.HasAuth(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing has_auth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "has_auth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "has_auth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRequireAuth2 struct {
  handler Apply
}

func (p *applyProcessorRequireAuth2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRequireAuth2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRequireAuth2Result{}
  if err2 = p.handler.RequireAuth2(ctx, args.Name, args.Permission); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing require_auth2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "require_auth2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "require_auth2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsAccount struct {
  handler Apply
}

func (p *applyProcessorIsAccount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsAccountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsAccountResult{}
  var retval bool
  if retval, err2 = p.handler.IsAccount(ctx, args.Name); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_account: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_account", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_account", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendInline struct {
  handler Apply
}

func (p *applyProcessorSendInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendInlineResult{}
  if err2 = p.handler.SendInline(ctx, args.SerializedAction); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendContextFreeInline struct {
  handler Apply
}

func (p *applyProcessorSendContextFreeInline) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendContextFreeInlineArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendContextFreeInlineResult{}
  if err2 = p.handler.SendContextFreeInline(ctx, args.SerializedData); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_context_free_inline: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_context_free_inline", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorPublicationTime struct {
  handler Apply
}

func (p *applyProcessorPublicationTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyPublicationTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyPublicationTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.PublicationTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing publication_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "publication_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "publication_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentReceiver struct {
  handler Apply
}

func (p *applyProcessorCurrentReceiver) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentReceiverArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentReceiverResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentReceiver(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_receiver: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_receiver", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_receiver", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssert struct {
  handler Apply
}

func (p *applyProcessorEosioAssert) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertResult{}
  if err2 = p.handler.EosioAssert(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertMessage struct {
  handler Apply
}

func (p *applyProcessorEosioAssertMessage) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertMessageArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertMessageResult{}
  if err2 = p.handler.EosioAssertMessage(ctx, args.Test, args.Msg); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_message: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_message", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioAssertCode struct {
  handler Apply
}

func (p *applyProcessorEosioAssertCode) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioAssertCodeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioAssertCodeResult{}
  if err2 = p.handler.EosioAssertCode(ctx, args.Test, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_assert_code: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_assert_code", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorEosioExit struct {
  handler Apply
}

func (p *applyProcessorEosioExit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyEosioExitArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyEosioExitResult{}
  if err2 = p.handler.EosioExit(ctx, args.Code); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing eosio_exit: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "eosio_exit", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCurrentTime struct {
  handler Apply
}

func (p *applyProcessorCurrentTime) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCurrentTimeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCurrentTimeResult{}
  var retval *Uint64
  if retval, err2 = p.handler.CurrentTime(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing current_time: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "current_time", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "current_time", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorIsFeatureActivated struct {
  handler Apply
}

func (p *applyProcessorIsFeatureActivated) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyIsFeatureActivatedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyIsFeatureActivatedResult{}
  var retval bool
  if retval, err2 = p.handler.IsFeatureActivated(ctx, args.FeatureDigest); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_feature_activated: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "is_feature_activated", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetSender struct {
  handler Apply
}

func (p *applyProcessorGetSender) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetSenderArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetSenderResult{}
  var retval *Uint64
  if retval, err2 = p.handler.GetSender(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_sender: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_sender", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_sender", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha256 struct {
  handler Apply
}

func (p *applyProcessorAssertSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha256Result{}
  if err2 = p.handler.AssertSha256(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha1 struct {
  handler Apply
}

func (p *applyProcessorAssertSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha1Result{}
  if err2 = p.handler.AssertSha1(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertSha512 struct {
  handler Apply
}

func (p *applyProcessorAssertSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertSha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertSha512Result{}
  if err2 = p.handler.AssertSha512(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRipemd160 struct {
  handler Apply
}

func (p *applyProcessorAssertRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRipemd160Result{}
  if err2 = p.handler.AssertRipemd160(ctx, args.Data, args.Hash); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha256 struct {
  handler Apply
}

func (p *applyProcessorSha256) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha256Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha256Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha256(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha256: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha256", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha256", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha1 struct {
  handler Apply
}

func (p *applyProcessorSha1) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha1Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha1Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha1(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha1: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha1", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha1", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSha512 struct {
  handler Apply
}

func (p *applyProcessorSha512) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySha512Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySha512Result{}
  var retval []byte
  if retval, err2 = p.handler.Sha512(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sha512: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sha512", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sha512", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRipemd160 struct {
  handler Apply
}

func (p *applyProcessorRipemd160) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRipemd160Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRipemd160Result{}
  var retval []byte
  if retval, err2 = p.handler.Ripemd160(ctx, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ripemd160: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ripemd160", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ripemd160", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorRecoverKey struct {
  handler Apply
}

func (p *applyProcessorRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyRecoverKeyResult{}
  var retval []byte
  if retval, err2 = p.handler.RecoverKey(ctx, args.Digest, args.Sig); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorAssertRecoverKey struct {
  handler Apply
}

func (p *applyProcessorAssertRecoverKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyAssertRecoverKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyAssertRecoverKeyResult{}
  if err2 = p.handler.AssertRecoverKey(ctx, args.Digest, args.Sig, args.Pub); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assert_recover_key: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "assert_recover_key", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorSendDeferred struct {
  handler Apply
}

func (p *applyProcessorSendDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplySendDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplySendDeferredResult{}
  if err2 = p.handler.SendDeferred(ctx, args.SenderID, args.Payer, args.SerializedTransaction, args.ReplaceExisting); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorCancelDeferred struct {
  handler Apply
}

func (p *applyProcessorCancelDeferred) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyCancelDeferredArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyCancelDeferredResult{}
  var retval int32
  if retval, err2 = p.handler.CancelDeferred(ctx, args.SenderID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_deferred: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "cancel_deferred", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorReadTransaction struct {
  handler Apply
}

func (p *applyProcessorReadTransaction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyReadTransactionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyReadTransactionResult{}
  var retval []byte
  if retval, err2 = p.handler.ReadTransaction(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing read_transaction: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "read_transaction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "read_transaction", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTransactionSize struct {
  handler Apply
}

func (p *applyProcessorTransactionSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTransactionSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTransactionSizeResult{}
  var retval int32
  if retval, err2 = p.handler.TransactionSize(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing transaction_size: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "transaction_size", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "transaction_size", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockNum struct {
  handler Apply
}

func (p *applyProcessorTaposBlockNum) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockNumArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockNumResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockNum(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_num: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_num", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorTaposBlockPrefix struct {
  handler Apply
}

func (p *applyProcessorTaposBlockPrefix) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyTaposBlockPrefixArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyTaposBlockPrefixResult{}
  var retval int32
  if retval, err2 = p.handler.TaposBlockPrefix(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tapos_block_prefix: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "tapos_block_prefix", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorExpiration struct {
  handler Apply
}

func (p *applyProcessorExpiration) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyExpirationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyExpirationResult{}
  var retval int64
  if retval, err2 = p.handler.Expiration(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expiration: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expiration", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expiration", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetAction struct {
  handler Apply
}

func (p *applyProcessorGetAction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetActionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetActionResult{}
  var retval []byte
  if retval, err2 = p.handler.GetAction(ctx, args._type, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_action: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_action", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_action", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorGetContextFreeData struct {
  handler Apply
}

func (p *applyProcessorGetContextFreeData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyGetContextFreeDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyGetContextFreeDataResult{}
  var retval []byte
  if retval, err2 = p.handler.GetContextFreeData(ctx, args.Index); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_context_free_data: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "get_context_free_data", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbStoreI64 struct {
  handler Apply
}

func (p *applyProcessorDbStoreI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbStoreI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbStoreI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbStoreI64(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_store_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_store_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpdateI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpdateI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpdateI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpdateI64Result{}
  if err2 = p.handler.DbUpdateI64(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_update_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_update_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbRemoveI64 struct {
  handler Apply
}

func (p *applyProcessorDbRemoveI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbRemoveI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbRemoveI64Result{}
  if err2 = p.handler.DbRemoveI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_remove_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_remove_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbGetI64 struct {
  handler Apply
}

func (p *applyProcessorDbGetI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbGetI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbGetI64Result{}
  var retval []byte
  if retval, err2 = p.handler.DbGetI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_get_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_get_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbNextI64 struct {
  handler Apply
}

func (p *applyProcessorDbNextI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbNextI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbNextI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbNextI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_next_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_next_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbPreviousI64 struct {
  handler Apply
}

func (p *applyProcessorDbPreviousI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbPreviousI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbPreviousI64Result{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbPreviousI64(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_previous_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_previous_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbFindI64 struct {
  handler Apply
}

func (p *applyProcessorDbFindI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbFindI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbFindI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbFindI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_find_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_find_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbLowerboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbLowerboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbLowerboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbLowerboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbLowerboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_lowerbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_lowerbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbUpperboundI64 struct {
  handler Apply
}

func (p *applyProcessorDbUpperboundI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbUpperboundI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbUpperboundI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbUpperboundI64(ctx, args.Code, args.Scope, args.Table, args.ID); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_upperbound_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_upperbound_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbEndI64 struct {
  handler Apply
}

func (p *applyProcessorDbEndI64) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbEndI64Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbEndI64Result{}
  var retval int32
  if retval, err2 = p.handler.DbEndI64(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_end_i64: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_end_i64", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpdateResult{}
  if err2 = p.handler.DbIdx64Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64RemoveResult{}
  if err2 = p.handler.DbIdx64Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx64Previous(ctx, args.Iteratory); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx64FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx64FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx64FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx64Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx64Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx64End struct {
  handler Apply
}

func (p *applyProcessorDbIdx64End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx64EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx64EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx64End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx64_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx64_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpdateResult{}
  if err2 = p.handler.DbIdx128Update(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128RemoveResult{}
  if err2 = p.handler.DbIdx128Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx128Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx128FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx128FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx128FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx128Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx128Upperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx128End struct {
  handler Apply
}

func (p *applyProcessorDbIdx128End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx128EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx128EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx128End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx128_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx128_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Store struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Store) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256StoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256StoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256Store(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Update struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpdateResult{}
  if err2 = p.handler.DbIdx256Update(ctx, args.Iterator, args.Payer, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Remove struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Remove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256RemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256RemoveResult{}
  if err2 = p.handler.DbIdx256Remove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Next struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Next) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256NextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256NextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Next(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Previous struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Previous) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256PreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256PreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdx256Previous(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdx256FindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256FindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdx256FindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256FindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256FindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdx256FindSecondary(ctx, args.Code, args.Scope, args.Table, args.Data); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Lowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Lowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256LowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256LowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Lowerbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256Upperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdx256Upperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256UpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256UpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdx256Upperbound(ctx, args.Code, args.Scope, args.Table, args.Data, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdx256End struct {
  handler Apply
}

func (p *applyProcessorDbIdx256End) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdx256EndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdx256EndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdx256End(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx256_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx256_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpdateResult{}
  if err2 = p.handler.DbIdxDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleRemoveResult{}
  if err2 = p.handler.DbIdxDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleStore struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleStore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleStoreArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleStoreResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleStore(ctx, args.Scope, args.Table, args.Payer, args.ID, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_store: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_store", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpdate struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpdateResult{}
  if err2 = p.handler.DbIdxLongDoubleUpdate(ctx, args.Iterator, args.Payer, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_update: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_update", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleRemove struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleRemoveArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleRemoveResult{}
  if err2 = p.handler.DbIdxLongDoubleRemove(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_remove: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_remove", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleNext struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleNext) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleNextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleNextResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoubleNext(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_next: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_next", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoublePrevious struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoublePrevious) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoublePreviousArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoublePreviousResult{}
  var retval *NextPreviousReturn
  if retval, err2 = p.handler.DbIdxLongDoublePrevious(ctx, args.Iterator); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_previous: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_previous", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindPrimary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindPrimary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindPrimaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindPrimaryResult{}
  var retval *FindPrimaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindPrimary(ctx, args.Code, args.Scope, args.Table, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_primary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_primary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleFindSecondary struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleFindSecondary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleFindSecondaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleFindSecondaryResult{}
  var retval *FindSecondaryReturn
  if retval, err2 = p.handler.DbIdxLongDoubleFindSecondary(ctx, args.Code, args.Scope, args.Table, args.Secondary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_find_secondary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_find_secondary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleLowerbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleLowerbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleLowerboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleLowerboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleLowerbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_lowerbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_lowerbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleUpperbound struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleUpperbound) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleUpperboundArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleUpperboundResult{}
  var retval *LowerBoundUpperBoundReturn
  if retval, err2 = p.handler.DbIdxLongDoubleUpperbound(ctx, args.Code, args.Scope, args.Table, args.Secondary, args.Primary); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_upperbound: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_upperbound", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type applyProcessorDbIdxLongDoubleEnd struct {
  handler Apply
}

func (p *applyProcessorDbIdxLongDoubleEnd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ApplyDbIdxLongDoubleEndArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ApplyDbIdxLongDoubleEndResult{}
  var retval int32
  if retval, err2 = p.handler.DbIdxLongDoubleEnd(ctx, args.Code, args.Scope, args.Table); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing db_idx_long_double_end: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "db_idx_long_double_end", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ApplyEndApplyArgs struct {
}

func NewApplyEndApplyArgs() *ApplyEndApplyArgs {
  return &ApplyEndApplyArgs{}
}

func (p *ApplyEndApplyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyEndApplyResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyEndApplyResult() *ApplyEndApplyResult {
  return &ApplyEndApplyResult{}
}

var ApplyEndApplyResult_Success_DEFAULT int32
func (p *ApplyEndApplyResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyEndApplyResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyEndApplyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyEndApplyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEndApplyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyEndApplyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "end_apply_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEndApplyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyEndApplyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEndApplyResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsArgs struct {
  Cstr string `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsArgs() *ApplyPrintsArgs {
  return &ApplyPrintsArgs{}
}


func (p *ApplyPrintsArgs) GetCstr() string {
  return p.Cstr
}
func (p *ApplyPrintsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Cstr)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsArgs(%+v)", *p)
}

type ApplyPrintsResult struct {
}

func NewApplyPrintsResult() *ApplyPrintsResult {
  return &ApplyPrintsResult{}
}

func (p *ApplyPrintsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsResult(%+v)", *p)
}

// Attributes:
//  - Cstr
type ApplyPrintsLArgs struct {
  Cstr []byte `thrift:"cstr,1" db:"cstr" json:"cstr"`
}

func NewApplyPrintsLArgs() *ApplyPrintsLArgs {
  return &ApplyPrintsLArgs{}
}


func (p *ApplyPrintsLArgs) GetCstr() []byte {
  return p.Cstr
}
func (p *ApplyPrintsLArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cstr = v
}
  return nil
}

func (p *ApplyPrintsLArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cstr", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cstr: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Cstr); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cstr (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cstr: ", p), err) }
  return err
}

func (p *ApplyPrintsLArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLArgs(%+v)", *p)
}

type ApplyPrintsLResult struct {
}

func NewApplyPrintsLResult() *ApplyPrintsLResult {
  return &ApplyPrintsLResult{}
}

func (p *ApplyPrintsLResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsLResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "prints_l_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsLResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsLResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintiArgs struct {
  N int64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintiArgs() *ApplyPrintiArgs {
  return &ApplyPrintiArgs{}
}


func (p *ApplyPrintiArgs) GetN() int64 {
  return p.N
}
func (p *ApplyPrintiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.N = v
}
  return nil
}

func (p *ApplyPrintiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.N)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.n (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiArgs(%+v)", *p)
}

type ApplyPrintiResult struct {
}

func NewApplyPrintiResult() *ApplyPrintiResult {
  return &ApplyPrintiResult{}
}

func (p *ApplyPrintiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintiResult(%+v)", *p)
}

// Attributes:
//  - N
type ApplyPrintuiArgs struct {
  N *Uint64 `thrift:"n,1" db:"n" json:"n"`
}

func NewApplyPrintuiArgs() *ApplyPrintuiArgs {
  return &ApplyPrintuiArgs{}
}

var ApplyPrintuiArgs_N_DEFAULT *Uint64
func (p *ApplyPrintuiArgs) GetN() *Uint64 {
  if !p.IsSetN() {
    return ApplyPrintuiArgs_N_DEFAULT
  }
return p.N
}
func (p *ApplyPrintuiArgs) IsSetN() bool {
  return p.N != nil
}

func (p *ApplyPrintuiArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.N = &Uint64{}
  if err := p.N.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.N), err)
  }
  return nil
}

func (p *ApplyPrintuiArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := p.N.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.N), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ApplyPrintuiArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiArgs(%+v)", *p)
}

type ApplyPrintuiResult struct {
}

func NewApplyPrintuiResult() *ApplyPrintuiResult {
  return &ApplyPrintuiResult{}
}

func (p *ApplyPrintuiResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintuiResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintuiResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintuiResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrinti128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrinti128Args() *ApplyPrinti128Args {
  return &ApplyPrinti128Args{}
}


func (p *ApplyPrinti128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrinti128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrinti128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrinti128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Args(%+v)", *p)
}

type ApplyPrinti128Result struct {
}

func NewApplyPrinti128Result() *ApplyPrinti128Result {
  return &ApplyPrinti128Result{}
}

func (p *ApplyPrinti128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinti128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printi128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinti128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinti128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintui128Args struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintui128Args() *ApplyPrintui128Args {
  return &ApplyPrintui128Args{}
}


func (p *ApplyPrintui128Args) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintui128Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintui128Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintui128Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Args(%+v)", *p)
}

type ApplyPrintui128Result struct {
}

func NewApplyPrintui128Result() *ApplyPrintui128Result {
  return &ApplyPrintui128Result{}
}

func (p *ApplyPrintui128Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintui128Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printui128_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintui128Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintui128Result(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintsfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintsfArgs() *ApplyPrintsfArgs {
  return &ApplyPrintsfArgs{}
}


func (p *ApplyPrintsfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintsfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintsfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintsfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfArgs(%+v)", *p)
}

type ApplyPrintsfResult struct {
}

func NewApplyPrintsfResult() *ApplyPrintsfResult {
  return &ApplyPrintsfResult{}
}

func (p *ApplyPrintsfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintsfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printsf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintsfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintsfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintdfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintdfArgs() *ApplyPrintdfArgs {
  return &ApplyPrintdfArgs{}
}


func (p *ApplyPrintdfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintdfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintdfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintdfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfArgs(%+v)", *p)
}

type ApplyPrintdfResult struct {
}

func NewApplyPrintdfResult() *ApplyPrintdfResult {
  return &ApplyPrintdfResult{}
}

func (p *ApplyPrintdfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintdfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printdf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintdfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintdfResult(%+v)", *p)
}

// Attributes:
//  - Value
type ApplyPrintqfArgs struct {
  Value []byte `thrift:"value,1" db:"value" json:"value"`
}

func NewApplyPrintqfArgs() *ApplyPrintqfArgs {
  return &ApplyPrintqfArgs{}
}


func (p *ApplyPrintqfArgs) GetValue() []byte {
  return p.Value
}
func (p *ApplyPrintqfArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *ApplyPrintqfArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *ApplyPrintqfArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfArgs(%+v)", *p)
}

type ApplyPrintqfResult struct {
}

func NewApplyPrintqfResult() *ApplyPrintqfResult {
  return &ApplyPrintqfResult{}
}

func (p *ApplyPrintqfResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintqfResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printqf_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintqfResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintqfResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyPrintnArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyPrintnArgs() *ApplyPrintnArgs {
  return &ApplyPrintnArgs{}
}

var ApplyPrintnArgs_Name_DEFAULT *Uint64
func (p *ApplyPrintnArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyPrintnArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyPrintnArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyPrintnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyPrintnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyPrintnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnArgs(%+v)", *p)
}

type ApplyPrintnResult struct {
}

func NewApplyPrintnResult() *ApplyPrintnResult {
  return &ApplyPrintnResult{}
}

func (p *ApplyPrintnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrintnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printn_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrintnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrintnResult(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyPrinthexArgs struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyPrinthexArgs() *ApplyPrinthexArgs {
  return &ApplyPrinthexArgs{}
}


func (p *ApplyPrinthexArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyPrinthexArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyPrinthexArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyPrinthexArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexArgs(%+v)", *p)
}

type ApplyPrinthexResult struct {
}

func NewApplyPrinthexResult() *ApplyPrinthexResult {
  return &ApplyPrinthexResult{}
}

func (p *ApplyPrinthexResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPrinthexResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "printhex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPrinthexResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPrinthexResult(%+v)", *p)
}

type ApplyActionDataSizeArgs struct {
}

func NewApplyActionDataSizeArgs() *ApplyActionDataSizeArgs {
  return &ApplyActionDataSizeArgs{}
}

func (p *ApplyActionDataSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyActionDataSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyActionDataSizeResult() *ApplyActionDataSizeResult {
  return &ApplyActionDataSizeResult{}
}

var ApplyActionDataSizeResult_Success_DEFAULT int32
func (p *ApplyActionDataSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyActionDataSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyActionDataSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyActionDataSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyActionDataSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyActionDataSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "action_data_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyActionDataSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyActionDataSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyActionDataSizeResult(%+v)", *p)
}

type ApplyReadActionDataArgs struct {
}

func NewApplyReadActionDataArgs() *ApplyReadActionDataArgs {
  return &ApplyReadActionDataArgs{}
}

func (p *ApplyReadActionDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadActionDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadActionDataResult() *ApplyReadActionDataResult {
  return &ApplyReadActionDataResult{}
}

var ApplyReadActionDataResult_Success_DEFAULT []byte

func (p *ApplyReadActionDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadActionDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadActionDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadActionDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadActionDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_action_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadActionDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadActionDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadActionDataResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireRecipientArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireRecipientArgs() *ApplyRequireRecipientArgs {
  return &ApplyRequireRecipientArgs{}
}

var ApplyRequireRecipientArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireRecipientArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireRecipientArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireRecipientArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireRecipientArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireRecipientArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireRecipientArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientArgs(%+v)", *p)
}

type ApplyRequireRecipientResult struct {
}

func NewApplyRequireRecipientResult() *ApplyRequireRecipientResult {
  return &ApplyRequireRecipientResult{}
}

func (p *ApplyRequireRecipientResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireRecipientResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_recipient_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireRecipientResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireRecipientResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyRequireAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyRequireAuthArgs() *ApplyRequireAuthArgs {
  return &ApplyRequireAuthArgs{}
}

var ApplyRequireAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyRequireAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyRequireAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthArgs(%+v)", *p)
}

type ApplyRequireAuthResult struct {
}

func NewApplyRequireAuthResult() *ApplyRequireAuthResult {
  return &ApplyRequireAuthResult{}
}

func (p *ApplyRequireAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyHasAuthArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyHasAuthArgs() *ApplyHasAuthArgs {
  return &ApplyHasAuthArgs{}
}

var ApplyHasAuthArgs_Name_DEFAULT *Uint64
func (p *ApplyHasAuthArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyHasAuthArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyHasAuthArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyHasAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyHasAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyHasAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyHasAuthResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyHasAuthResult() *ApplyHasAuthResult {
  return &ApplyHasAuthResult{}
}

var ApplyHasAuthResult_Success_DEFAULT bool
func (p *ApplyHasAuthResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyHasAuthResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyHasAuthResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyHasAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyHasAuthResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyHasAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "has_auth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyHasAuthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyHasAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyHasAuthResult(%+v)", *p)
}

// Attributes:
//  - Name
//  - Permission
type ApplyRequireAuth2Args struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
  Permission *Uint64 `thrift:"permission,2" db:"permission" json:"permission"`
}

func NewApplyRequireAuth2Args() *ApplyRequireAuth2Args {
  return &ApplyRequireAuth2Args{}
}

var ApplyRequireAuth2Args_Name_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyRequireAuth2Args_Name_DEFAULT
  }
return p.Name
}
var ApplyRequireAuth2Args_Permission_DEFAULT *Uint64
func (p *ApplyRequireAuth2Args) GetPermission() *Uint64 {
  if !p.IsSetPermission() {
    return ApplyRequireAuth2Args_Permission_DEFAULT
  }
return p.Permission
}
func (p *ApplyRequireAuth2Args) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyRequireAuth2Args) IsSetPermission() bool {
  return p.Permission != nil
}

func (p *ApplyRequireAuth2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Permission = &Uint64{}
  if err := p.Permission.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Permission), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "permission", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:permission: ", p), err) }
  if err := p.Permission.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Permission), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:permission: ", p), err) }
  return err
}

func (p *ApplyRequireAuth2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Args(%+v)", *p)
}

type ApplyRequireAuth2Result struct {
}

func NewApplyRequireAuth2Result() *ApplyRequireAuth2Result {
  return &ApplyRequireAuth2Result{}
}

func (p *ApplyRequireAuth2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRequireAuth2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "require_auth2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRequireAuth2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRequireAuth2Result(%+v)", *p)
}

// Attributes:
//  - Name
type ApplyIsAccountArgs struct {
  Name *Uint64 `thrift:"name,1" db:"name" json:"name"`
}

func NewApplyIsAccountArgs() *ApplyIsAccountArgs {
  return &ApplyIsAccountArgs{}
}

var ApplyIsAccountArgs_Name_DEFAULT *Uint64
func (p *ApplyIsAccountArgs) GetName() *Uint64 {
  if !p.IsSetName() {
    return ApplyIsAccountArgs_Name_DEFAULT
  }
return p.Name
}
func (p *ApplyIsAccountArgs) IsSetName() bool {
  return p.Name != nil
}

func (p *ApplyIsAccountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Name = &Uint64{}
  if err := p.Name.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Name), err)
  }
  return nil
}

func (p *ApplyIsAccountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := p.Name.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Name), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ApplyIsAccountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsAccountResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsAccountResult() *ApplyIsAccountResult {
  return &ApplyIsAccountResult{}
}

var ApplyIsAccountResult_Success_DEFAULT bool
func (p *ApplyIsAccountResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsAccountResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsAccountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsAccountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsAccountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsAccountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_account_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsAccountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsAccountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsAccountResult(%+v)", *p)
}

// Attributes:
//  - SerializedAction
type ApplySendInlineArgs struct {
  SerializedAction []byte `thrift:"serialized_action,1" db:"serialized_action" json:"serialized_action"`
}

func NewApplySendInlineArgs() *ApplySendInlineArgs {
  return &ApplySendInlineArgs{}
}


func (p *ApplySendInlineArgs) GetSerializedAction() []byte {
  return p.SerializedAction
}
func (p *ApplySendInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedAction = v
}
  return nil
}

func (p *ApplySendInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_action", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_action: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedAction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_action (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_action: ", p), err) }
  return err
}

func (p *ApplySendInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineArgs(%+v)", *p)
}

type ApplySendInlineResult struct {
}

func NewApplySendInlineResult() *ApplySendInlineResult {
  return &ApplySendInlineResult{}
}

func (p *ApplySendInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendInlineResult(%+v)", *p)
}

// Attributes:
//  - SerializedData
type ApplySendContextFreeInlineArgs struct {
  SerializedData []byte `thrift:"serialized_data,1" db:"serialized_data" json:"serialized_data"`
}

func NewApplySendContextFreeInlineArgs() *ApplySendContextFreeInlineArgs {
  return &ApplySendContextFreeInlineArgs{}
}


func (p *ApplySendContextFreeInlineArgs) GetSerializedData() []byte {
  return p.SerializedData
}
func (p *ApplySendContextFreeInlineArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SerializedData = v
}
  return nil
}

func (p *ApplySendContextFreeInlineArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serialized_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serialized_data: ", p), err) }
  return err
}

func (p *ApplySendContextFreeInlineArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineArgs(%+v)", *p)
}

type ApplySendContextFreeInlineResult struct {
}

func NewApplySendContextFreeInlineResult() *ApplySendContextFreeInlineResult {
  return &ApplySendContextFreeInlineResult{}
}

func (p *ApplySendContextFreeInlineResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendContextFreeInlineResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_context_free_inline_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendContextFreeInlineResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendContextFreeInlineResult(%+v)", *p)
}

type ApplyPublicationTimeArgs struct {
}

func NewApplyPublicationTimeArgs() *ApplyPublicationTimeArgs {
  return &ApplyPublicationTimeArgs{}
}

func (p *ApplyPublicationTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyPublicationTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyPublicationTimeResult() *ApplyPublicationTimeResult {
  return &ApplyPublicationTimeResult{}
}

var ApplyPublicationTimeResult_Success_DEFAULT *Uint64
func (p *ApplyPublicationTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyPublicationTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyPublicationTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyPublicationTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyPublicationTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "publication_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyPublicationTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyPublicationTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyPublicationTimeResult(%+v)", *p)
}

type ApplyCurrentReceiverArgs struct {
}

func NewApplyCurrentReceiverArgs() *ApplyCurrentReceiverArgs {
  return &ApplyCurrentReceiverArgs{}
}

func (p *ApplyCurrentReceiverArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentReceiverResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentReceiverResult() *ApplyCurrentReceiverResult {
  return &ApplyCurrentReceiverResult{}
}

var ApplyCurrentReceiverResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentReceiverResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentReceiverResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentReceiverResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentReceiverResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentReceiverResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_receiver_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentReceiverResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentReceiverResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentReceiverResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertArgs() *ApplyEosioAssertArgs {
  return &ApplyEosioAssertArgs{}
}


func (p *ApplyEosioAssertArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertArgs(%+v)", *p)
}

type ApplyEosioAssertResult struct {
}

func NewApplyEosioAssertResult() *ApplyEosioAssertResult {
  return &ApplyEosioAssertResult{}
}

func (p *ApplyEosioAssertResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Msg
type ApplyEosioAssertMessageArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Msg []byte `thrift:"msg,2" db:"msg" json:"msg"`
}

func NewApplyEosioAssertMessageArgs() *ApplyEosioAssertMessageArgs {
  return &ApplyEosioAssertMessageArgs{}
}


func (p *ApplyEosioAssertMessageArgs) GetTest() bool {
  return p.Test
}

func (p *ApplyEosioAssertMessageArgs) GetMsg() []byte {
  return p.Msg
}
func (p *ApplyEosioAssertMessageArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Msg = v
}
  return nil
}

func (p *ApplyEosioAssertMessageArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "msg", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:msg: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Msg); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.msg (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:msg: ", p), err) }
  return err
}

func (p *ApplyEosioAssertMessageArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageArgs(%+v)", *p)
}

type ApplyEosioAssertMessageResult struct {
}

func NewApplyEosioAssertMessageResult() *ApplyEosioAssertMessageResult {
  return &ApplyEosioAssertMessageResult{}
}

func (p *ApplyEosioAssertMessageResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertMessageResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_message_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertMessageResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertMessageResult(%+v)", *p)
}

// Attributes:
//  - Test
//  - Code
type ApplyEosioAssertCodeArgs struct {
  Test bool `thrift:"test,1" db:"test" json:"test"`
  Code *Uint64 `thrift:"code,2" db:"code" json:"code"`
}

func NewApplyEosioAssertCodeArgs() *ApplyEosioAssertCodeArgs {
  return &ApplyEosioAssertCodeArgs{}
}


func (p *ApplyEosioAssertCodeArgs) GetTest() bool {
  return p.Test
}
var ApplyEosioAssertCodeArgs_Code_DEFAULT *Uint64
func (p *ApplyEosioAssertCodeArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyEosioAssertCodeArgs_Code_DEFAULT
  }
return p.Code
}
func (p *ApplyEosioAssertCodeArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyEosioAssertCodeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Test = v
}
  return nil
}

func (p *ApplyEosioAssertCodeArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "test", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:test: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Test)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.test (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:test: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:code: ", p), err) }
  return err
}

func (p *ApplyEosioAssertCodeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeArgs(%+v)", *p)
}

type ApplyEosioAssertCodeResult struct {
}

func NewApplyEosioAssertCodeResult() *ApplyEosioAssertCodeResult {
  return &ApplyEosioAssertCodeResult{}
}

func (p *ApplyEosioAssertCodeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioAssertCodeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_assert_code_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioAssertCodeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioAssertCodeResult(%+v)", *p)
}

// Attributes:
//  - Code
type ApplyEosioExitArgs struct {
  Code int32 `thrift:"code,1" db:"code" json:"code"`
}

func NewApplyEosioExitArgs() *ApplyEosioExitArgs {
  return &ApplyEosioExitArgs{}
}


func (p *ApplyEosioExitArgs) GetCode() int32 {
  return p.Code
}
func (p *ApplyEosioExitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *ApplyEosioExitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyEosioExitArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitArgs(%+v)", *p)
}

type ApplyEosioExitResult struct {
}

func NewApplyEosioExitResult() *ApplyEosioExitResult {
  return &ApplyEosioExitResult{}
}

func (p *ApplyEosioExitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyEosioExitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "eosio_exit_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyEosioExitResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyEosioExitResult(%+v)", *p)
}

type ApplyCurrentTimeArgs struct {
}

func NewApplyCurrentTimeArgs() *ApplyCurrentTimeArgs {
  return &ApplyCurrentTimeArgs{}
}

func (p *ApplyCurrentTimeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCurrentTimeResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCurrentTimeResult() *ApplyCurrentTimeResult {
  return &ApplyCurrentTimeResult{}
}

var ApplyCurrentTimeResult_Success_DEFAULT *Uint64
func (p *ApplyCurrentTimeResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyCurrentTimeResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyCurrentTimeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCurrentTimeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyCurrentTimeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "current_time_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCurrentTimeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCurrentTimeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCurrentTimeResult(%+v)", *p)
}

// Attributes:
//  - FeatureDigest
type ApplyIsFeatureActivatedArgs struct {
  FeatureDigest []byte `thrift:"feature_digest,1" db:"feature_digest" json:"feature_digest"`
}

func NewApplyIsFeatureActivatedArgs() *ApplyIsFeatureActivatedArgs {
  return &ApplyIsFeatureActivatedArgs{}
}


func (p *ApplyIsFeatureActivatedArgs) GetFeatureDigest() []byte {
  return p.FeatureDigest
}
func (p *ApplyIsFeatureActivatedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FeatureDigest = v
}
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "feature_digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature_digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.FeatureDigest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.feature_digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature_digest: ", p), err) }
  return err
}

func (p *ApplyIsFeatureActivatedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyIsFeatureActivatedResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyIsFeatureActivatedResult() *ApplyIsFeatureActivatedResult {
  return &ApplyIsFeatureActivatedResult{}
}

var ApplyIsFeatureActivatedResult_Success_DEFAULT bool
func (p *ApplyIsFeatureActivatedResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ApplyIsFeatureActivatedResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyIsFeatureActivatedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyIsFeatureActivatedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyIsFeatureActivatedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyIsFeatureActivatedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "is_feature_activated_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyIsFeatureActivatedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyIsFeatureActivatedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyIsFeatureActivatedResult(%+v)", *p)
}

type ApplyGetSenderArgs struct {
}

func NewApplyGetSenderArgs() *ApplyGetSenderArgs {
  return &ApplyGetSenderArgs{}
}

func (p *ApplyGetSenderArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetSenderResult struct {
  Success *Uint64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetSenderResult() *ApplyGetSenderResult {
  return &ApplyGetSenderResult{}
}

var ApplyGetSenderResult_Success_DEFAULT *Uint64
func (p *ApplyGetSenderResult) GetSuccess() *Uint64 {
  if !p.IsSetSuccess() {
    return ApplyGetSenderResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyGetSenderResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetSenderResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetSenderResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Uint64{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyGetSenderResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_sender_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetSenderResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetSenderResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetSenderResult(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha256Args() *ApplyAssertSha256Args {
  return &ApplyAssertSha256Args{}
}


func (p *ApplyAssertSha256Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha256Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha256Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Args(%+v)", *p)
}

type ApplyAssertSha256Result struct {
}

func NewApplyAssertSha256Result() *ApplyAssertSha256Result {
  return &ApplyAssertSha256Result{}
}

func (p *ApplyAssertSha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha256Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha1Args() *ApplyAssertSha1Args {
  return &ApplyAssertSha1Args{}
}


func (p *ApplyAssertSha1Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha1Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha1Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Args(%+v)", *p)
}

type ApplyAssertSha1Result struct {
}

func NewApplyAssertSha1Result() *ApplyAssertSha1Result {
  return &ApplyAssertSha1Result{}
}

func (p *ApplyAssertSha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha1Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertSha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertSha512Args() *ApplyAssertSha512Args {
  return &ApplyAssertSha512Args{}
}


func (p *ApplyAssertSha512Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertSha512Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertSha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertSha512Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertSha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertSha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Args(%+v)", *p)
}

type ApplyAssertSha512Result struct {
}

func NewApplyAssertSha512Result() *ApplyAssertSha512Result {
  return &ApplyAssertSha512Result{}
}

func (p *ApplyAssertSha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertSha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertSha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertSha512Result(%+v)", *p)
}

// Attributes:
//  - Data
//  - Hash
type ApplyAssertRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
  Hash []byte `thrift:"hash,2" db:"hash" json:"hash"`
}

func NewApplyAssertRipemd160Args() *ApplyAssertRipemd160Args {
  return &ApplyAssertRipemd160Args{}
}


func (p *ApplyAssertRipemd160Args) GetData() []byte {
  return p.Data
}

func (p *ApplyAssertRipemd160Args) GetHash() []byte {
  return p.Hash
}
func (p *ApplyAssertRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Hash = v
}
  return nil
}

func (p *ApplyAssertRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hash", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Hash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hash (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hash: ", p), err) }
  return err
}

func (p *ApplyAssertRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Args(%+v)", *p)
}

type ApplyAssertRipemd160Result struct {
}

func NewApplyAssertRipemd160Result() *ApplyAssertRipemd160Result {
  return &ApplyAssertRipemd160Result{}
}

func (p *ApplyAssertRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha256Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha256Args() *ApplySha256Args {
  return &ApplySha256Args{}
}


func (p *ApplySha256Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha256Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha256Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha256Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha256Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha256Result() *ApplySha256Result {
  return &ApplySha256Result{}
}

var ApplySha256Result_Success_DEFAULT []byte

func (p *ApplySha256Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha256Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha256Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha256Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha256Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha256_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha256Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha256Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha256Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha1Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha1Args() *ApplySha1Args {
  return &ApplySha1Args{}
}


func (p *ApplySha1Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha1Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha1Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha1Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha1Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha1Result() *ApplySha1Result {
  return &ApplySha1Result{}
}

var ApplySha1Result_Success_DEFAULT []byte

func (p *ApplySha1Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha1Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha1Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha1Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha1Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha1_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha1Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha1Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha1Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplySha512Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplySha512Args() *ApplySha512Args {
  return &ApplySha512Args{}
}


func (p *ApplySha512Args) GetData() []byte {
  return p.Data
}
func (p *ApplySha512Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplySha512Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplySha512Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplySha512Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplySha512Result() *ApplySha512Result {
  return &ApplySha512Result{}
}

var ApplySha512Result_Success_DEFAULT []byte

func (p *ApplySha512Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplySha512Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplySha512Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySha512Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplySha512Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sha512_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySha512Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplySha512Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySha512Result(%+v)", *p)
}

// Attributes:
//  - Data
type ApplyRipemd160Args struct {
  Data []byte `thrift:"data,1" db:"data" json:"data"`
}

func NewApplyRipemd160Args() *ApplyRipemd160Args {
  return &ApplyRipemd160Args{}
}


func (p *ApplyRipemd160Args) GetData() []byte {
  return p.Data
}
func (p *ApplyRipemd160Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyRipemd160Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:data: ", p), err) }
  return err
}

func (p *ApplyRipemd160Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRipemd160Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRipemd160Result() *ApplyRipemd160Result {
  return &ApplyRipemd160Result{}
}

var ApplyRipemd160Result_Success_DEFAULT []byte

func (p *ApplyRipemd160Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRipemd160Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRipemd160Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRipemd160Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRipemd160Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ripemd160_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRipemd160Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRipemd160Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRipemd160Result(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
type ApplyRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
}

func NewApplyRecoverKeyArgs() *ApplyRecoverKeyArgs {
  return &ApplyRecoverKeyArgs{}
}


func (p *ApplyRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}
func (p *ApplyRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyRecoverKeyResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyRecoverKeyResult() *ApplyRecoverKeyResult {
  return &ApplyRecoverKeyResult{}
}

var ApplyRecoverKeyResult_Success_DEFAULT []byte

func (p *ApplyRecoverKeyResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyRecoverKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyRecoverKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyRecoverKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - Digest
//  - Sig
//  - Pub
type ApplyAssertRecoverKeyArgs struct {
  Digest []byte `thrift:"digest,1" db:"digest" json:"digest"`
  Sig []byte `thrift:"sig,2" db:"sig" json:"sig"`
  Pub []byte `thrift:"pub,3" db:"pub" json:"pub"`
}

func NewApplyAssertRecoverKeyArgs() *ApplyAssertRecoverKeyArgs {
  return &ApplyAssertRecoverKeyArgs{}
}


func (p *ApplyAssertRecoverKeyArgs) GetDigest() []byte {
  return p.Digest
}

func (p *ApplyAssertRecoverKeyArgs) GetSig() []byte {
  return p.Sig
}

func (p *ApplyAssertRecoverKeyArgs) GetPub() []byte {
  return p.Pub
}
func (p *ApplyAssertRecoverKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Digest = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Sig = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pub = v
}
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "digest", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:digest: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Digest); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.digest (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:digest: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sig: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Sig); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sig: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pub", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pub: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Pub); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pub (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pub: ", p), err) }
  return err
}

func (p *ApplyAssertRecoverKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyArgs(%+v)", *p)
}

type ApplyAssertRecoverKeyResult struct {
}

func NewApplyAssertRecoverKeyResult() *ApplyAssertRecoverKeyResult {
  return &ApplyAssertRecoverKeyResult{}
}

func (p *ApplyAssertRecoverKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "assert_recover_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyAssertRecoverKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyAssertRecoverKeyResult(%+v)", *p)
}

// Attributes:
//  - SenderID
//  - Payer
//  - SerializedTransaction
//  - ReplaceExisting
type ApplySendDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  SerializedTransaction []byte `thrift:"serialized_transaction,3" db:"serialized_transaction" json:"serialized_transaction"`
  ReplaceExisting int32 `thrift:"replace_existing,4" db:"replace_existing" json:"replace_existing"`
}

func NewApplySendDeferredArgs() *ApplySendDeferredArgs {
  return &ApplySendDeferredArgs{}
}


func (p *ApplySendDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
var ApplySendDeferredArgs_Payer_DEFAULT *Uint64
func (p *ApplySendDeferredArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplySendDeferredArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplySendDeferredArgs) GetSerializedTransaction() []byte {
  return p.SerializedTransaction
}

func (p *ApplySendDeferredArgs) GetReplaceExisting() int32 {
  return p.ReplaceExisting
}
func (p *ApplySendDeferredArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplySendDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.SerializedTransaction = v
}
  return nil
}

func (p *ApplySendDeferredArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ReplaceExisting = v
}
  return nil
}

func (p *ApplySendDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serialized_transaction", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serialized_transaction: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SerializedTransaction); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serialized_transaction (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serialized_transaction: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "replace_existing", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:replace_existing: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ReplaceExisting)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.replace_existing (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:replace_existing: ", p), err) }
  return err
}

func (p *ApplySendDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredArgs(%+v)", *p)
}

type ApplySendDeferredResult struct {
}

func NewApplySendDeferredResult() *ApplySendDeferredResult {
  return &ApplySendDeferredResult{}
}

func (p *ApplySendDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplySendDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplySendDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplySendDeferredResult(%+v)", *p)
}

// Attributes:
//  - SenderID
type ApplyCancelDeferredArgs struct {
  SenderID []byte `thrift:"sender_id,1" db:"sender_id" json:"sender_id"`
}

func NewApplyCancelDeferredArgs() *ApplyCancelDeferredArgs {
  return &ApplyCancelDeferredArgs{}
}


func (p *ApplyCancelDeferredArgs) GetSenderID() []byte {
  return p.SenderID
}
func (p *ApplyCancelDeferredArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SenderID = v
}
  return nil
}

func (p *ApplyCancelDeferredArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sender_id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sender_id: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.SenderID); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sender_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sender_id: ", p), err) }
  return err
}

func (p *ApplyCancelDeferredArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyCancelDeferredResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyCancelDeferredResult() *ApplyCancelDeferredResult {
  return &ApplyCancelDeferredResult{}
}

var ApplyCancelDeferredResult_Success_DEFAULT int32
func (p *ApplyCancelDeferredResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyCancelDeferredResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyCancelDeferredResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyCancelDeferredResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyCancelDeferredResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyCancelDeferredResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cancel_deferred_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyCancelDeferredResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyCancelDeferredResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyCancelDeferredResult(%+v)", *p)
}

type ApplyReadTransactionArgs struct {
}

func NewApplyReadTransactionArgs() *ApplyReadTransactionArgs {
  return &ApplyReadTransactionArgs{}
}

func (p *ApplyReadTransactionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyReadTransactionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyReadTransactionResult() *ApplyReadTransactionResult {
  return &ApplyReadTransactionResult{}
}

var ApplyReadTransactionResult_Success_DEFAULT []byte

func (p *ApplyReadTransactionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyReadTransactionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyReadTransactionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyReadTransactionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyReadTransactionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "read_transaction_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyReadTransactionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyReadTransactionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyReadTransactionResult(%+v)", *p)
}

type ApplyTransactionSizeArgs struct {
}

func NewApplyTransactionSizeArgs() *ApplyTransactionSizeArgs {
  return &ApplyTransactionSizeArgs{}
}

func (p *ApplyTransactionSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTransactionSizeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTransactionSizeResult() *ApplyTransactionSizeResult {
  return &ApplyTransactionSizeResult{}
}

var ApplyTransactionSizeResult_Success_DEFAULT int32
func (p *ApplyTransactionSizeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTransactionSizeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTransactionSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTransactionSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTransactionSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTransactionSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "transaction_size_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTransactionSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTransactionSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTransactionSizeResult(%+v)", *p)
}

type ApplyTaposBlockNumArgs struct {
}

func NewApplyTaposBlockNumArgs() *ApplyTaposBlockNumArgs {
  return &ApplyTaposBlockNumArgs{}
}

func (p *ApplyTaposBlockNumArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockNumResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockNumResult() *ApplyTaposBlockNumResult {
  return &ApplyTaposBlockNumResult{}
}

var ApplyTaposBlockNumResult_Success_DEFAULT int32
func (p *ApplyTaposBlockNumResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockNumResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockNumResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockNumResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockNumResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockNumResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_num_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockNumResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockNumResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockNumResult(%+v)", *p)
}

type ApplyTaposBlockPrefixArgs struct {
}

func NewApplyTaposBlockPrefixArgs() *ApplyTaposBlockPrefixArgs {
  return &ApplyTaposBlockPrefixArgs{}
}

func (p *ApplyTaposBlockPrefixArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyTaposBlockPrefixResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyTaposBlockPrefixResult() *ApplyTaposBlockPrefixResult {
  return &ApplyTaposBlockPrefixResult{}
}

var ApplyTaposBlockPrefixResult_Success_DEFAULT int32
func (p *ApplyTaposBlockPrefixResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyTaposBlockPrefixResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyTaposBlockPrefixResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyTaposBlockPrefixResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyTaposBlockPrefixResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyTaposBlockPrefixResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tapos_block_prefix_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyTaposBlockPrefixResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyTaposBlockPrefixResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyTaposBlockPrefixResult(%+v)", *p)
}

type ApplyExpirationArgs struct {
}

func NewApplyExpirationArgs() *ApplyExpirationArgs {
  return &ApplyExpirationArgs{}
}

func (p *ApplyExpirationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyExpirationResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyExpirationResult() *ApplyExpirationResult {
  return &ApplyExpirationResult{}
}

var ApplyExpirationResult_Success_DEFAULT int64
func (p *ApplyExpirationResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ApplyExpirationResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyExpirationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyExpirationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyExpirationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyExpirationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expiration_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyExpirationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyExpirationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyExpirationResult(%+v)", *p)
}

// Attributes:
//  - _type
//  - Index
type ApplyGetActionArgs struct {
  _type int32 `thrift:"_type,1" db:"_type" json:"_type"`
  Index int32 `thrift:"index,2" db:"index" json:"index"`
}

func NewApplyGetActionArgs() *ApplyGetActionArgs {
  return &ApplyGetActionArgs{}
}


func (p *ApplyGetActionArgs) Get_type() int32 {
  return p._type
}

func (p *ApplyGetActionArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetActionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p._type = v
}
  return nil
}

func (p *ApplyGetActionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetActionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "_type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:_type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p._type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T._type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:_type: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:index: ", p), err) }
  return err
}

func (p *ApplyGetActionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetActionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetActionResult() *ApplyGetActionResult {
  return &ApplyGetActionResult{}
}

var ApplyGetActionResult_Success_DEFAULT []byte

func (p *ApplyGetActionResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetActionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetActionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetActionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetActionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_action_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetActionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetActionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetActionResult(%+v)", *p)
}

// Attributes:
//  - Index
type ApplyGetContextFreeDataArgs struct {
  Index int32 `thrift:"index,1" db:"index" json:"index"`
}

func NewApplyGetContextFreeDataArgs() *ApplyGetContextFreeDataArgs {
  return &ApplyGetContextFreeDataArgs{}
}


func (p *ApplyGetContextFreeDataArgs) GetIndex() int32 {
  return p.Index
}
func (p *ApplyGetContextFreeDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Index = v
}
  return nil
}

func (p *ApplyGetContextFreeDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "index", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:index: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Index)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.index (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:index: ", p), err) }
  return err
}

func (p *ApplyGetContextFreeDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyGetContextFreeDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyGetContextFreeDataResult() *ApplyGetContextFreeDataResult {
  return &ApplyGetContextFreeDataResult{}
}

var ApplyGetContextFreeDataResult_Success_DEFAULT []byte

func (p *ApplyGetContextFreeDataResult) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyGetContextFreeDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyGetContextFreeDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyGetContextFreeDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyGetContextFreeDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_context_free_data_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyGetContextFreeDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyGetContextFreeDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyGetContextFreeDataResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbStoreI64Args struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbStoreI64Args() *ApplyDbStoreI64Args {
  return &ApplyDbStoreI64Args{}
}

var ApplyDbStoreI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbStoreI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbStoreI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbStoreI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbStoreI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbStoreI64Args_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbStoreI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbStoreI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbStoreI64Args_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbStoreI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbStoreI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbStoreI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbStoreI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbStoreI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbStoreI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Args)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbStoreI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbStoreI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbStoreI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbStoreI64Result() *ApplyDbStoreI64Result {
  return &ApplyDbStoreI64Result{}
}

var ApplyDbStoreI64Result_Success_DEFAULT int32
func (p *ApplyDbStoreI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbStoreI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbStoreI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbStoreI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbStoreI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbStoreI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_store_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbStoreI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbStoreI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbStoreI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbUpdateI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbUpdateI64Args() *ApplyDbUpdateI64Args {
  return &ApplyDbUpdateI64Args{}
}


func (p *ApplyDbUpdateI64Args) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbUpdateI64Args_Payer_DEFAULT *Uint64
func (p *ApplyDbUpdateI64Args) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbUpdateI64Args_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbUpdateI64Args) GetData() []byte {
  return p.Data
}
func (p *ApplyDbUpdateI64Args) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbUpdateI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbUpdateI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbUpdateI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Args(%+v)", *p)
}

type ApplyDbUpdateI64Result struct {
}

func NewApplyDbUpdateI64Result() *ApplyDbUpdateI64Result {
  return &ApplyDbUpdateI64Result{}
}

func (p *ApplyDbUpdateI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpdateI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_update_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpdateI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpdateI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbRemoveI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbRemoveI64Args() *ApplyDbRemoveI64Args {
  return &ApplyDbRemoveI64Args{}
}


func (p *ApplyDbRemoveI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbRemoveI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbRemoveI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbRemoveI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Args(%+v)", *p)
}

type ApplyDbRemoveI64Result struct {
}

func NewApplyDbRemoveI64Result() *ApplyDbRemoveI64Result {
  return &ApplyDbRemoveI64Result{}
}

func (p *ApplyDbRemoveI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbRemoveI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_remove_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbRemoveI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbRemoveI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbGetI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbGetI64Args() *ApplyDbGetI64Args {
  return &ApplyDbGetI64Args{}
}


func (p *ApplyDbGetI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbGetI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbGetI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbGetI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbGetI64Result struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbGetI64Result() *ApplyDbGetI64Result {
  return &ApplyDbGetI64Result{}
}

var ApplyDbGetI64Result_Success_DEFAULT []byte

func (p *ApplyDbGetI64Result) GetSuccess() []byte {
  return p.Success
}
func (p *ApplyDbGetI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbGetI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbGetI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *ApplyDbGetI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_get_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbGetI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbGetI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbGetI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbNextI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbNextI64Args() *ApplyDbNextI64Args {
  return &ApplyDbNextI64Args{}
}


func (p *ApplyDbNextI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbNextI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbNextI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbNextI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbNextI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbNextI64Result() *ApplyDbNextI64Result {
  return &ApplyDbNextI64Result{}
}

var ApplyDbNextI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbNextI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbNextI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbNextI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbNextI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbNextI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_next_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbNextI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbNextI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbNextI64Result(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbPreviousI64Args struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbPreviousI64Args() *ApplyDbPreviousI64Args {
  return &ApplyDbPreviousI64Args{}
}


func (p *ApplyDbPreviousI64Args) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbPreviousI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbPreviousI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbPreviousI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbPreviousI64Result struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbPreviousI64Result() *ApplyDbPreviousI64Result {
  return &ApplyDbPreviousI64Result{}
}

var ApplyDbPreviousI64Result_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbPreviousI64Result) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbPreviousI64Result_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbPreviousI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbPreviousI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbPreviousI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_previous_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbPreviousI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbPreviousI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbPreviousI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbFindI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbFindI64Args() *ApplyDbFindI64Args {
  return &ApplyDbFindI64Args{}
}

var ApplyDbFindI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbFindI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbFindI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbFindI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbFindI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbFindI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbFindI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbFindI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbFindI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbFindI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbFindI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbFindI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbFindI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbFindI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbFindI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbFindI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbFindI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbFindI64Result() *ApplyDbFindI64Result {
  return &ApplyDbFindI64Result{}
}

var ApplyDbFindI64Result_Success_DEFAULT int32
func (p *ApplyDbFindI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbFindI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbFindI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbFindI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbFindI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbFindI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_find_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbFindI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbFindI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbFindI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbLowerboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbLowerboundI64Args() *ApplyDbLowerboundI64Args {
  return &ApplyDbLowerboundI64Args{}
}

var ApplyDbLowerboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbLowerboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbLowerboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbLowerboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbLowerboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbLowerboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbLowerboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbLowerboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbLowerboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbLowerboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbLowerboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbLowerboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbLowerboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbLowerboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbLowerboundI64Result() *ApplyDbLowerboundI64Result {
  return &ApplyDbLowerboundI64Result{}
}

var ApplyDbLowerboundI64Result_Success_DEFAULT int32
func (p *ApplyDbLowerboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbLowerboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbLowerboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbLowerboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbLowerboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbLowerboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_lowerbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbLowerboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbLowerboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbLowerboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - ID
type ApplyDbUpperboundI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
}

func NewApplyDbUpperboundI64Args() *ApplyDbUpperboundI64Args {
  return &ApplyDbUpperboundI64Args{}
}

var ApplyDbUpperboundI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbUpperboundI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbUpperboundI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbUpperboundI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbUpperboundI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbUpperboundI64Args_Table_DEFAULT
  }
return p.Table
}
var ApplyDbUpperboundI64Args_ID_DEFAULT *Uint64
func (p *ApplyDbUpperboundI64Args) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbUpperboundI64Args_ID_DEFAULT
  }
return p.ID
}
func (p *ApplyDbUpperboundI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbUpperboundI64Args) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbUpperboundI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbUpperboundI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbUpperboundI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbUpperboundI64Result() *ApplyDbUpperboundI64Result {
  return &ApplyDbUpperboundI64Result{}
}

var ApplyDbUpperboundI64Result_Success_DEFAULT int32
func (p *ApplyDbUpperboundI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbUpperboundI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbUpperboundI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbUpperboundI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbUpperboundI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbUpperboundI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_upperbound_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbUpperboundI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbUpperboundI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbUpperboundI64Result(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbEndI64Args struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbEndI64Args() *ApplyDbEndI64Args {
  return &ApplyDbEndI64Args{}
}

var ApplyDbEndI64Args_Code_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbEndI64Args_Code_DEFAULT
  }
return p.Code
}
var ApplyDbEndI64Args_Scope_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbEndI64Args_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbEndI64Args_Table_DEFAULT *Uint64
func (p *ApplyDbEndI64Args) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbEndI64Args_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbEndI64Args) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbEndI64Args) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbEndI64Args) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbEndI64Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbEndI64Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbEndI64Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Args(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbEndI64Result struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbEndI64Result() *ApplyDbEndI64Result {
  return &ApplyDbEndI64Result{}
}

var ApplyDbEndI64Result_Success_DEFAULT int32
func (p *ApplyDbEndI64Result) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbEndI64Result_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbEndI64Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbEndI64Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbEndI64Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbEndI64Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_end_i64_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbEndI64Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbEndI64Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbEndI64Result(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx64StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary *Uint64 `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64StoreArgs() *ApplyDbIdx64StoreArgs {
  return &ApplyDbIdx64StoreArgs{}
}

var ApplyDbIdx64StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx64StoreArgs_ID_DEFAULT
  }
return p.ID
}
var ApplyDbIdx64StoreArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64StoreArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64StoreArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx64StoreArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64StoreResult() *ApplyDbIdx64StoreResult {
  return &ApplyDbIdx64StoreResult{}
}

var ApplyDbIdx64StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx64StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx64UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary *Uint64 `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64UpdateArgs() *ApplyDbIdx64UpdateArgs {
  return &ApplyDbIdx64UpdateArgs{}
}


func (p *ApplyDbIdx64UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx64UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx64UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx64UpdateArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpdateArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpdateArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx64UpdateArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateArgs(%+v)", *p)
}

type ApplyDbIdx64UpdateResult struct {
}

func NewApplyDbIdx64UpdateResult() *ApplyDbIdx64UpdateResult {
  return &ApplyDbIdx64UpdateResult{}
}

func (p *ApplyDbIdx64UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64RemoveArgs() *ApplyDbIdx64RemoveArgs {
  return &ApplyDbIdx64RemoveArgs{}
}


func (p *ApplyDbIdx64RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveArgs(%+v)", *p)
}

type ApplyDbIdx64RemoveResult struct {
}

func NewApplyDbIdx64RemoveResult() *ApplyDbIdx64RemoveResult {
  return &ApplyDbIdx64RemoveResult{}
}

func (p *ApplyDbIdx64RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx64NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx64NextArgs() *ApplyDbIdx64NextArgs {
  return &ApplyDbIdx64NextArgs{}
}


func (p *ApplyDbIdx64NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx64NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx64NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx64NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64NextResult() *ApplyDbIdx64NextResult {
  return &ApplyDbIdx64NextResult{}
}

var ApplyDbIdx64NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64NextResult(%+v)", *p)
}

// Attributes:
//  - Iteratory
type ApplyDbIdx64PreviousArgs struct {
  Iteratory int32 `thrift:"iteratory,1" db:"iteratory" json:"iteratory"`
}

func NewApplyDbIdx64PreviousArgs() *ApplyDbIdx64PreviousArgs {
  return &ApplyDbIdx64PreviousArgs{}
}


func (p *ApplyDbIdx64PreviousArgs) GetIteratory() int32 {
  return p.Iteratory
}
func (p *ApplyDbIdx64PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iteratory = v
}
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iteratory", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iteratory: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iteratory)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iteratory (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iteratory: ", p), err) }
  return err
}

func (p *ApplyDbIdx64PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64PreviousResult() *ApplyDbIdx64PreviousResult {
  return &ApplyDbIdx64PreviousResult{}
}

var ApplyDbIdx64PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx64PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx64FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx64FindPrimaryArgs() *ApplyDbIdx64FindPrimaryArgs {
  return &ApplyDbIdx64FindPrimaryArgs{}
}

var ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindPrimaryResult() *ApplyDbIdx64FindPrimaryResult {
  return &ApplyDbIdx64FindPrimaryResult{}
}

var ApplyDbIdx64FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx64FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx64FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx64FindSecondaryArgs() *ApplyDbIdx64FindSecondaryArgs {
  return &ApplyDbIdx64FindSecondaryArgs{}
}

var ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64FindSecondaryArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64FindSecondaryArgs_Secondary_DEFAULT
  }
return p.Secondary
}
func (p *ApplyDbIdx64FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64FindSecondaryResult() *ApplyDbIdx64FindSecondaryResult {
  return &ApplyDbIdx64FindSecondaryResult{}
}

var ApplyDbIdx64FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx64FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64LowerboundArgs() *ApplyDbIdx64LowerboundArgs {
  return &ApplyDbIdx64LowerboundArgs{}
}

var ApplyDbIdx64LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64LowerboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64LowerboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64LowerboundResult() *ApplyDbIdx64LowerboundResult {
  return &ApplyDbIdx64LowerboundResult{}
}

var ApplyDbIdx64LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx64UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary *Uint64 `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx64UpperboundArgs() *ApplyDbIdx64UpperboundArgs {
  return &ApplyDbIdx64UpperboundArgs{}
}

var ApplyDbIdx64UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64UpperboundArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetSecondary() *Uint64 {
  if !p.IsSetSecondary() {
    return ApplyDbIdx64UpperboundArgs_Secondary_DEFAULT
  }
return p.Secondary
}
var ApplyDbIdx64UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx64UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx64UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx64UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetSecondary() bool {
  return p.Secondary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx64UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Secondary = &Uint64{}
  if err := p.Secondary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Secondary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := p.Secondary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Secondary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx64UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64UpperboundResult() *ApplyDbIdx64UpperboundResult {
  return &ApplyDbIdx64UpperboundResult{}
}

var ApplyDbIdx64UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx64UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx64UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx64EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx64EndArgs() *ApplyDbIdx64EndArgs {
  return &ApplyDbIdx64EndArgs{}
}

var ApplyDbIdx64EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx64EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx64EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx64EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx64EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx64EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx64EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx64EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx64EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx64EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx64EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx64EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx64EndResult() *ApplyDbIdx64EndResult {
  return &ApplyDbIdx64EndResult{}
}

var ApplyDbIdx64EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx64EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx64EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx64EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx64EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx64EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx64EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx64_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx64EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx64EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx64EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdx128StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128StoreArgs() *ApplyDbIdx128StoreArgs {
  return &ApplyDbIdx128StoreArgs{}
}

var ApplyDbIdx128StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx128StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx128StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx128StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx128StoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx128StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128StoreResult() *ApplyDbIdx128StoreResult {
  return &ApplyDbIdx128StoreResult{}
}

var ApplyDbIdx128StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx128StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdx128UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128UpdateArgs() *ApplyDbIdx128UpdateArgs {
  return &ApplyDbIdx128UpdateArgs{}
}


func (p *ApplyDbIdx128UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx128UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx128UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx128UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx128UpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx128UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateArgs(%+v)", *p)
}

type ApplyDbIdx128UpdateResult struct {
}

func NewApplyDbIdx128UpdateResult() *ApplyDbIdx128UpdateResult {
  return &ApplyDbIdx128UpdateResult{}
}

func (p *ApplyDbIdx128UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128RemoveArgs() *ApplyDbIdx128RemoveArgs {
  return &ApplyDbIdx128RemoveArgs{}
}


func (p *ApplyDbIdx128RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveArgs(%+v)", *p)
}

type ApplyDbIdx128RemoveResult struct {
}

func NewApplyDbIdx128RemoveResult() *ApplyDbIdx128RemoveResult {
  return &ApplyDbIdx128RemoveResult{}
}

func (p *ApplyDbIdx128RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128NextArgs() *ApplyDbIdx128NextArgs {
  return &ApplyDbIdx128NextArgs{}
}


func (p *ApplyDbIdx128NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128NextResult() *ApplyDbIdx128NextResult {
  return &ApplyDbIdx128NextResult{}
}

var ApplyDbIdx128NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx128PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx128PreviousArgs() *ApplyDbIdx128PreviousArgs {
  return &ApplyDbIdx128PreviousArgs{}
}


func (p *ApplyDbIdx128PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx128PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx128PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128PreviousResult() *ApplyDbIdx128PreviousResult {
  return &ApplyDbIdx128PreviousResult{}
}

var ApplyDbIdx128PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx128PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx128FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx128FindPrimaryArgs() *ApplyDbIdx128FindPrimaryArgs {
  return &ApplyDbIdx128FindPrimaryArgs{}
}

var ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindPrimaryResult() *ApplyDbIdx128FindPrimaryResult {
  return &ApplyDbIdx128FindPrimaryResult{}
}

var ApplyDbIdx128FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx128FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdx128FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdx128FindSecondaryArgs() *ApplyDbIdx128FindSecondaryArgs {
  return &ApplyDbIdx128FindSecondaryArgs{}
}

var ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128FindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdx128FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128FindSecondaryResult() *ApplyDbIdx128FindSecondaryResult {
  return &ApplyDbIdx128FindSecondaryResult{}
}

var ApplyDbIdx128FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx128FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128LowerboundArgs() *ApplyDbIdx128LowerboundArgs {
  return &ApplyDbIdx128LowerboundArgs{}
}

var ApplyDbIdx128LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128LowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128LowerboundResult() *ApplyDbIdx128LowerboundResult {
  return &ApplyDbIdx128LowerboundResult{}
}

var ApplyDbIdx128LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdx128UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx128UpperboundArgs() *ApplyDbIdx128UpperboundArgs {
  return &ApplyDbIdx128UpperboundArgs{}
}

var ApplyDbIdx128UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx128UpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdx128UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx128UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx128UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx128UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx128UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx128UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128UpperboundResult() *ApplyDbIdx128UpperboundResult {
  return &ApplyDbIdx128UpperboundResult{}
}

var ApplyDbIdx128UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx128UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx128UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx128EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx128EndArgs() *ApplyDbIdx128EndArgs {
  return &ApplyDbIdx128EndArgs{}
}

var ApplyDbIdx128EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx128EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx128EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx128EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx128EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx128EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx128EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx128EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx128EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx128EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx128EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx128EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx128EndResult() *ApplyDbIdx128EndResult {
  return &ApplyDbIdx128EndResult{}
}

var ApplyDbIdx128EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx128EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx128EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx128EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx128EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx128EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx128EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx128_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx128EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx128EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx128EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Data
type ApplyDbIdx256StoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Data []byte `thrift:"data,5" db:"data" json:"data"`
}

func NewApplyDbIdx256StoreArgs() *ApplyDbIdx256StoreArgs {
  return &ApplyDbIdx256StoreArgs{}
}

var ApplyDbIdx256StoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256StoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256StoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256StoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256StoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256StoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdx256StoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdx256StoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdx256StoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdx256StoreArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256StoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256StoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdx256StoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256StoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256StoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256StoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256StoreResult() *ApplyDbIdx256StoreResult {
  return &ApplyDbIdx256StoreResult{}
}

var ApplyDbIdx256StoreResult_Success_DEFAULT int32
func (p *ApplyDbIdx256StoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256StoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256StoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256StoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256StoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256StoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256StoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256StoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256StoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Data
type ApplyDbIdx256UpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Data []byte `thrift:"data,3" db:"data" json:"data"`
}

func NewApplyDbIdx256UpdateArgs() *ApplyDbIdx256UpdateArgs {
  return &ApplyDbIdx256UpdateArgs{}
}


func (p *ApplyDbIdx256UpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdx256UpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdx256UpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdx256UpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdx256UpdateArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256UpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdx256UpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateArgs(%+v)", *p)
}

type ApplyDbIdx256UpdateResult struct {
}

func NewApplyDbIdx256UpdateResult() *ApplyDbIdx256UpdateResult {
  return &ApplyDbIdx256UpdateResult{}
}

func (p *ApplyDbIdx256UpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256RemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256RemoveArgs() *ApplyDbIdx256RemoveArgs {
  return &ApplyDbIdx256RemoveArgs{}
}


func (p *ApplyDbIdx256RemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256RemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256RemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveArgs(%+v)", *p)
}

type ApplyDbIdx256RemoveResult struct {
}

func NewApplyDbIdx256RemoveResult() *ApplyDbIdx256RemoveResult {
  return &ApplyDbIdx256RemoveResult{}
}

func (p *ApplyDbIdx256RemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256RemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256RemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256NextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256NextArgs() *ApplyDbIdx256NextArgs {
  return &ApplyDbIdx256NextArgs{}
}


func (p *ApplyDbIdx256NextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256NextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256NextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256NextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256NextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256NextResult() *ApplyDbIdx256NextResult {
  return &ApplyDbIdx256NextResult{}
}

var ApplyDbIdx256NextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256NextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256NextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256NextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256NextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256NextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256NextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256NextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256NextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdx256PreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdx256PreviousArgs() *ApplyDbIdx256PreviousArgs {
  return &ApplyDbIdx256PreviousArgs{}
}


func (p *ApplyDbIdx256PreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdx256PreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdx256PreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256PreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256PreviousResult() *ApplyDbIdx256PreviousResult {
  return &ApplyDbIdx256PreviousResult{}
}

var ApplyDbIdx256PreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdx256PreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256PreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256PreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256PreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256PreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256PreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256PreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdx256FindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdx256FindPrimaryArgs() *ApplyDbIdx256FindPrimaryArgs {
  return &ApplyDbIdx256FindPrimaryArgs{}
}

var ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256FindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256FindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256FindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindPrimaryResult() *ApplyDbIdx256FindPrimaryResult {
  return &ApplyDbIdx256FindPrimaryResult{}
}

var ApplyDbIdx256FindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdx256FindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
type ApplyDbIdx256FindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
}

func NewApplyDbIdx256FindSecondaryArgs() *ApplyDbIdx256FindSecondaryArgs {
  return &ApplyDbIdx256FindSecondaryArgs{}
}

var ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256FindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256FindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256FindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256FindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256FindSecondaryArgs) GetData() []byte {
  return p.Data
}
func (p *ApplyDbIdx256FindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256FindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256FindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256FindSecondaryResult() *ApplyDbIdx256FindSecondaryResult {
  return &ApplyDbIdx256FindSecondaryResult{}
}

var ApplyDbIdx256FindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdx256FindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256FindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256FindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256FindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256FindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256FindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256LowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256LowerboundArgs() *ApplyDbIdx256LowerboundArgs {
  return &ApplyDbIdx256LowerboundArgs{}
}

var ApplyDbIdx256LowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256LowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256LowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256LowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256LowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256LowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256LowerboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256LowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256LowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256LowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256LowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256LowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256LowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256LowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256LowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256LowerboundResult() *ApplyDbIdx256LowerboundResult {
  return &ApplyDbIdx256LowerboundResult{}
}

var ApplyDbIdx256LowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256LowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256LowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256LowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256LowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256LowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256LowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256LowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Data
//  - Primary
type ApplyDbIdx256UpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Data []byte `thrift:"data,4" db:"data" json:"data"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdx256UpperboundArgs() *ApplyDbIdx256UpperboundArgs {
  return &ApplyDbIdx256UpperboundArgs{}
}

var ApplyDbIdx256UpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256UpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256UpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256UpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256UpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256UpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdx256UpperboundArgs) GetData() []byte {
  return p.Data
}
var ApplyDbIdx256UpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdx256UpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdx256UpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdx256UpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256UpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdx256UpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:data: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdx256UpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256UpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256UpperboundResult() *ApplyDbIdx256UpperboundResult {
  return &ApplyDbIdx256UpperboundResult{}
}

var ApplyDbIdx256UpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdx256UpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256UpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdx256UpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256UpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256UpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256UpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256UpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdx256EndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdx256EndArgs() *ApplyDbIdx256EndArgs {
  return &ApplyDbIdx256EndArgs{}
}

var ApplyDbIdx256EndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdx256EndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdx256EndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdx256EndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdx256EndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdx256EndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdx256EndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdx256EndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdx256EndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdx256EndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdx256EndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdx256EndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdx256EndResult() *ApplyDbIdx256EndResult {
  return &ApplyDbIdx256EndResult{}
}

var ApplyDbIdx256EndResult_Success_DEFAULT int32
func (p *ApplyDbIdx256EndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdx256EndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdx256EndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdx256EndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdx256EndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdx256EndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx256_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdx256EndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdx256EndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdx256EndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleStoreArgs() *ApplyDbIdxDoubleStoreArgs {
  return &ApplyDbIdxDoubleStoreArgs{}
}

var ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleStoreResult() *ApplyDbIdxDoubleStoreResult {
  return &ApplyDbIdxDoubleStoreResult{}
}

var ApplyDbIdxDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleUpdateArgs() *ApplyDbIdxDoubleUpdateArgs {
  return &ApplyDbIdxDoubleUpdateArgs{}
}


func (p *ApplyDbIdxDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxDoubleUpdateResult struct {
}

func NewApplyDbIdxDoubleUpdateResult() *ApplyDbIdxDoubleUpdateResult {
  return &ApplyDbIdxDoubleUpdateResult{}
}

func (p *ApplyDbIdxDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleRemoveArgs() *ApplyDbIdxDoubleRemoveArgs {
  return &ApplyDbIdxDoubleRemoveArgs{}
}


func (p *ApplyDbIdxDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxDoubleRemoveResult struct {
}

func NewApplyDbIdxDoubleRemoveResult() *ApplyDbIdxDoubleRemoveResult {
  return &ApplyDbIdxDoubleRemoveResult{}
}

func (p *ApplyDbIdxDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoubleNextArgs() *ApplyDbIdxDoubleNextArgs {
  return &ApplyDbIdxDoubleNextArgs{}
}


func (p *ApplyDbIdxDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleNextResult() *ApplyDbIdxDoubleNextResult {
  return &ApplyDbIdxDoubleNextResult{}
}

var ApplyDbIdxDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxDoublePreviousArgs() *ApplyDbIdxDoublePreviousArgs {
  return &ApplyDbIdxDoublePreviousArgs{}
}


func (p *ApplyDbIdxDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoublePreviousResult() *ApplyDbIdxDoublePreviousResult {
  return &ApplyDbIdxDoublePreviousResult{}
}

var ApplyDbIdxDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleFindPrimaryArgs() *ApplyDbIdxDoubleFindPrimaryArgs {
  return &ApplyDbIdxDoubleFindPrimaryArgs{}
}

var ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindPrimaryResult() *ApplyDbIdxDoubleFindPrimaryResult {
  return &ApplyDbIdxDoubleFindPrimaryResult{}
}

var ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxDoubleFindSecondaryArgs() *ApplyDbIdxDoubleFindSecondaryArgs {
  return &ApplyDbIdxDoubleFindSecondaryArgs{}
}

var ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleFindSecondaryResult() *ApplyDbIdxDoubleFindSecondaryResult {
  return &ApplyDbIdxDoubleFindSecondaryResult{}
}

var ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleLowerboundArgs() *ApplyDbIdxDoubleLowerboundArgs {
  return &ApplyDbIdxDoubleLowerboundArgs{}
}

var ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleLowerboundResult() *ApplyDbIdxDoubleLowerboundResult {
  return &ApplyDbIdxDoubleLowerboundResult{}
}

var ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxDoubleUpperboundArgs() *ApplyDbIdxDoubleUpperboundArgs {
  return &ApplyDbIdxDoubleUpperboundArgs{}
}

var ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleUpperboundResult() *ApplyDbIdxDoubleUpperboundResult {
  return &ApplyDbIdxDoubleUpperboundResult{}
}

var ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxDoubleEndArgs() *ApplyDbIdxDoubleEndArgs {
  return &ApplyDbIdxDoubleEndArgs{}
}

var ApplyDbIdxDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxDoubleEndResult() *ApplyDbIdxDoubleEndResult {
  return &ApplyDbIdxDoubleEndResult{}
}

var ApplyDbIdxDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxDoubleEndResult(%+v)", *p)
}

// Attributes:
//  - Scope
//  - Table
//  - Payer
//  - ID
//  - Secondary
type ApplyDbIdxLongDoubleStoreArgs struct {
  Scope *Uint64 `thrift:"scope,1" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,2" db:"table" json:"table"`
  Payer *Uint64 `thrift:"payer,3" db:"payer" json:"payer"`
  ID *Uint64 `thrift:"id,4" db:"id" json:"id"`
  Secondary []byte `thrift:"secondary,5" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleStoreArgs() *ApplyDbIdxLongDoubleStoreArgs {
  return &ApplyDbIdxLongDoubleStoreArgs{}
}

var ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleStoreArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleStoreArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleStoreArgs_Payer_DEFAULT
  }
return p.Payer
}
var ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleStoreArgs) GetID() *Uint64 {
  if !p.IsSetID() {
    return ApplyDbIdxLongDoubleStoreArgs_ID_DEFAULT
  }
return p.ID
}

func (p *ApplyDbIdxLongDoubleStoreArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) IsSetID() bool {
  return p.ID != nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ID = &Uint64{}
  if err := p.ID.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ID), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err) }
  if err := p.ID.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ID), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleStoreResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleStoreResult() *ApplyDbIdxLongDoubleStoreResult {
  return &ApplyDbIdxLongDoubleStoreResult{}
}

var ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleStoreResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleStoreResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleStoreResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_store_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleStoreResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleStoreResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleStoreResult(%+v)", *p)
}

// Attributes:
//  - Iterator
//  - Payer
//  - Secondary
type ApplyDbIdxLongDoubleUpdateArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
  Payer *Uint64 `thrift:"payer,2" db:"payer" json:"payer"`
  Secondary []byte `thrift:"secondary,3" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleUpdateArgs() *ApplyDbIdxLongDoubleUpdateArgs {
  return &ApplyDbIdxLongDoubleUpdateArgs{}
}


func (p *ApplyDbIdxLongDoubleUpdateArgs) GetIterator() int32 {
  return p.Iterator
}
var ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpdateArgs) GetPayer() *Uint64 {
  if !p.IsSetPayer() {
    return ApplyDbIdxLongDoubleUpdateArgs_Payer_DEFAULT
  }
return p.Payer
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleUpdateArgs) IsSetPayer() bool {
  return p.Payer != nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Payer = &Uint64{}
  if err := p.Payer.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Payer), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "payer", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:payer: ", p), err) }
  if err := p.Payer.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Payer), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:payer: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleUpdateResult struct {
}

func NewApplyDbIdxLongDoubleUpdateResult() *ApplyDbIdxLongDoubleUpdateResult {
  return &ApplyDbIdxLongDoubleUpdateResult{}
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpdateResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleRemoveArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleRemoveArgs() *ApplyDbIdxLongDoubleRemoveArgs {
  return &ApplyDbIdxLongDoubleRemoveArgs{}
}


func (p *ApplyDbIdxLongDoubleRemoveArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleRemoveArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveArgs(%+v)", *p)
}

type ApplyDbIdxLongDoubleRemoveResult struct {
}

func NewApplyDbIdxLongDoubleRemoveResult() *ApplyDbIdxLongDoubleRemoveResult {
  return &ApplyDbIdxLongDoubleRemoveResult{}
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleRemoveResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoubleNextArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoubleNextArgs() *ApplyDbIdxLongDoubleNextArgs {
  return &ApplyDbIdxLongDoubleNextArgs{}
}


func (p *ApplyDbIdxLongDoubleNextArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoubleNextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleNextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleNextResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleNextResult() *ApplyDbIdxLongDoubleNextResult {
  return &ApplyDbIdxLongDoubleNextResult{}
}

var ApplyDbIdxLongDoubleNextResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoubleNextResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleNextResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleNextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_next_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleNextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleNextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleNextResult(%+v)", *p)
}

// Attributes:
//  - Iterator
type ApplyDbIdxLongDoublePreviousArgs struct {
  Iterator int32 `thrift:"iterator,1" db:"iterator" json:"iterator"`
}

func NewApplyDbIdxLongDoublePreviousArgs() *ApplyDbIdxLongDoublePreviousArgs {
  return &ApplyDbIdxLongDoublePreviousArgs{}
}


func (p *ApplyDbIdxLongDoublePreviousArgs) GetIterator() int32 {
  return p.Iterator
}
func (p *ApplyDbIdxLongDoublePreviousArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Iterator = v
}
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "iterator", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:iterator: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Iterator)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.iterator (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:iterator: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoublePreviousResult struct {
  Success *NextPreviousReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoublePreviousResult() *ApplyDbIdxLongDoublePreviousResult {
  return &ApplyDbIdxLongDoublePreviousResult{}
}

var ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT *NextPreviousReturn
func (p *ApplyDbIdxLongDoublePreviousResult) GetSuccess() *NextPreviousReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoublePreviousResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoublePreviousResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NextPreviousReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_previous_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoublePreviousResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoublePreviousResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoublePreviousResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Primary
type ApplyDbIdxLongDoubleFindPrimaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Primary *Uint64 `thrift:"primary,4" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleFindPrimaryArgs() *ApplyDbIdxLongDoubleFindPrimaryArgs {
  return &ApplyDbIdxLongDoubleFindPrimaryArgs{}
}

var ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Table_DEFAULT
  }
return p.Table
}
var ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleFindPrimaryArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindPrimaryResult struct {
  Success *FindPrimaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindPrimaryResult() *ApplyDbIdxLongDoubleFindPrimaryResult {
  return &ApplyDbIdxLongDoubleFindPrimaryResult{}
}

var ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT *FindPrimaryReturn
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) GetSuccess() *FindPrimaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindPrimaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindPrimaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindPrimaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_primary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindPrimaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindPrimaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
type ApplyDbIdxLongDoubleFindSecondaryArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
}

func NewApplyDbIdxLongDoubleFindSecondaryArgs() *ApplyDbIdxLongDoubleFindSecondaryArgs {
  return &ApplyDbIdxLongDoubleFindSecondaryArgs{}
}

var ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleFindSecondaryArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) GetSecondary() []byte {
  return p.Secondary
}
func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleFindSecondaryResult struct {
  Success *FindSecondaryReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleFindSecondaryResult() *ApplyDbIdxLongDoubleFindSecondaryResult {
  return &ApplyDbIdxLongDoubleFindSecondaryResult{}
}

var ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT *FindSecondaryReturn
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) GetSuccess() *FindSecondaryReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleFindSecondaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleFindSecondaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FindSecondaryReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_find_secondary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleFindSecondaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleFindSecondaryResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleLowerboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleLowerboundArgs() *ApplyDbIdxLongDoubleLowerboundArgs {
  return &ApplyDbIdxLongDoubleLowerboundArgs{}
}

var ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleLowerboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleLowerboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleLowerboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleLowerboundResult() *ApplyDbIdxLongDoubleLowerboundResult {
  return &ApplyDbIdxLongDoubleLowerboundResult{}
}

var ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleLowerboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleLowerboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleLowerboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_lowerbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleLowerboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleLowerboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
//  - Secondary
//  - Primary
type ApplyDbIdxLongDoubleUpperboundArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
  Secondary []byte `thrift:"secondary,4" db:"secondary" json:"secondary"`
  Primary *Uint64 `thrift:"primary,5" db:"primary" json:"primary"`
}

func NewApplyDbIdxLongDoubleUpperboundArgs() *ApplyDbIdxLongDoubleUpperboundArgs {
  return &ApplyDbIdxLongDoubleUpperboundArgs{}
}

var ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Table_DEFAULT
  }
return p.Table
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetSecondary() []byte {
  return p.Secondary
}
var ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleUpperboundArgs) GetPrimary() *Uint64 {
  if !p.IsSetPrimary() {
    return ApplyDbIdxLongDoubleUpperboundArgs_Primary_DEFAULT
  }
return p.Primary
}
func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) IsSetPrimary() bool {
  return p.Primary != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Secondary = v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Primary = &Uint64{}
  if err := p.Primary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Primary), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "secondary", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:secondary: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Secondary); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.secondary (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:secondary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "primary", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:primary: ", p), err) }
  if err := p.Primary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Primary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:primary: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleUpperboundResult struct {
  Success *LowerBoundUpperBoundReturn `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleUpperboundResult() *ApplyDbIdxLongDoubleUpperboundResult {
  return &ApplyDbIdxLongDoubleUpperboundResult{}
}

var ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT *LowerBoundUpperBoundReturn
func (p *ApplyDbIdxLongDoubleUpperboundResult) GetSuccess() *LowerBoundUpperBoundReturn {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleUpperboundResult_Success_DEFAULT
  }
return p.Success
}
func (p *ApplyDbIdxLongDoubleUpperboundResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LowerBoundUpperBoundReturn{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_upperbound_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleUpperboundResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleUpperboundResult(%+v)", *p)
}

// Attributes:
//  - Code
//  - Scope
//  - Table
type ApplyDbIdxLongDoubleEndArgs struct {
  Code *Uint64 `thrift:"code,1" db:"code" json:"code"`
  Scope *Uint64 `thrift:"scope,2" db:"scope" json:"scope"`
  Table *Uint64 `thrift:"table,3" db:"table" json:"table"`
}

func NewApplyDbIdxLongDoubleEndArgs() *ApplyDbIdxLongDoubleEndArgs {
  return &ApplyDbIdxLongDoubleEndArgs{}
}

var ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetCode() *Uint64 {
  if !p.IsSetCode() {
    return ApplyDbIdxLongDoubleEndArgs_Code_DEFAULT
  }
return p.Code
}
var ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetScope() *Uint64 {
  if !p.IsSetScope() {
    return ApplyDbIdxLongDoubleEndArgs_Scope_DEFAULT
  }
return p.Scope
}
var ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT *Uint64
func (p *ApplyDbIdxLongDoubleEndArgs) GetTable() *Uint64 {
  if !p.IsSetTable() {
    return ApplyDbIdxLongDoubleEndArgs_Table_DEFAULT
  }
return p.Table
}
func (p *ApplyDbIdxLongDoubleEndArgs) IsSetCode() bool {
  return p.Code != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetScope() bool {
  return p.Scope != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Code = &Uint64{}
  if err := p.Code.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Code), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Scope = &Uint64{}
  if err := p.Scope.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Scope), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &Uint64{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := p.Code.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Code), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scope", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:scope: ", p), err) }
  if err := p.Scope.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Scope), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:scope: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:table: ", p), err) }
  return err
}

func (p *ApplyDbIdxLongDoubleEndArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ApplyDbIdxLongDoubleEndResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewApplyDbIdxLongDoubleEndResult() *ApplyDbIdxLongDoubleEndResult {
  return &ApplyDbIdxLongDoubleEndResult{}
}

var ApplyDbIdxLongDoubleEndResult_Success_DEFAULT int32
func (p *ApplyDbIdxLongDoubleEndResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ApplyDbIdxLongDoubleEndResult_Success_DEFAULT
  }
return *p.Success
}
func (p *ApplyDbIdxLongDoubleEndResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "db_idx_long_double_end_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ApplyDbIdxLongDoubleEndResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ApplyDbIdxLongDoubleEndResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ApplyDbIdxLongDoubleEndResult(%+v)", *p)
}


